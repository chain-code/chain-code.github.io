<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Basic on Soulmate</title>
    <link>https://chain-code.github.io/docs/ai/basic/</link>
    <description>Recent content in Basic on Soulmate</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://chain-code.github.io/docs/ai/basic/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>cursor续杯</title>
      <link>https://chain-code.github.io/docs/ai/basic/cursor%E7%BB%AD%E6%9D%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/cursor%E7%BB%AD%E6%9D%AF/</guid>
      <description>https://github.com/yeongpin/cursor-free-vip?tab=readme-ov-file
Windows：PowerShell
irm https://raw.githubusercontent.com/yeongpin/cursor-free-vip/main/scripts/install.ps1 | iex 先重置机器码
再用2925邮箱注册账号
不断更改账号</description>
    </item>
    
    <item>
      <title>MCP服务</title>
      <link>https://chain-code.github.io/docs/ai/basic/mcp%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/mcp%E6%9C%8D%E5%8A%A1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Opencv Cuda编译</title>
      <link>https://chain-code.github.io/docs/ai/basic/opencv_cuda%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/opencv_cuda%E7%BC%96%E8%AF%91/</guid>
      <description>相关参考资料 # 安装python
原生python官网下载地址，选择Windows版本。
cmake安装
CMake官方下载地址
其他版本下载地址：https://cmake.org/files/
opencv下载
Opencv官方下载地址，下载OpenCV – 4.8.0 Sources，下载解压opencv-4.8.0.zip
opencv_contrib
opencv_contrib官方下载地址，选择opencv对应的contrib版本，例如opencv4.8.0对应就是opencv_contrib-4.8.0.zip。下载后直接解压。
NUIDIA-cuDNN
NVIDIA cuDNN
visual studio 2019 16.11.43
https://learn.microsoft.com/en-us/visualstudio/releases/2019/history
编译相关文章 # https://blog.csdn.net/iracer/article/details/125360183
https://www.cnblogs.com/guojin-blogs/p/17939955
https://zhuanlan.zhihu.com/p/354838274
https://blog.csdn.net/fixed_zhang/article/details/110930716
https://blog.csdn.net/yangyu0515/article/details/129643486
https://blog.csdn.net/yangyu0515/article/details/133794355
https://www.rwr.ink/index.php/2023/11/07/opencv-with-cuda%E7%BC%96%E8%AF%91%E5%AE%9E%E6%88%98/
OpenCV CUDA 安装 # https://github.com/chrismeunier/OpenCV-CUDA-installation/blob/main/README.md#check-install-and-troubleshooting
Conda+PyTorch+OpenCV-contrib-cuda环境下，import cv2 出现dll找不到的问题 # https://blog.csdn.net/zMGAM/article/details/138158027
解决opencv编译中出现的#error: This file was generated by an older version of protoc which is (编C1189译源文件）问题 # https://blog.csdn.net/m0_58326153/article/details/142381832
https://github.com/opencv/opencv/issues/17389
https://blog.csdn.net/weixin_38934440/article/details/107093908
protoc下载地址
https://github.com/protocolbuffers/protobuf/tags?after=v3.29.3
实操准备 # opencv 4.8.0
opencv_contrib
cmake 3.27.7
visual Studio 2019</description>
    </item>
    
    <item>
      <title>pytorch食谱</title>
      <link>https://chain-code.github.io/docs/ai/basic/pytorch%E9%A3%9F%E8%B0%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/pytorch%E9%A3%9F%E8%B0%B1/</guid>
      <description>PyTorch食谱</description>
    </item>
    
    <item>
      <title>Trae使用心得分享</title>
      <link>https://chain-code.github.io/docs/ai/basic/trae%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/trae%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/</guid>
      <description>Trae介绍 # Trae 是字节跳动推出的一款融合了 AI 辅助编程、智能代码建议、生成代码文件 以及 灵活适配不同场景 的 IDE。它不仅能够帮助开发者更快地编写代码，还可以根据具体提示语生成代码并进行维护，从而优化开发流程，实现高效协作。
选择 Trae ，主要因为它是国产软件，有中文界面和文档，并且完全免费，完全免费，完全免费。缺点是bug较多，反应速度较慢，好的一点是字节几乎一天一更新，相信将来会变得更好。
Trae下载官网
主要功能 # 上下文 # 当你需要参考某个特定函数、接口的代码，或者想要了解某个文件、文件夹的整体内容，又或者想对整个工作空间有一个全局的认识时，就可以使用该技巧向 AI 助手获取相关信息。
可以选择Code、File、Folder、Workspace、Doc、Web不同功能，能够更好地满足复杂开发需求。
在选择代码上下文时，我常用的使用快捷键Ctrl+U添加,也可以将终端中的内容作为上下文
模型 # Trae 预置了一系列业内表现比较出色的模型，你可以直接切换不同的模型进行使用。此外，Trae 还支持通过 API 密钥（API Key）接入自定义模型，从而满足个性化的需求。
个人使用过程中，感觉Gemini-2.5-Pro-Preview模型、和Claude-3.7-Sonnet模型对于代码的理解相对于其他模型较好。
AI修复 # Trae会自动探测代码中存在的明显问题，并指明具体位置
根据指示，当鼠标位于上方会出现AI修复提示
点击修复按钮，Trae会给出修改建议如下：
代码补全 # 在光标所在位置，敲击回车键换行，AI 助手会阅读并理解当前代码，然后自动补全后续代码。
按下 Tab 键，接受所有自动补全的代码。
多模态图片 # 当你遇到一些用文字难以描述清楚的问题时，就可以使用该技巧通过添加图片的方式更准确高效地表达需求。
规则 # 可以通过制定规则来规范 AI 在 Trae IDE 内的行为。
比如：我告诉AI我的操作系统为Windows，跟我保持中文对话。
智能体+MCP # 智能体 # 智能体是你面向不同开发场景的编程助手。除内置的智能体 Builder 外，你还可以创建自定义智能体，通过灵活配置提示词和工具集，使其更高效地帮你完成复杂任务。
Trae 提供以下内置智能体：
Builder：Builder 可以帮助你从 0 到 1 开发一个完整的项目。根据你的需求，Builder 会调用不同的工具，包括分析代码文件的工具、编辑代码文件的工具、运行命令的工具等等，从而更加精确且有效地处理你的需求。 Builder with MCP：在 Builder 的基础上，你配置的所有 MCP Server 都会默认添加至 Builder with MCP，且不可编辑。 MCP # AI 模型通过连接外部应用，来扩展功能。每个外部应用的接口，都不一样，如果要接入10个应用，就要写10种接入代码，非常麻烦。而且，要是换一个模型，可能所有接入代码都要重写。</description>
    </item>
    
    <item>
      <title>借助AI编程工具从零构建数据可视化平台复盘</title>
      <link>https://chain-code.github.io/docs/ai/basic/%E5%80%9F%E5%8A%A9ai%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0%E5%A4%8D%E7%9B%98-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/%E5%80%9F%E5%8A%A9ai%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B3%E5%8F%B0%E5%A4%8D%E7%9B%98-/</guid>
      <description>上次看到晖哥使用Trae从零搭建了一个雷电云的埋点数据分析平台，感觉很有意思。正好迭代最后几天进入覆盖测试阶段，手上任务都做完了，也想搭建一个视频取证的数据统计分析平台；一来多学习学习前端知识，二来埋点数据可视化页面有助于团队基于数据做出更精准的决策和迭代优化。
项目说明 # 项目采用 Vite + Vue 3 + TypeScript 技术栈构建，并搭配了 Element Plus UI 组件库。通过 vue-router 管理页面导航，并使用 Axios 与公司部署的 Elastic APM 数据库进行交互。属于纯前端项目，没有任何后端代码。
项目使用Trae工具从零开始搭建，除了一些参数翻译字典手敲之外，全程由AI生成；项目所有功能都是基于视频取证产品埋点数据结构体设计，后续会根据产品需求在空闲之余继续添加功能；我是一个后端程序员，前端只是可以稍微看得懂代码。
效果展示 # 完整地址：http://172.16.60.141:3000 三楼同事可自行查看
概览 # 概览功能支持任务状态分布、版本分布、任务成功率等等。
数据展示 # 数据展示界面可删选所有记录、任务等，支持搜索等功能，详细界面还翻译了任务参数
任务使用排行榜 # 任务使用排行榜，分记录和任务两个维度，按使用次数排行。
点击具体任务，可查看此任务相关参数统计图，及每个任务的详细信息
像高级识别任务物体描述是加密上传到elastic平台的，这里还做了解密处理。
IP地址排行榜 # IP地址排行榜对不同IP的数据进行了分类统计排序，可直观看到我们的用户分布。
心得体会 # 最热门编程语言 # 这张图内大多数情形我们或多或少都经历过，虽说是网上的段子，但它真实记录了我们驾驭AI过程中走过的路。
转变角色 # 随着AI技术的发展，特别是像Trae这样的编程助手，正在如何重塑我们的开发工作流。我们基本上不再编码，是否可以逐渐向“架构师”的方向转变，从执行者到定义者再到决策者。技术知识仍然重要，但更重要的是理解业务需求、系统设计和用户体验等更广泛的技能。
整体规划 # 开发项目之前，先想清楚要做什么？它的框架是什么样的？想清楚之后，将它写入一个文档，可以让AI进行润色。我们在后面开发的过程中可以根据实际情况不断的修改这个文档，每当AI开始不受控制胡说八道的时候，先让它阅读一下这个文档，再跟上你的功能需求描述。
不仅仅是框架，当遇到一些重复且复杂的任务，也可以写成文档，让AI根据文档的流程去处理，避免AI自行发挥。
一次只办一件事 # 一次只办一件事情，不要让它同时做多个任务，贪多必失
你必须看得懂代码 # 如果你不知道它生成的代码是什么意思，或许刚开始没有什么问题；但随着你问的问题越来越多，功能越来越复杂，你埋下的“坑”就会像雪球一样越滚越大。一个微小的改动都可能引发连锁反应，AI还自行解决不了。由于你从未真正理解底层逻辑，排查和解决问题的困难很大，只能不断地将报错复制给AI，继续生成更多不可控的代码，形成恶性循环。
不要随意接受任何代码 # 当我们发现功能没有问题的时候，很容易接受所有代码。但这样会有隐患，你不知道它在什么时候改了一行会影响到其他功能的代码，与其后面排查半天，不如每次仔细审查每一行代码。
先问自己在问什么？ # 这是我在某个文章中看到的一句话，很受触动。
比如你在开发一个项目前，你问别人，你用什么开发工具？
很正常的提问，却是一个非常差的问题，因为它需要多步的沟通来确认真正的问题，跟晖哥之前说的“报联商”有相似的地方。比如，你指的是那类开发工具？（IDE、文本编辑器、版本控制、API测试？），或者针对什么技术栈？（前端、Java、Go、Python？），由或者你的使用场景是什么？
正确的提问方式是什么？ 以“开发工具”这个问题为例，先想清楚我要问什么。
你为什么想问这个？ 是你正在用的工具遇到了问题（例如：“VS Code在打开大型项目时卡顿，有何优化方案？”），还是你要开始学习一门新语言（例如：“刚开始学Go，有哪些轻量级的IDE推荐？”）？如果是前者，这完全是另一个“解决问题”而非“寻求推荐”的问题。问题解决了，你根本不用换工具。 如果你想找一个新工具，最基本的，你要定义什么是“合适”，罗列完整自己的需求。哪些是必须项，哪些是加分项，哪些可有可无。必须项： 免费、对Python支持好、调试方便。加分项： 界面美观、插件市场丰富、Git集成流畅。可有可无： 内置数据库管理工具。于是你的问题变成了：“我需要一个免费的、对Python和Django框架支持良好的IDE，调试功能要强大，有什么推荐？” 。 更进一步，你应该先搜索一下，了解主流的选择（比如PyCharm， VS Code， Vim等），看看相关的测评，试试它们的官方基础功能。把这些工具和你的需求进行匹配。现在，你的问题是：“我想学Python Web开发，需要免费且调试功能强的IDE。了解到VS Code很轻量且免费，PyCharm专业版收费但社区版免费。我的需求是免费 、Django支持好、 调试方便。请问社区版PyCharm和配置了Python插件的VS Code相比，在调试和Django支持上差距大吗？或者有更优解？” 对AI下达指令也是一样的道理，先问问自己在问什么？</description>
    </item>
    
    <item>
      <title>华为昇腾910B适配记录</title>
      <link>https://chain-code.github.io/docs/ai/basic/%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BE910b%E9%80%82%E9%85%8D%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/%E5%8D%8E%E4%B8%BA%E6%98%87%E8%85%BE910b%E9%80%82%E9%85%8D%E8%AE%B0%E5%BD%95/</guid>
      <description>华为昇腾910适配记录 # 昇腾配置信息 # npu-smi info lscpu free -h 查看cpu使用率 # top 或者htop
sudo apt install htop //安装 htop 环境安装 # 驱动安装 # 参考文档：https://www.hiascend.com/document/detail/zh/canncommercial/80RC2/softwareinst/instg/instg_0003.html?Mode=PmIns&amp;amp;OS=Ubuntu&amp;amp;Software=cannToolKit
下载地址：https://www.hiascend.com/hardware/firmware-drivers/community?product=2&amp;amp;model=15&amp;amp;cann=8.2.RC2&amp;amp;driver=Ascend+HDK+25.2.0
下载驱动对应版本文件：Ascend-hdk-310p-npu-driver_25.2.0_linux-aarch64.run 下载固件版本文件：Ascend-hdk-310p-npu-firmware_7.7.0.6.236.run CANN安装 # 参考文档：https://www.hiascend.com/document/detail/zh/canncommercial/81RC1/softwareinst/instg/instg_0008.html?Mode=PmIns&amp;amp;InstallType=local&amp;amp;OS=openEuler&amp;amp;Software=cannToolKit
下载地址：https://www.hiascend.com/developer/download/community/result?cann=8.2.RC2&amp;amp;product=2&amp;amp;model=15
Toolkit开发套件包：Ascend-cann-toolkit_8.2.RC2_linux-aarch64.run Kernels算子包：Ascend-cann-kernels-310p_8.2.RC2_linux-aarch64.run NNAL神经网络加速库：Ascend-cann-nnal_8.2.RC2_linux-aarch64.run pytorch安装 # 参考文档：https://www.hiascend.com/document/detail/zh/Pytorch/710/configandinstg/instg/insg_0004.html
其他用到的python环境 # (base) root@autodl-container-6ce943a632-c1481b25:~/python/service# pip list Package Version ------------------------------ ------------------ absl-py 2.3.0 albucore 0.0.24 albumentations 2.0.8 annotated-types 0.7.0 anyio 4.9.0 argon2-cffi 25.1.0 argon2-cffi-bindings 21.2.0 arrow 1.3.0 asttokens 3.0.0 async-lru 2.0.5 attrs 25.3.0 auto_tune 0.</description>
    </item>
    
    <item>
      <title>基础知识</title>
      <link>https://chain-code.github.io/docs/ai/basic/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>NumPy 数组 (numpy.ndarray) # 是什么？
NumPy (Numerical Python) 是 Python 语言的一个核心库，专门用于进行科学计算，特别是处理大型多维数组和矩阵。 NumPy 最核心的对象是 ndarray（N-dimensional array），它是一个同质（所有元素类型相同，如全是整数或全是浮点数）的多维数组。你可以把它想象成一个灵活的、强大的网格结构，可以是一维（向量）、二维（矩阵）、三维（立方体）甚至更高维度。 为什么重要？
性能： NumPy 底层是用 C 语言实现的，其数组操作（如数学运算、索引、切片）比 Python 内置的列表（list）快得多，尤其是处理大量数据时。这是因为它利用了向量化操作，避免了 Python 级别的循环。 内存效率： NumPy 数组在内存中是连续存储的（通常情况下），这使得访问和操作更加高效。 功能丰富： 提供了大量的数学函数（线性代gebra、傅里叶变换、随机数生成等）来操作这些数组。 生态基础： NumPy 是许多其他 Python 科学计算库（如 SciPy、Pandas、Scikit-learn、Matplotlib）的基础。很多库的输入输出都接受或返回 NumPy 数组。 关键特性：
维度 (Dimensions/Axes)： 数组的“方向”数量，称为 ndim。 形状 (Shape)： 一个描述数组在每个维度上大小的元组，称为 shape。例如，一个 3x4 的矩阵，shape 是 (3, 4)。 数据类型 (Data Type/dtype)： 数组中元素的数据类型，如 int32, float64, uint8 (常用于图像)。 常见用途：
任何需要高效数值计算的场景。 数据分析中的数据存储和预处理。 图像表示： 图像可以被看作是二维（灰度图）或三维（彩色图）的像素网格，NumPy 数组是表示它们的自然方式。例如，一个 640x480 的彩色图像可以用一个 shape 为 (480, 640, 3) 的 NumPy 数组表示（高度、宽度、颜色通道）。 示例：</description>
    </item>
    
    <item>
      <title>相关工具库</title>
      <link>https://chain-code.github.io/docs/ai/basic/%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%BA%93/</guid>
      <description>工具集合库 # Awesome DeepSeek Integrations</description>
    </item>
    
    <item>
      <title>项目收藏</title>
      <link>https://chain-code.github.io/docs/ai/basic/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/</guid>
      <description>https://github.com/Yuliang-Liu/MonkeyOCR
系统性的 LLM 学习教程</description>
    </item>
    
    <item>
      <title></title>
      <link>https://chain-code.github.io/docs/ai/basic/ai%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/ai/basic/ai%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/</guid>
      <description>title: &amp;#34;AI知识普及&amp;#34; weight: 1 # bookFlatSection: false # bookToc: true # bookHidden: false # bookCollapseSection: false # bookComments: false # bookSearchExclude: false AI的起源 # 人工神经网络的萌芽（1950年代） # 人工智能概念的提出后，发展出了符号主义、联结主义(神经网络)，相继取得了一批令人瞩目的研究成果，如机器定理证明、跳棋程序、人机对话等，掀起人工智能发展的第一个高潮。
1943年：首次出现神经网络理论。 1957年：首个人工神经网络模型“感知器”被提出。 停滞期开始（1960年代-1980年代） # 人工智能发展初期的突破性进展大大提升了人们对人工智能的期望，人们开始尝试更具挑战性的任务，然而计算力及理论等的匮乏使得不切实际目标的落空，人工智能的发展走入低谷。
1969年：提出“感知器”的局限性。 1986年：提出多层感知器理论。 人工神经网络的复苏（1990年代-2000年代） # 人工智能走入应用发展的新高潮。专家系统模拟人类专家的知识和经验解决特定领域的问题，实现了人工智能从理论研究走向实际应用、从一般推理策略探讨转向运用专门知识的重大突破。而机器学习(特别是神经网络)探索不同的学习策略和各种学习方法，在大量的实际应用中也开始慢慢复苏。
2006年：提出深度信念网络结构。 人工智能的平稳发展（20世纪90年代—2010年） # 由于互联网技术的迅速发展，加速了人工智能的创新研究，促使人工智能技术进一步走向实用化，人工智能相关的各个领域都取得长足进步。在2000年代初，由于专家系统的项目都需要编码太多的显式规则，这降低了效率并增加了成本，人工智能研究的重心从基于知识系统转向了机器学习方向。
深度学习的发展（2010年代-2020年代） # 随着大数据、云计算、互联网、物联网等信息技术的发展，泛在感知数据和图形处理器等计算平台推动以深度神经网络为代表的人工智能技术飞速发展，大幅跨越了科学与应用之间的技术鸿沟，诸如图像分类、语音识别、知识问答、人机对弈、无人驾驶等人工智能技术实现了重大的技术突破，迎来爆发式增长的新高潮。
2012年：AlexNet在ILSVRC竞赛中夺冠，标志着深度学习的突破。 2016年：阿尔法围棋（AlphaGo）赢得围棋比赛，展示了深度学习的强大能力。 生成式人工智能热潮的开始（2020年代至今） # 2022年，生成式人工智能（Generative AI）迎来了突破性进展，特别是在自然语言处理、图像生成、代码生成等领域取得显著成果。以OpenAI发布的GPT-3、GPT-4为代表的大型语言模型，能够生成与人类语言高度相似的文本内容，广泛应用于自动写作、对话系统、文本摘要等场景。同时，扩散模型（Diffusion Model）在图像生成领域崭露头角，能够生成高度逼真的图像和多模态内容，推动了艺术创作、虚拟现实、游戏设计等行业的变革。生成式人工智能的崛起标志着人工智能进入一个更加智能化、创意化、个性化的新阶段，正在深刻影响各行各业的发展。
人工智能，机器学习，深度学习等范围和概念 # 神经网络 # 神经网络(Artificial Neural Networks)：人工神经网络的简称， 是一种应用类似于大脑神经突触联接的结构或网络，进行信息处理的数学模型 。神经网络是一门重要机器学习技术，它是目前最火热的研究方向—深度学习之基础。
神经元 一个神经元通常具有多个树突，主要用来接受传入信息；而轴突只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“突触”。
单层神经网络数学模型 1943年，心理学家McCulloch和数学家Pitts参考了生物神经元的结构，发表了抽象的神经元模型MP，神经元模型是一个包含输入，输出与计算功能的模型。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。具体的神经元模型如下图所示：
一个简单神经元模型中每一个有向箭头线称为 连接 ；每一个连接上有一个值，称为权值或权重。连接是神经元中最重要的东西。每一个连接上都有一个权重。一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。
深度神经网络架构 深度神经网络又名深度学习网络，拥有多个隐藏层，包含数百万个链接在一起的人工神经元。名为权重的数字代表节点之间的连接。如果节点之间相互激励，则该权重为正值，如果节点之间相互压制，则该权重为负值。节点的权重值越高，对其他节点的影响力就越大。
代码示例 # 通过简单的神经网络来拟合二元一次方程</description>
    </item>
    
  </channel>
</rss>
