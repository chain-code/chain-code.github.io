<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="CGO入门 # Golang 自带的 CGO 可以支持与 C 语言接口的互通。
Go 与 C 的桥梁：cgo 入门，剖析与实践 - 知乎 (zhihu.com)
启用CGO特性 # 在 golang 代码中加入 import “C” 语句就可以启动 CGO 特性。这样在进行 go build 命令时，就会在编译和连接阶段启动 gcc 编译器。
package mainimport &#34;C&#34; // import &#34;C&#34;更像是一个关键字，CGO工具在预处理时会删掉这一行func main() {} 使用 -x 选项可以查看 go 程序编译过程中执行的所有指令。可以看到 golang 编译器已经为 test1.go 创建了 CGO 编译选项
[root@VM-centos ~/cgo_test/golink2]# go build -x test1.goWORK=/tmp/go-build330287398mkdir -p $WORK/b001/cd /root/cgo_test/golink2CGO_LDFLAGS=&#39;&#34;-g&#34; &#34;-O2&#34;&#39; /usr/lib/golang/pkg/tool/linux_amd64/cgo -objdir $WORK/b001/ -importpath command-line-arguments -- -I $WORK/b001/ -g -O2 .">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="CGo" />
<meta property="og:description" content="CGO入门 # Golang 自带的 CGO 可以支持与 C 语言接口的互通。
Go 与 C 的桥梁：cgo 入门，剖析与实践 - 知乎 (zhihu.com)
启用CGO特性 # 在 golang 代码中加入 import “C” 语句就可以启动 CGO 特性。这样在进行 go build 命令时，就会在编译和连接阶段启动 gcc 编译器。
package mainimport &#34;C&#34; // import &#34;C&#34;更像是一个关键字，CGO工具在预处理时会删掉这一行func main() {} 使用 -x 选项可以查看 go 程序编译过程中执行的所有指令。可以看到 golang 编译器已经为 test1.go 创建了 CGO 编译选项
[root@VM-centos ~/cgo_test/golink2]# go build -x test1.goWORK=/tmp/go-build330287398mkdir -p $WORK/b001/cd /root/cgo_test/golink2CGO_LDFLAGS=&#39;&#34;-g&#34; &#34;-O2&#34;&#39; /usr/lib/golang/pkg/tool/linux_amd64/cgo -objdir $WORK/b001/ -importpath command-line-arguments -- -I $WORK/b001/ -g -O2 ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chain-code.github.io/docs/c/cgo/" /><meta property="article:section" content="docs" />


<title>CGo | Soulmate</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.f8de3645fe00591b41524aee174e19edd98a22255a2930a0cdc82a94835ba387.css" integrity="sha256-&#43;N42Rf4AWRtBUkruF04Z7dmKIiVaKTCgzcgqlINbo4c=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.2042c1252d4fb3f5c39054bb88d5c386898b84d301c5b056af012e8abece95e8.js" integrity="sha256-IELBJS1Ps/XDkFS7iNXDhomLhNMBxbBWrwEuir7Oleg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>Soulmate</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>计算机基础</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1e99d92668627838818961f696faae00" class="toggle"  />
    <label for="section-1e99d92668627838818961f696faae00" class="flex justify-between">
      <a role="button" class="">八股文</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="">操作系统基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/" class="">数据库基础-牛客</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%9B%E5%AE%A2/" class="">计算机网络 牛客</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="">计算机网络基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" class="">数据库基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="">布隆过滤器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="">算法基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/linux%E5%9F%BA%E7%A1%80/" class="">Linux基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/git%E5%9F%BA%E7%A1%80/" class="">Git基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-00c75bd1eabdaaae0cac73d13168e71f" class="toggle"  />
    <label for="section-00c75bd1eabdaaae0cac73d13168e71f" class="flex justify-between">
      <a role="button" class="">其他</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/crontab%E4%BD%BF%E7%94%A8/" class="">crontab使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/libewf%E5%BA%93%E7%BC%96%E8%AF%91/" class="">libewf库编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/localhost%E4%B8%8E127.0.0.1/" class="">localhost与127.0.0.1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/schtasks%E4%BD%BF%E7%94%A8/" class="">schtask使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/swagger/" class="">Swagger</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/vim%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="">Vim编程常用快捷键</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" class="">代码整洁之道</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/" class="">代码注释</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8github%E5%92%8Cgitlab/" class="">同时使用github和gitlab</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E8%8E%B7%E5%8F%96%E5%86%85%E7%BD%91%E6%B4%BB%E8%B7%83ip/" class="">获取内网活跃IP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E9%80%9A%E8%BF%87%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97ip%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4/" class="">通过子网掩码计算IP地址范围</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E9%85%8D%E7%BD%AEkylinv10/" class="">配置 Kylin V10</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BD%91/" class="">虚拟组网</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3dcacc5e7a7c646c608757dc5f042d92" class="toggle"  />
    <label for="section-3dcacc5e7a7c646c608757dc5f042d92" class="flex justify-between">
      <a role="button" class="">LeetCode</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-10-14-golang%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B8%80/" class="">golang力扣刷题（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E4%B8%80/" class="">每日一题（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-11-04-golang%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%BA%8C/" class="">golang力扣刷题（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/%E5%BF%85%E5%88%B7top101/" class="">必刷top101</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-10-28-leetcode%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="">LeetCode算法总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-670eda717a06f31447c52422ec93a159" class="toggle"  />
    <label for="section-670eda717a06f31447c52422ec93a159" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-04-07-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%80/" class="">go语言基础（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/channel/" class="">Channel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go-%E4%B8%AD%E4%BD%BF%E7%94%A8-sync.pool-%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%99%B7%E9%98%B1/" class="">Go 中使用 sync.Pool 时可能遇到的陷阱</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golangci-lint/" class="">golangci-lint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golang%E6%8E%A7%E6%B5%81/" class="">Golang控流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golang%E9%99%90%E6%B5%81%E5%AE%9E%E8%B7%B5/" class="">golang限流实践</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D/" class="">go泛型介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/panic/" class="">panic</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/pprof/" class="">pprof</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/protobuf/" class="">ProtoBuf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/url/" class="">URL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86/" class="">包管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="">单元测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/io.copy/" class="">奇怪的io.copy</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81/" class="">常用业务代码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-10-26-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%BA%8C/" class="">go语言基础（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%89/" class="">go语言基础（三）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-go/" class="">数据结构-go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/" class="">go语言底层基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-12-20-benchmark%E6%B5%8B%E8%AF%95/" class="">benchmark测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/" class="">Go安全指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/json%E5%BA%8F%E5%88%97%E5%8C%96/" class="">Json序列化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E4%BD%BF%E7%94%A8ollvm%E6%B7%B7%E6%B7%86hello-world/" class="">使用 Ollvm混淆 Hello World</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E5%90%88%E9%9B%86/" class="">经验分享合集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/goland%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="">Goland常用技巧</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c453881a62c640f6a4cceec99c02477e" class="toggle"  />
    <label for="section-c453881a62c640f6a4cceec99c02477e" class="flex justify-between">
      <a role="button" class="">高阶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="">Go高阶-语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="">Go内存对齐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="">并发编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" class="">Go避坑指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%BA%93/" class="">Go高阶 语言类库</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="">go性能优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="">Go高阶 高级特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/%E6%98%93%E9%94%99%E7%BB%86%E8%8A%82/" class="">易错细节</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f235e88e751d2cb18d527c1784763605" class="toggle"  />
    <label for="section-f235e88e751d2cb18d527c1784763605" class="flex justify-between">
      <a role="button" class="">Package</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/flag/" class="">Flag</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/atomic/" class="">Atomic</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/os/" class="">Os</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/strconv/" class="">Strconv</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/sort/" class="">Sort</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/strings/" class="">Strings</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/reflect/" class="">Reflect</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/context/" class="">context</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/filepath/" class="">filepath</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/math/" class="">math</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/time/" class="">Time</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/sync/" class="">Sync</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-98f45c00d30ea45270982f872bd1c0bb" class="toggle"  />
    <label for="section-98f45c00d30ea45270982f872bd1c0bb" class="flex justify-between">
      <a role="button" class="">第三方库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/resty/" class="">resty</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/diskqueue/" class="">diskqueue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gofpdf/" class="">gofpdf</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>AI</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b671b3ce1ddd28af1b4312866c8b524" class="toggle"  />
    <label for="section-9b671b3ce1ddd28af1b4312866c8b524" class="flex justify-between">
      <a role="button" class="">Basic</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/cursor%E7%BB%AD%E6%9D%AF/" class="">cursor续杯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/mcp%E6%9C%8D%E5%8A%A1/" class="">MCP服务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/opencv_cuda%E7%BC%96%E8%AF%91/" class="">Opencv Cuda编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/pytorch%E9%A3%9F%E8%B0%B1/" class="">pytorch食谱</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/trae%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/" class="">Trae使用心得分享</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="">基础知识</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%BA%93/" class="">相关工具库</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/" class="">项目收藏</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/ai%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/" class="">Ai知识普及</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12d52a883bb94360d36ad3bbf0cb5fd3" class="toggle"  />
    <label for="section-12d52a883bb94360d36ad3bbf0cb5fd3" class="flex justify-between">
      <a role="button" class="">Computer Vision</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/ocr%E8%AF%86%E5%88%AB/" class="">Ocr识别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/reid%E6%95%B0%E6%8D%AE%E9%9B%86/" class="">Reid数据集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/reid%E8%A1%8C%E4%BA%BA%E9%87%8D%E8%AF%86%E5%88%AB/" class="">Reid行人重识别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo-world/" class="">yolo-world</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="">yolo底层原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo%E6%95%B0%E6%8D%AE%E9%9B%86/" class="">yolo数据集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E4%BB%8B%E7%BB%8D/" class="">图像增强介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E5%8E%9F%E7%90%86/" class="">图像超分原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E8%A7%86%E9%A2%91%E8%B6%85%E5%88%86/" class="">视频超分</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolov8%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B&#43;%E5%AE%9E%E8%B7%B5/" class="">Yolov8快速上手 实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-948cfe1684759289af9e39747f026a40" class="toggle"  />
    <label for="section-948cfe1684759289af9e39747f026a40" class="flex justify-between">
      <a role="button" class="">Generative AI</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/qwen2.5-vl%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" class="">Qwen2.5-vl源码部署</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/xinference%E5%9F%BA%E7%A1%80/" class="">Xinference基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/%E5%88%A9%E7%94%A8dspy%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90prompt/" class="">利用 Dspy自动生成 Prompt</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-ac8e4e2fda641053d78fc10cbbde236e" class="toggle" checked />
    <label for="section-ac8e4e2fda641053d78fc10cbbde236e" class="flex justify-between">
      <a role="button" class="">C</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/c/c&#43;&#43;%E9%83%A8%E7%BD%B2paddleocr/" class="">C&#43;&#43;部署PaddleOCR</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/cgo/" class="active">CGo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/cgo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="">CGO遇到的问题解决</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81/" class="">业务代码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/%E5%9C%A8cgo%E4%B8%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%B0%83%E7%94%A8dll%E6%96%87%E4%BB%B6/" class="">在CGO中集成和调用DLL文件</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Python</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9fa9875ee3af29ba8922d532968a7155" class="toggle"  />
    <label for="section-9fa9875ee3af29ba8922d532968a7155" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/" class="">python内存泄漏排查方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%9F%BA%E7%A1%80/" class="">python基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%AE%89%E8%A3%85/" class="">python安装</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" class="">venv虚拟环境</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/" class="">开发实例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%84%9A%E6%9C%AC/" class="">日常小脚本</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-76d10924673a9347dff74c68c3ea9d86" class="toggle"  />
    <label for="section-76d10924673a9347dff74c68c3ea9d86" class="flex justify-between">
      <a role="button" class="">Package</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/argparse/" class="">argparse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/collections/" class="">collections</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/detetime/" class="">datetime</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/decord/" class="">Decord</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/uvicorn/" class="">uvicorn</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="">正则表达式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>数据库</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-94f26238d1ca3b5bcd40eadc7a88d726" class="toggle"  />
    <label for="section-94f26238d1ca3b5bcd40eadc7a88d726" class="flex justify-between">
      <a role="button" class="">MySql</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="">MySql相关问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%94%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="">MySql锁相关总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2021-04-20-mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" class="">MySql基础总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="">Mac连接数据库所遇到的问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb%E5%AE%89%E8%A3%85/" class="">Mongodb安装</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96/" class="">数据库规范化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-01e4ef5e6295826a1eab8f1a7114ec2c" class="toggle"  />
    <label for="section-01e4ef5e6295826a1eab8f1a7114ec2c" class="flex justify-between">
      <a role="button" class="">Redis</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2022-03-21-redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="">Redis集群搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2022-03-20-redis%E5%9F%BA%E7%A1%80/" class="">Redis基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2021-05-02-redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="">redis面试总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8be9c2251abd1fe110e3c1520cac6177" class="toggle"  />
    <label for="section-8be9c2251abd1fe110e3c1520cac6177" class="flex justify-between">
      <a role="button" class="">SQLite</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/fts/" class="">fts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/sqlite/" class="">Sqlite</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96/" class="">Sqlite数据库插入优化</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/xorm/" class="">Xorm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/gorm/" class="">Gorm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" class="">常见数据库的备份与恢复</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>系统架构</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="">系统架构基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-083ca86fd1b56cca1f76a6d6b34dc093" class="toggle"  />
    <label for="section-083ca86fd1b56cca1f76a6d6b34dc093" class="flex justify-between">
      <a role="button" class="">设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">创建型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">结构型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">行为型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/" class="">设计模式扩展</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-266e66094f86ce336245af3b8aaf0e2e" class="toggle"  />
    <label for="section-266e66094f86ce336245af3b8aaf0e2e" class="flex justify-between">
      <a role="button" class="">微服务</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/grpc/" class="">Grpc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/grpc%E6%8B%A6%E6%88%AA%E5%99%A8retry/" class="">grpc拦截器retry</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="">微服务</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3d14fec58473cc9c35cafaca50699647" class="toggle"  />
    <label for="section-3d14fec58473cc9c35cafaca50699647" class="flex justify-between">
      <a role="button" class="">web框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/gin%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/" class="">Gin参数绑定</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/" class="">动态路由与静态路由</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/gin%E6%A1%86%E6%9E%B6/" class="">gin框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE/" class="">流式数据</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/beego%E6%A1%86%E6%9E%B6/" class="">Beego框架</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>前端</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/restfulapi/" class="">Restful API</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vite&#43;vue%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="">Vite&#43;Vue快速搭建项目</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vue3/" class="">Vue3</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="">Vue环境搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/websocket/" class="">Web Socket</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/webstorm-debug/" class="">WebStorm-debug</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>区块链</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-76bfb65f46ce25a0ff78d6cc4ad47773" class="toggle"  />
    <label for="section-76bfb65f46ce25a0ff78d6cc4ad47773" class="flex justify-between">
      <a role="button" class="">Fabric</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-02-25-fabric%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/" class="">fabric相关机制与原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-10-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" class="">智能合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-08-fabric-sdk-go%E8%AF%A6%E8%A7%A3/" class="">fabric-sdk-go详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-15-fabric-ca%E8%AF%A6%E8%A7%A3/" class="">fabric-ca详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1e3df3eda5cf08a9c7e8cc723288fefb" class="toggle"  />
    <label for="section-1e3df3eda5cf08a9c7e8cc723288fefb" class="flex justify-between">
      <a role="button" class="">环境测试</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/fabric%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%8A%A5%E9%94%99%E4%B8%80/" class="">fabric网络中的报错（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-22-fabric%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%8A%A5%E9%94%99%E4%BA%8C/" class="">fabric网络中的报错（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-24-fabric%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="">fabric环境搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-25-fabric-solo%E8%8A%82%E7%82%B9%E6%B5%8B%E8%AF%95/" class="">solo节点测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-25-fabric%E5%A4%9A%E6%9C%BA%E6%90%AD%E5%BB%BA/" class="">fabric多机搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-12-20-%E9%83%A8%E7%BD%B2tape%E6%B5%8B%E8%AF%95/" class="">部署tape测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-05-01-%E6%89%8B%E5%8A%A8%E7%94%9F%E6%88%90ca%E8%AF%81%E4%B9%A6%E6%90%AD%E5%BB%BAfabric%E7%BD%91%E7%BB%9C/" class="">手动生成ca证书搭建fabric网络</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-18-centos%E5%AE%89%E8%A3%85fabric1.2/" class="">centos安装fabric1.2</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-25aef1d59a561fcefcaecb043ef8afd2" class="toggle"  />
    <label for="section-25aef1d59a561fcefcaecb043ef8afd2" class="flex justify-between">
      <a role="button" class="">配置文件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-05-01-cryptogen%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/" class="">cryptogen生成的证书详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-30-config-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">config.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-30-docker-compose-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">docker-compose.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-29-configtx-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">configtx.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-29-crypto-config-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">crypto-config.yaml文件详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-04-14-%E5%8D%87%E7%BA%A7%E9%93%BE%E7%A0%81/" class="">升级链码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-03-25-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/" class="">区块链网络添加组织</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-02-fabric%E6%B5%8F%E8%A7%88%E5%99%A8%E6%90%AD%E5%BB%BA/" class="">fabric浏览器搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-17-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%B2%E6%9C%89%E7%BB%84%E7%BB%87%E4%B8%AD%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9/" class="">如何在已有组织中增加节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-15-fabric1.4%E5%A4%9A%E9%80%9A%E9%81%93%E5%AE%9E%E9%AA%8C/" class="">Fabric1.4多通道实验</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b07621083aa30b12de4c0333941e479f" class="toggle"  />
    <label for="section-b07621083aa30b12de4c0333941e479f" class="flex justify-between">
      <a role="button" class="">比特币</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/2022-02-25-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/" class="">比特币相关机制与原理</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ff5477999ef29208270c84e8b56b2758" class="toggle"  />
    <label for="section-ff5477999ef29208270c84e8b56b2758" class="flex justify-between">
      <a role="button" class="">IPFS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-12-05-go-ipfs-api/" class="">go-ipfs-api</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-07-12-ipfs-webui%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/" class="">ipfs-webui可视化工具搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-07-08-ipfs%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%80/" class="">IPFS基本原理（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-06-02-ipfs%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/" class="">IPFS私有网络搭建</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-77a0a17b06e8d04cfb0fba9952941706" class="toggle"  />
    <label for="section-77a0a17b06e8d04cfb0fba9952941706" class="flex justify-between">
      <a role="button" class="">密码学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2022-08-15-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" class="">区块链安全基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2021-04-12-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86/" class="">椭圆曲线加密</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2021-03-04-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" class="">密码学基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2e4d10b323fd668021dbd532575d8790" class="toggle"  />
    <label for="section-2e4d10b323fd668021dbd532575d8790" class="flex justify-between">
      <a role="button" class="">Docker</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/docker%E5%9F%BA%E7%A1%80/" class="">Docker基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/dockerfile/" class="">Dockerfile</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/2021-04-30-docker%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="">docker常用知识总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70383d7f28a7ae4bf840a844eb61aa16" class="toggle"  />
    <label for="section-70383d7f28a7ae4bf840a844eb61aa16" class="flex justify-between">
      <a role="button" class="">共识算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="">共识算法基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2022-03-26-raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" class="">Raft共识算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-5f7b667081fbae0581cd216f66d5102f" class="toggle"  />
    <label for="section-5f7b667081fbae0581cd216f66d5102f" class="flex justify-between">
      <a role="button" class="">博客</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8D%9A%E5%AE%A2/2022-08-27-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAhugo/" class="">个人博客搭建Hugo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAhexo/" class="">个人博客搭建Hexo</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%9B%BE%E4%B9%A6/" class="">图书</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%B7%A5%E5%85%B7%E5%BA%93/" class="">工具库</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/" class="">开源项目收藏</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="https://gitee.com/chaincode"  target="_blank" rel="noopener">
        Gitee
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>CGo</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#cgo入门">CGO入门</a>
          <ul>
            <li><a href="#启用cgo特性">启用CGO特性</a></li>
            <li><a href="#hello-cgo">Hello Cgo</a></li>
            <li><a href="#cgo-工具">cgo 工具</a></li>
          </ul>
        </li>
        <li><a href="#cgo-的-n-种用法">CGO 的 N 种用法</a>
          <ul>
            <li><a href="#go-调用自定义-c-程序">Go 调用自定义 C 程序</a></li>
            <li><a href="#go-调用-cc模块">Go 调用 C/C++模块</a></li>
            <li><a href="#c-调用-go-模块">C 调用 Go 模块</a></li>
          </ul>
        </li>
        <li><a href="#类型转换">类型转换</a>
          <ul>
            <li><a href="#数值类型">数值类型</a></li>
            <li><a href="#切片">切片</a></li>
            <li><a href="#字符串">字符串</a></li>
          </ul>
        </li>
        <li><a href="#初始化示例">初始化示例</a>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="cgo入门">
  CGO入门
  <a class="anchor" href="#cgo%e5%85%a5%e9%97%a8">#</a>
</h2>
<p>Golang 自带的 CGO 可以支持与 C 语言接口的互通。</p>
<p><a href="https://zhuanlan.zhihu.com/p/349197066">Go 与 C 的桥梁：cgo 入门，剖析与实践 - 知乎 (zhihu.com)</a></p>
<h3 id="启用cgo特性">
  启用CGO特性
  <a class="anchor" href="#%e5%90%af%e7%94%a8cgo%e7%89%b9%e6%80%a7">#</a>
</h3>
<p>在 golang 代码中加入 import “C” 语句就可以启动 CGO 特性。这样在进行 go build 命令时，就会在编译和连接阶段启动 gcc 编译器。</p>
<pre tabindex="0"><code>package main
import &#34;C&#34;      // import &#34;C&#34;更像是一个关键字，CGO工具在预处理时会删掉这一行

func main() {
}
</code></pre><p>使用 -x 选项可以查看 go 程序编译过程中执行的所有指令。可以看到 golang 编译器已经为 test1.go 创建了 CGO 编译选项</p>
<pre tabindex="0"><code>[root@VM-centos ~/cgo_test/golink2]# go build -x test1.go
WORK=/tmp/go-build330287398
mkdir -p $WORK/b001/
cd /root/cgo_test/golink2
CGO_LDFLAGS=&#39;&#34;-g&#34; &#34;-O2&#34;&#39; /usr/lib/golang/pkg/tool/linux_amd64/cgo -objdir $WORK/b001/ -importpath command-line-arguments -- -I $WORK/b001/ -g -O2 ./test1.go    # CGO编译选项
cd $WORK
gcc -fno-caret-diagnostics -c -x c - -o /dev/null || true
gcc -Qunused-arguments -c -x c - -o /dev/null || true
gcc -fdebug-prefix-map=a=b -c -x c - -o /dev/null || true
gcc -gno-record-gcc-switches -c -x c - -o /dev/null || true
.......
</code></pre><h3 id="hello-cgo">
  Hello Cgo
  <a class="anchor" href="#hello-cgo">#</a>
</h3>
<p>通过 import “C” 语句启用 CGO 特性后，CGO 会将上一行代码所处注释块的内容视为 C 代码块，被称为序文（preamble）。</p>
<pre tabindex="0"><code>// test2.go
package main

//#include &lt;stdio.h&gt;        //  序文中可以链接标准C程序库
import &#34;C&#34;

func main() {
    C.puts(C.CString(&#34;Hello, Cgo\n&#34;))
}
</code></pre><p>在序文中可以使用 C.func 的方式调用 C 代码块中的函数，包括库文件中的函数。对于 C 代码块的变量，类型也可以使用相同方法进行调用。</p>
<p>test2.go 通过 CGO 提供的 C.CString 函数将 Go 语言字符串转化为 C 语言字符串，最后再通过 C.puts 调用 &lt;stdio.h&gt;中的 puts 函数向标准输出打印字符串。</p>
<h3 id="cgo-工具">
  cgo 工具
  <a class="anchor" href="#cgo-%e5%b7%a5%e5%85%b7">#</a>
</h3>
<p>当你在包中引用 import &ldquo;C&rdquo;，go build 就会做很多额外的工作来构建你的代码，构建就不仅仅是向 go tool compile 传递一堆 .go 文件了，而是要先进行以下步骤：</p>
<p>1）cgo 工具就会被调用，在 C 转换 Go、Go 转换 C 的之间生成各种文件。</p>
<p>2）系统的 C 编译器会被调用来处理包中所有的 C 文件。</p>
<p>3）所有独立的编译单元会被组合到一个 .o 文件。</p>
<p>4）生成的 .o 文件会在系统的连接器中对它的引用进行一次检查修复。</p>
<p>cgo 是一个 Go 语言自带的特殊工具，可以使用命令 go tool cgo 来运行。它可以生成能够调用 C 语言代码的 Go 语言源文件，也就是说所有启用了 CGO 特性的 Go 代码，都会首先经过 cgo 的&quot;预处理&quot;。</p>
<p>对 test2.go，cgo 工具会在同目录生成以下文件</p>
<pre tabindex="0"><code>_obj--|
      |--_cgo.o             // C代码编译出的链接库
      |--_cgo_main.c        // C代码部分的main函数
      |--_cgo_flags         // C代码的编译和链接选项
      |--_cgo_export.c      //
      |--_cgo_export.h      // 导出到C语言的Go类型
      |--_cgo_gotypes.go    // 导出到Go语言的C类型
      |--test1.cgo1.go      // 经过“预处理”的Go代码
      |--test1.cgo2.c       // 经过“预处理”的C代码
</code></pre><h2 id="cgo-的-n-种用法">
  CGO 的 N 种用法
  <a class="anchor" href="#cgo-%e7%9a%84-n-%e7%a7%8d%e7%94%a8%e6%b3%95">#</a>
</h2>
<p>CGO 作为 Go 语言和 C 语言之间的桥梁，其使用场景可以分为两种：Go 调用 C 程序 和 C 调用 Go 程序。</p>
<h3 id="go-调用自定义-c-程序">
  Go 调用自定义 C 程序
  <a class="anchor" href="#go-%e8%b0%83%e7%94%a8%e8%87%aa%e5%ae%9a%e4%b9%89-c-%e7%a8%8b%e5%ba%8f">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// test3.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#cgo LDFLAGS: -L/usr/local/lib
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdlib.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define REPEAT_LIMIT 3              // CGO会保留C代码块中的宏定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">typedef struct{                     // 自定义结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int repeat_time;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    char* str;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}blob;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int SayHello(blob* pblob) {  // 自定义函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    for ( ;pblob-&gt;repeat_time &lt; REPEAT_LIMIT; pblob-&gt;repeat_time++){
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        puts(pblob-&gt;str);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cblob</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">blob</span>{}                               <span style="color:#75715e">// 在GO程序中创建的C对象，存储在Go的内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cblob</span>.<span style="color:#a6e22e">repeat_time</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cblob</span>.<span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CString</span>(<span style="color:#e6db74">&#34;Hello, World\n&#34;</span>)         <span style="color:#75715e">// C.CString 会在C的内存空间申请一个C语言字符串对象，再将Go字符串拷贝到C字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cblob</span>)                       <span style="color:#75715e">// &amp;cblob 取C语言对象cblob的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;ret&#34;</span>, <span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;repeat_time&#34;</span>, <span style="color:#a6e22e">cblob</span>.<span style="color:#a6e22e">repeat_time</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">free</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">cblob</span>.<span style="color:#a6e22e">str</span>))               <span style="color:#75715e">// C.CString 申请的C空间内存不会自动释放，需要显示调用C中的free释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>CGO 会保留序文中的宏定义，但是并不会保留注释，也不支持#program，<strong>C 代码块中的#program 语句极可能产生未知错误</strong>。</p>
<p>CGO 中<strong>使用 #cgo 关键字可以设置编译阶段和链接阶段的相关参数</strong>，可以使用 ${SRCDIR} 来表示 Go 包当前目录的绝对路径。</p>
<p>使用 C.结构名 或 C.struct_结构名 可以在 Go 代码段中定义 C 对象，并通过成员名访问结构体成员。</p>
<p>test3.go 中使用 C.CString 将 Go 字符串对象转化为 C 字符串对象，并将其传入 C 程序空间进行使用，由于 C 的内存空间不受 Go 的 GC 管理，因此需要显示的调用 C 语言的 free 来进行回收。详情见第三章。</p>
<h3 id="go-调用-cc模块">
  Go 调用 C/C++模块
  <a class="anchor" href="#go-%e8%b0%83%e7%94%a8-cc%e6%a8%a1%e5%9d%97">#</a>
</h3>
<h4 id="简单-go-调-c">
  简单 Go 调 C
  <a class="anchor" href="#%e7%ae%80%e5%8d%95-go-%e8%b0%83-c">#</a>
</h4>
<p>直接将完整的 C 代码放在 Go 源文件中，这种编排方式便于开发人员快速在 C 代码和 Go 代码间进行切换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/test4.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdio.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int SayHello() {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> puts(&#34;Hello World&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是当 CGO 中使用了大量的 C 语言代码时，将所有的代码放在同一个 go 文件中即不利于代码复用，也会影响代码的可读性。此时可以将 C 代码抽象成模块，再将 C 模块集成入 Go 程序中。</p>
<h4 id="go-调用-c-模块">
  Go 调用 C 模块
  <a class="anchor" href="#go-%e8%b0%83%e7%94%a8-c-%e6%a8%a1%e5%9d%97">#</a>
</h4>
<p>将 C 代码进行抽象，放到相同目录下的 C 语言源文件 hello.c 中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">include</span> &lt;<span style="color:#a6e22e">stdio</span>.<span style="color:#a6e22e">h</span>&gt;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">SayHello</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">puts</span>(<span style="color:#e6db74">&#34;Hello World&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在 Go 代码中，声明 SayHello() 函数，再引用 hello.c 源文件，就可以调起外部 C 源文件中的函数了。同理也可以将<strong>C 源码编译打包为静态库或动态库进行使用</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/test5.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;hello.c&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int SayHello();
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>test5.go 中只对 SayHello 函数进行了声明，然后再通过链接 C 程序库的方式加载函数的实现。那么同样的，也可以通过链接 C++程序库的方式，来实现 Go 调用 C++程序。</p>
<h4 id="go-调用-c模块">
  Go 调用 C++模块
  <a class="anchor" href="#go-%e8%b0%83%e7%94%a8-c%e6%a8%a1%e5%9d%97">#</a>
</h4>
<p>基于 test4。可以抽象出一个 hello 模块，将模块的接口函数在 hello.h 头文件进行定义</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">SayHello</span>();
</span></span></code></pre></div><p>再使用 C++来重新实现这个 C 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.cpp
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">include</span> &lt;<span style="color:#a6e22e">iostream</span>&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">include</span> <span style="color:#e6db74">&#34;hello.h&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">SayHello</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">std</span>::<span style="color:#a6e22e">cout</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Hello World&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后再在 Go 代码中，引用 hello.h 头文件，就可以调用 C++实现的 SayHello 函数了</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/test6.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;hello.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ret</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ret</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CGO 提供的这种面向 C 语言接口的编程方式，使得开发者可以使用是任何编程语言来对接口进行实现，只要最终满足 C 语言接口即可。</p>
<h3 id="c-调用-go-模块">
  C 调用 Go 模块
  <a class="anchor" href="#c-%e8%b0%83%e7%94%a8-go-%e6%a8%a1%e5%9d%97">#</a>
</h3>
<p>C 调用 Go 相对于 Go 调 C 来说要复杂多，可以分为两种情况。一是原生 Go 进程调用 C，C 中再反调 Go 程序。另一种是原生 C 进程直接调用 Go。</p>
<h4 id="go-实现的-c-函数">
  Go 实现的 C 函数
  <a class="anchor" href="#go-%e5%ae%9e%e7%8e%b0%e7%9a%84-c-%e5%87%bd%e6%95%b0">#</a>
</h4>
<p>如前述，开发者可以用任何编程语言来编写程序，只要支持 CGO 的 C 接口标准，就可以被 CGO 接入。那么同样可以用 Go 实现 C 函数接口。</p>
<p>在 test6.go 中，已经定义了 C 接口模块 hello.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">void</span> <span style="color:#a6e22e">SayHello</span>(<span style="color:#a6e22e">char</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">s</span>);
</span></span></code></pre></div><p>可以创建一个 hello.go 文件，来用 Go 语言实现 SayHello 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#include &lt;hello.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//export SayHello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SayHello</span>(<span style="color:#a6e22e">str</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">char</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">GoString</span>(<span style="color:#a6e22e">str</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>CGO 的//export SayHello 指令将 Go 语言实现的 SayHello 函数导出为 C 语言函数。这样再 Go 中调用 C.SayHello 时，最终调用的是 hello.go 中定义的 Go 函数 SayHello</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/test7.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// go run ../demo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//#include &#34;hello.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CString</span>(<span style="color:#e6db74">&#34;Hello World&#34;</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Go 程序先调用 C 的 SayHello 接口，由于 SayHello 接口链接在 Go 的实现上，又调到 Go。</p>
<p>看起来调起方和实现方都是 Go，但实际执行顺序是 Go 的 main 函数，调到 CGO 生成的 C 桥接函数，最后 C 桥接函数再调到 Go 的 SayHello。这部分会在第四章进行分析。</p>
<h4 id="原生-c-调用-go">
  原生 C 调用 Go
  <a class="anchor" href="#%e5%8e%9f%e7%94%9f-c-%e8%b0%83%e7%94%a8-go">#</a>
</h4>
<p>C 调用到 Go 这种情况比较复杂，Go 一般是便以为 c-shared/c-archive 的库给 C 调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// demo/hello.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//export hello
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hello</span>(<span style="color:#a6e22e">value</span> <span style="color:#66d9ef">string</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">char</span> {   <span style="color:#75715e">// 如果函数有返回值，则要将返回值转换为C语言对应的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CString</span>(<span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">value</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 此处一定要有main函数，有main函数才能让cgo编译器去把包编译成C的库
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>如果 Go 函数有多个返回值，会生成一个 C 结构体进行返回，结构体定义参考生成的.h 文件</p>
<p>生成 c-shared 文件 命令</p>
<pre tabindex="0"><code>go build -buildmode=c-shared -o hello.so hello.go
</code></pre><p>在 C 代码中，只需要引用 go build 生成的.h 文件，并在编译时链接对应的.so 程序库，即可从 C 调用 Go 程序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">// demo/test8.c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;hello.h&#34;                       //此处为上一步生成的.h文件</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> c1[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;did&#34;</span>;
</span></span><span style="display:flex;"><span>    GoString s1 <span style="color:#f92672">=</span> {c1,<span style="color:#a6e22e">strlen</span>(c1)};       <span style="color:#75715e">//构建Go语言的字符串类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>c <span style="color:#f92672">=</span> <span style="color:#a6e22e">hello</span>(s1);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;r:%s&#34;</span>,c);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译命令</p>
<pre tabindex="0"><code>gcc -o c_go main.c hello.so
</code></pre><p>C 函数调入进 Go，必须按照 Go 的规则执行，当主程序是 C 调用 Go 时，也同样有一个 Go 的 runtime 与 C 程序并行执行。这个 runtime 的初始化在对应的 c-shared 的库加载时就会执行。因此，在进程启动时就有两个线程执行，一个 C 的，一 (多)个是 Go 的。</p>
<h2 id="类型转换">
  类型转换
  <a class="anchor" href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>想要更好的使用 CGO 必须了解 Go 和 C 之间类型转换的规则</p>
<h3 id="数值类型">
  数值类型
  <a class="anchor" href="#%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b">#</a>
</h3>
<p>在 Go 语言中访问 C 语言的符号时，一般都通过虚拟的“C”包进行。比如C.int，C.char 就对应与 C 语言中的 int 和 char，对应于 Go 语言中的 int 和 byte。</p>
<p>C 语言和 Go 语言的数值类型对应如下:</p>
<table>
<thead>
<tr>
<th>c语言类型</th>
<th>Go-CGO类型</th>
<th>GO类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>C.char</td>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>singed char</td>
<td>C.schar</td>
<td>int8</td>
<td>1</td>
</tr>
<tr>
<td>unsigned char</td>
<td>C.uchar</td>
<td>uint8</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>C.short</td>
<td>int16</td>
<td>2</td>
</tr>
<tr>
<td>unsigned short</td>
<td>C.ushort</td>
<td>uint16</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>C.int</td>
<td>int32</td>
<td>4</td>
</tr>
<tr>
<td>unsigned int</td>
<td>C.uint</td>
<td>uint32</td>
<td>4</td>
</tr>
<tr>
<td>long long int</td>
<td>C.longlong</td>
<td>int64</td>
<td>8</td>
</tr>
<tr>
<td>unsigned long long int</td>
<td>C.ulonglong</td>
<td>uint64</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>C.float</td>
<td>float32</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>C.double</td>
<td>float64</td>
<td>8</td>
</tr>
<tr>
<td>size_t</td>
<td>C.size_t</td>
<td>uint</td>
<td>4/8</td>
</tr>
<tr>
<td>unsigned long</td>
<td>C.ulong</td>
<td>uint32</td>
<td></td>
</tr>
</tbody>
</table>
<p>Go 语言的 int 和 uint 在 32 位和 64 位系统下分别是 4 个字节和 8 个字节大小。它在 C 语言中的导出类型 GoInt 和 GoUint 在不同位数系统下内存大小也不同。</p>
<p>如下是 64 位系统中，Go 数值类型在 C 语言的导出列表</p>
<pre tabindex="0"><code>// _cgo_export.h
typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef float _Complex GoComplex64;
typedef double _Complex GoComplex128;
</code></pre><p>需要注意的是在 <strong>C 语言符号名前加上 Ctype， 便是其在 Go 中的导出名，因此在启用 CGO 特性后，Go 语言中禁止出现以Ctype 开头的自定义符号名，类似的还有Cfunc等</strong>。</p>
<p>可以在序文中引入_obj/_cgo_export.h 来显式使用 cgo 在 C 中的导出类型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GO" data-lang="GO"><span style="display:flex;"><span><span style="color:#75715e">// test9.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;_obj/_cgo_export.h&#34;                       // _cgo_export.h由cgo工具动态生成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">GoInt32 Add(GoInt32 param1, GoInt32 param2) {       // GoInt32即为cgo在C语言的导出类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> return param1 + param2;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// _Ctype_                      // _Ctype_ 会在cgo预处理阶段触发异常，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如下是 64 位系统中，C 数值类型在 Go 语言的导出列表</p>
<pre tabindex="0"><code>// _cgo_gotypes.go
type _Ctype_char int8
type _Ctype_double float64
type _Ctype_float float32
type _Ctype_int int32
type _Ctype_long int64
type _Ctype_longlong int64
type _Ctype_schar int8
type _Ctype_short int16
type _Ctype_size_t = _Ctype_ulong
type _Ctype_uchar uint8
type _Ctype_uint uint32
type _Ctype_ulong uint64
type _Ctype_ulonglong uint64
type _Ctype_void [0]byte
</code></pre><p>为了提高 C 语言的可移植性，更好的做法是通过 C 语言的 C99 标准引入的**``**头文件，不但每个数值类型都提供了明确内存大小，而且和 Go 语言的类型命名更加一致。</p>
<h3 id="切片">
  切片
  <a class="anchor" href="#%e5%88%87%e7%89%87">#</a>
</h3>
<p>Go 中切片的使用方法类似 C 中的数组，但是内存结构并不一样。C 中的数组实际上指的是一段连续的内存，而 Go 的切片在存储数据的连续内存基础上，还有一个头结构体，其内存结构如下</p>
<p>因此 Go 的切片不能直接传递给 C 使用，而是需要取切片的内部缓冲区的首地址(即首个元素的地址)来传递给 C 使用。使用这种方式把 Go 的内存空间暴露给 C 使用，可以大大减少 Go 和 C 之间参数传递时内存拷贝的消耗。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GO" data-lang="GO"><span style="display:flex;"><span><span style="color:#75715e">// test10.go
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">int SayHello(char* buff, int len) {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    char hello[] = &#34;Hello Cgo!&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    int movnum = len &lt; sizeof(hello) ? len:sizeof(hello);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    memcpy(buff, hello, movnum);                        // go字符串没有&#39;\0&#39;，所以直接内存拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    return movnum;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;unsafe&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">buff</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">8</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">SayHello</span>((<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">char</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">buff</span>[<span style="color:#ae81ff">0</span>])), <span style="color:#a6e22e">C</span>.int(len(<span style="color:#a6e22e">buff</span>)))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> string(<span style="color:#a6e22e">buff</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="字符串">
  字符串
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2">#</a>
</h3>
<p>Go 的字符串与 C 的字符串在底层的内存模型也不一样：</p>
<p>Go 的字符串并没有以&rsquo;\0&rsquo; 结尾，因此使用类似切片的方式，直接将 Go 字符串的首元素地址传递给 C 是不可行的。</p>
<h4 id="go-与-c-的字符串传递">
  Go 与 C 的字符串传递
  <a class="anchor" href="#go-%e4%b8%8e-c-%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%bc%a0%e9%80%92">#</a>
</h4>
<p>cgo 给出的解决方案是标准库函数 C.CString()，它会在 C 内存空间内申请足够的空间，并将 Go 字符串拷贝到 C 空间中。因此 C.CString 申请的内存在 C 空间中，因此需要显式的调用 C.free 来释放空间，如 test3。</p>
<p>如下是 C.CString()的底层实现</p>
<p>func _Cfunc_CString(s string) <em>_Ctype_char {        // 从Go string 到 C char</em> 类型转换
p := _cgo_cmalloc(uint64(len(s)+1))
pp := (<em>[1&laquo;30]byte)(p)
copy(pp[:], s)
pp[len(s)] = 0
return (</em>_Ctype_char)(p)
}</p>
<p>//go:cgo_unsafe_args
func _cgo_cmalloc(p0 uint64) (r1 unsafe.Pointer) {
_cgo_runtime_cgocall(_cgo_bb7421b6328a_Cfunc__Cmalloc, uintptr(unsafe.Pointer(&amp;p0)))
if r1 == nil {
runtime_throw(&ldquo;runtime: C malloc failed&rdquo;)
}
return
}
_Cfunc_CString</p>
<p>_Cfunc_CString 是 cgo 定义的从 Go string 到 C char* 的类型转换函数</p>
<p>1）使用_cgo_cmalloc 在 C 空间内申请内存(即不受 Go GC 控制的内存)</p>
<p>2）使用该段 C 内存初始化一个[]byte 对象</p>
<p>3）将 string 拷贝到[]byte 对象</p>
<p>4）将该段 C 空间内存的地址返回</p>
<p>它的实现方式类似前述，切片的类型转换。不同在于切片的类型转换，是将 Go 空间内存暴露给 C 函数使用。而_Cfunc_CString 是将 C 空间内存暴露给 Go 使用。</p>
<p>_cgo_cmalloc</p>
<p>定义了一个暴露给 Go 的 C 函数，用于在 C 空间申请内存</p>
<p>与 C.CString()对应的是从 C 字符串转 Go 字符串的转换函数 C.GoString()。C.GoString()函数的实现较为简单，检索 C 字符串长度，然后申请相同长度的 Go-string 对象，最后内存拷贝。</p>
<p>如下是 C.GoString()的底层实现</p>
<p>//go:linkname _cgo_runtime_gostring runtime.gostring
func _cgo_runtime_gostring(*_Ctype_char) string</p>
<p>func _Cfunc_GoString(p <em>_Ctype_char) string {           // 从C char</em> 到 Go string 类型转换
return _cgo_runtime_gostring(p)
}</p>
<p>//go:linkname gostring
func gostring(p *byte) string {             // 底层实现
l := findnull(p)
if l == 0 {
return &quot;&quot;
}
s, b := rawstring(l)
memmove(unsafe.Pointer(&amp;b[0]), unsafe.Pointer(p), uintptr(l))
return s
}
3.3.2、更高效的字符串传递方法
C.CString 简单安全，但是它涉及了一次从 Go 到 C 空间的内存拷贝，对于长字符串而言这会是难以忽视的开销。</p>
<p>Go 官方文档中声称 string 类型是”不可改变的“，但是在实操中可以发现，除了常量字符串会在编译期被分配到只读段，其他的动态生成的字符串实际上都是在堆上。</p>
<p>因此如果能够获得 string 的内存缓存区地址，那么就可以使用类似切片传递的方式将字符串指针和长度直接传递给 C 使用。</p>
<p>查阅源码，可知 String 实际上是由缓冲区首地址 和 长度构成的。这样就可以通过一些方式拿到缓存区地址。</p>
<p>type stringStruct struct {
str unsafe.Pointer  //str首地址
len int             //str长度
}
test11.go 将 fmt 动态生成的 string 转为自定义类型 MyString 便可以获得缓冲区首地址，将地址传入 C 函数，这样就可以在 C 空间直接操作 Go-String 的内存空间了，这样可以免去内存拷贝的消耗。</p>
<p>// test11.go
package main</p>
<p>/*
#include &lt;string.h&gt;
int SayHello(char* buff, int len) {
char hello[] = &ldquo;Hello Cgo!&rdquo;;
int movnum = len &lt; sizeof(hello) ? len:sizeof(hello);
memcpy(buff, hello, movnum);
return movnum;
}
*/
import &ldquo;C&rdquo;
import (
&ldquo;fmt&rdquo;
&ldquo;unsafe&rdquo;
)</p>
<p>type MyString struct {
Str *C.char
Len int
}
func main() {
s := fmt.Sprintf(&quot;             &ldquo;)
C.SayHello((*MyString)(unsafe.Pointer(&amp;s)).Str, C.int((*MyString)(unsafe.Pointer(&amp;s)).Len))
fmt.Print(s)
}
这种方法背离了 Go 语言的设计理念，如非必要，不要把这种代码带入你的工程，这里只是作为一种“黑科技”进行分享。</p>
<p>3.4、结构体，联合，枚举
cgo 中结构体，联合，枚举的使用方式类似，可以通过 C.struct_XXX 来访问 C 语言中 struct XXX 类型。union,enum 也类似。</p>
<p>3.4.1、结构体
如果结构体的成员名字中碰巧是 Go 语言的关键字，可以通过在成员名开头添加下划线来访问</p>
<p>如果有 2 个成员：一个是以 Go 语言关键字命名，另一个刚好是以下划线和 Go 语言关键字命名，那么以 Go 语言关键字命名的成员将无法访问（被屏蔽）</p>
<p>C 语言结构体中位字段对应的成员无法在 Go 语言中访问，如果需要操作位字段成员，需要通过在 C 语言中定义辅助函数来完成。对应零长数组的成员(C 中经典的变长数组)，无法在 Go 语言中直接访问数组的元素，但同样可以通过在 C 中定义辅助函数来访问。</p>
<p>结构体的内存布局按照 C 语言的通用对齐规则，在 32 位 Go 语言环境 C 语言结构体也按照 32 位对齐规则，在 64 位 Go 语言环境按照 64 位的对齐规则。对于指定了特殊对齐规则的结构体，无法在 CGO 中访问。</p>
<p>// test11.go
package main
/*
struct Test {
int a;
float b;
double type;
int size:10;
int arr1[10];
int arr2[];
};
int Test_arr2_helper(struct Test * tm ,int pos){
return tm-&gt;arr2[pos];
}
#pragma  pack(1)
struct Test2 {
float a;
char b;
int c;
};
*/
import &ldquo;C&rdquo;
import &ldquo;fmt&rdquo;
func main() {
test := C.struct_Test{}
fmt.Println(test.a)
fmt.Println(test.b)
fmt.Println(test._type)
//fmt.Println(test.size)        // 位数据
fmt.Println(test.arr1[0])
//fmt.Println(test.arr)         // 零长数组无法直接访问
//Test_arr2_helper(&amp;test, 1)</p>
<pre><code>test2 := C.struct_Test2{}
fmt.Println(test2.c)
//fmt.Println(test2.c)          // 由于内存对齐，该结构体部分字段Go无法访问
</code></pre>
<p>}
3.4.2、联合
Go 语言中并不支持 C 语言联合类型，它们会被转为对应大小的字节数组。</p>
<p>如果需要操作 C 语言的联合类型变量，一般有三种方法：第一种是在 C 语言中定义辅助函数；第二种是通过 Go 语言的&quot;encoding/binary&quot;手工解码成员(需要注意大端小端问题)；第三种是使用unsafe包强制转型为对应类型(这是性能最好的方式)。</p>
<p>test12 给出了 union 的三种访问方式</p>
<p>// test12.go
package main
/*
#include &lt;stdint.h&gt;
union SayHello {
int Say;
float Hello;
};
union SayHello init_sayhello(){
union SayHello us;
us.Say = 100;
return us;
}
int SayHello_Say_helper(union SayHello * us){
return us-&gt;Say;
}
*/
import &ldquo;C&rdquo;
import (
&ldquo;fmt&rdquo;
&ldquo;unsafe&rdquo;
&ldquo;encoding/binary&rdquo;
)</p>
<p>func main() {
SayHello := C.init_sayhello()
fmt.Println(&ldquo;C-helper &ldquo;,C.SayHello_Say_helper(&amp;SayHello))           // 通过C辅助函数
buff := C.GoBytes(unsafe.Pointer(&amp;SayHello), 4)
Say2 := binary.LittleEndian.Uint32(buff)
fmt.Println(&ldquo;binary &ldquo;,Say2)                 // 从内存直接解码一个int32
fmt.Println(&ldquo;unsafe modify &ldquo;, *(*C.int)(unsafe.Pointer(&amp;SayHello)))     // 强制类型转换
}
3.4.3、枚举
对于枚举类型，可以通过C.enum_xxx来访问 C 语言中定义的enum xxx结构体类型。</p>
<p>使用方式和 C 相同，这里就不列例子了</p>
<p>3.5、指针
在 Go 语言中两个指针的类型完全一致则不需要转换可以直接通用。如果一个指针类型是用 type 命令在另一个指针类型基础之上构建的，换言之两个指针底层是相同完全结构的指针，那么也可以通过直接强制转换语法进行指针间的转换。</p>
<p>但是 C 语言中，不同类型的指针是可以显式或隐式转换。cgo 经常要面对的是 2 个完全不同类型的指针间的转换，实现这一转换的关键就是 unsafe.Pointer,类似于 C 语言中的 Void*类型指针。</p>
<p>使用这种方式就可以实现不同类型间的转换，如下是从 Go - int32 到 *C.char 的转换。</p>
<p>四、内部机制
go tool cgo 是分析 CGO 内部运行机制的重要工具，本章根据 cgo 工具生成的中间代码，再辅以 Golang 源码中 runtime 部分，来对 cgo 的内部运行机制进行分析。</p>
<p>cgo 的工作流程为：代码预处理 -&gt; gcc 编译 -&gt; Go Complier 编译。其产生的中间文件如图所示</p>
<p>4.1、Go 调 C
Go 调 C 的过程比较简单。test13 中定义了一个 C 函数 sum，并在 Go 中调用了 C.sum。</p>
<p>package main</p>
<p>//int sum(int a, int b) { return a+b; }
import &ldquo;C&rdquo;</p>
<p>func main() {
println(C.sum(1, 1))
}
下面是 cgo 工具产生的中间文件，最重要的是 test13.cgo1.go，test13.cgo1.c，_cgo_gotypes.go</p>
<p>test13.cgo1.go
test13.cgo1.go 是原本 test13.go 被 cgo 处理之后的文件。</p>
<p>// Code generated by cmd/cgo; DO NOT EDIT.</p>
<p>//line test4.go:1:1
package main</p>
<p>//int sum(int a, int b) { return a+b; }
import _ &ldquo;unsafe&rdquo;</p>
<p>func main() {
println(( /<em>line :7:10</em>/_Cfunc_sum /<em>line :7:14</em>/)(1, 1))
}
这个文件才是 go complier 真正编译的代码。可以看到原本的C.sum 被改写为_Cfunc_sum，_Cfunc_sum的定义在_cgo_gotypes.go 中。</p>
<p>_cgo_gotypes.go
// Code generated by cmd/cgo; DO NOT EDIT.</p>
<p>package main</p>
<p>import &ldquo;unsafe&rdquo;</p>
<p>import _ &ldquo;runtime/cgo&rdquo;</p>
<p>import &ldquo;syscall&rdquo;</p>
<p>var _ syscall.Errno
func _Cgo_ptr(ptr unsafe.Pointer) unsafe.Pointer { return ptr }</p>
<p>//go:linkname _Cgo_always_false runtime.cgoAlwaysFalse
var _Cgo_always_false bool              //  永远为 false
//go:linkname _Cgo_use runtime.cgoUse
func _Cgo_use(interface{})              // 返回一个 Error
type _Ctype_int int32                   // CGO类型导出</p>
<p>type _Ctype_void [0]byte                // CGO类型导出</p>
<p>//go:linkname _cgo_runtime_cgocall runtime.cgocall
func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32            // Go调C的入口函数</p>
<p>//go:linkname _cgo_runtime_cgocallback runtime.cgocallback
func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr, uintptr)     //  回调入口</p>
<p>//go:linkname _cgoCheckPointer runtime.cgoCheckPointer
func _cgoCheckPointer(interface{}, interface{})             // 检查传入C的指针，防止传入了指向Go指针的Go指针</p>
<p>//go:linkname _cgoCheckResult runtime.cgoCheckResult
func _cgoCheckResult(interface{})               //  检查返回值，防止返回了一个Go指针</p>
<p>//go:cgo_import_static _cgo_53efb99bd95c_Cfunc_sum
//go:linkname __cgofn__cgo_53efb99bd95c_Cfunc_sum _cgo_53efb99bd95c_Cfunc_sum
var __cgofn__cgo_53efb99bd95c_Cfunc_sum byte                // 指向C空间的sum函
var _cgo_53efb99bd95c_Cfunc_sum = unsafe.Pointer(&amp;__cgofn__cgo_53efb99bd95c_Cfunc_sum)  // 将sum函数指针赋值给_cgo_53efb99bd95c_Cfunc_sum</p>
<p>//go:cgo_unsafe_args
func _Cfunc_sum(p0 _Ctype_int, p1 _Ctype_int) (r1 _Ctype_int) {
_cgo_runtime_cgocall(_cgo_53efb99bd95c_Cfunc_sum, uintptr(unsafe.Pointer(&amp;p0))) // 将参数塞到列表中，调用C函数
if _Cgo_always_false {
_Cgo_use(p0)            // 针对编译器的优化操作，为了将C函数的参数分配在堆上，实际永远不会执行
_Cgo_use(p1)
}
return
}
_cgo_gotypes.go 是 Go 调 C 的精髓，这里逐段分析。</p>
<p>_Cgo_always_false &amp; _Cgo_use
//go:linkname _Cgo_always_false runtime.cgoAlwaysFalse
var _Cgo_always_false bool              //  永远为 false
//go:linkname _Cgo_use runtime.cgoUse
func _Cgo_use(interface{})              // 返回一个 Error</p>
<p>&hellip;&hellip;&hellip;.</p>
<p>if _Cgo_always_false {
_Cgo_use(p0)            // 针对编译器的优化操作，为了将C函数的参数分配在堆上，实际永远不会执行
_Cgo_use(p1)
}
_Cgo_always_false 是一个&quot;常量&rdquo;，正常情况下永远为 false。</p>
<p>_Cgo_use的函数实现如下</p>
<p>// runtime/cgo.go
func cgoUse(interface{}) { throw(&ldquo;cgoUse should not be called&rdquo;) }
Go 中变量可以分配在栈或者堆上。栈中变量的地址会随着 go 程调度，发生变化。堆中变量则不会。</p>
<p>而程序进入到 C 空间后，会脱离 Go 程的调度机制，所以必须保证 C 函数的参数分配在堆上。</p>
<p>Go 通过在编译器里做逃逸分析来决定一个对象放栈上还是放堆上，不逃逸的对象放栈上，可能逃逸的放堆上。</p>
<p>由于栈上内存存在不需要 gc，内存碎片少，分配速度快等优点，所以 Go 会将变量更多的放在栈上。</p>
<p>_Cgo_use以 interface 类型为入参，编译器很难在编译期知道，变量最后会是什么类型，因此它的参数都会被分配在堆上。</p>
<p>_cgo_runtime_cgocall
//go:linkname _cgo_runtime_cgocall runtime.cgocall
func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32            // Go调C的入口函数
_cgo_runtime_cgocall是从 Go 调 C 的关键函数，这个函数里面做了一些调度相关的安排。</p>
<p>// Call from Go to C.
//
// This must be nosplit because it&rsquo;s used for syscalls on some
// platforms. Syscalls may have untyped arguments on the stack, so
// it&rsquo;s not safe to grow or scan the stack.
//
//go:nosplit
func cgocall(fn, arg unsafe.Pointer) int32 {
if !iscgo &amp;&amp; GOOS != &ldquo;solaris&rdquo; &amp;&amp; GOOS != &ldquo;illumos&rdquo; &amp;&amp; GOOS != &ldquo;windows&rdquo; {
throw(&ldquo;cgocall unavailable&rdquo;)
}</p>
<p>if fn == nil {
throw(&ldquo;cgocall nil&rdquo;)
}</p>
<p>if raceenabled {                // 数据竞争检测，与CGO无瓜
racereleasemerge(unsafe.Pointer(&amp;racecgosync))
}</p>
<p>mp := getg().m
mp.ncgocall++           // 统计 M 调用CGO次数
mp.ncgo++               // 周期内调用次数</p>
<p>// Reset traceback.
mp.cgoCallers[0] = 0    // 如果在cgo中creash，记录CGO的Traceback</p>
<p>// Announce we are entering a system call
// so that the scheduler knows to create another
// M to run goroutines while we are in the
// foreign code.
//
// The call to asmcgocall is guaranteed not to
// grow the stack and does not allocate memory,
// so it is safe to call while &ldquo;in a system call&rdquo;, outside
// the $GOMAXPROCS accounting.
//
// fn may call back into Go code, in which case we&rsquo;ll exit the
// &ldquo;system call&rdquo;, run the Go code (which may grow the stack),
// and then re-enter the &ldquo;system call&rdquo; reusing the PC and SP
// saved by entersyscall here.
entersyscall()      // 将M与P剥离，防止系统调用阻塞P的调度，保存上下文</p>
<p>// Tell asynchronous preemption that we&rsquo;re entering external
// code. We do this after entersyscall because this may block
// and cause an async preemption to fail, but at this point a
// sync preemption will succeed (though this is not a matter
// of correctness).
osPreemptExtEnter(mp)   // 关闭异步抢占</p>
<p>mp.incgo = true
errno := asmcgocall(fn, arg)            // 调用C函数fn</p>
<p>// Update accounting before exitsyscall because exitsyscall may
// reschedule us on to a different M.
mp.incgo = false
mp.ncgo&ndash;</p>
<p>osPreemptExtExit(mp)    // 打开异步抢占</p>
<p>exitsyscall()       // 寻找P来承载从C空间返回的Go程</p>
<p>// Note that raceacquire must be called only after exitsyscall has
// wired this M to a P.
if raceenabled {
raceacquire(unsafe.Pointer(&amp;racecgosync))
}</p>
<p>// From the garbage collector&rsquo;s perspective, time can move
// backwards in the sequence above. If there&rsquo;s a callback into
// Go code, GC will see this function at the call to
// asmcgocall. When the Go call later returns to C, the
// syscall PC/SP is rolled back and the GC sees this function
// back at the call to entersyscall. Normally, fn and arg
// would be live at entersyscall and dead at asmcgocall, so if
// time moved backwards, GC would see these arguments as dead
// and then live. Prevent these undead arguments from crashing
// GC by forcing them to stay live across this time warp.
KeepAlive(fn)               // 防止Go的gc，在C函数执行期间，回收相关参数，用法与前述_Cgo_use类似
KeepAlive(arg)
KeepAlive(mp)</p>
<p>return errno
}
Go 调入 C 之后，程序的运行将不受 Go 的 runtime 的管控。一个正常的 Go 函数是需要 runtime 的管控的，即函数的运行时间过长会导致 goroutine 的抢占，以及 GC 的执行会导致所有的 goroutine 被拉齐。</p>
<p>C 程序的执行，限制了 Go 的 runtime 的调度行为。为此，Go 的 runtime 会在进入到 C 程序之后，会标记这个运行 C 的线程 M 将其排除出调度。</p>
<p>此外，由于正常的 Go 程序运行在一个 2K 的栈上，而 C 程序需要一个无穷大的栈。因此在进去 C 函数之前需要把当前线程的栈从 2K 的栈切换到线程本身的系统栈上，即切换到 g0。</p>
<p>cgocall 中几个重要函数功能说明：</p>
<p>1）entersyscall() 将当前的 M 与 P 剥离，防止 C 程序独占 M 时，阻塞 P 的调度。</p>
<p>2）asmcgocall() 将栈切换到 g0 的系统栈，并执行 C 函数调用</p>
<p>3）exitsyscall()寻找合适的 P 来运行从 C 函数返回的 Go 程，优先选择调用 C 之前依附的 P，其次选择其他空闲的 P</p>
<p>下图是 Go 调 C 函数过程中，MPG 的调度过程。</p>
<p>当 Go 程在调用 C 函数时，会单独占用一个系统线程。因此如果在 Go 程中并发调用 C 函数，而 C 函数中又存在阻塞操作，就很可能会造成 Go 程序不停的创建新的系统线程，而 Go 并不会回收系统线程，过多的线程数会拖垮整个系统。</p>
<p>_cgoCheckPointer &amp; _cgoCheckResult
//go:linkname _cgoCheckPointer runtime.cgoCheckPointer
func _cgoCheckPointer(interface{}, interface{})             // 检查传入C的指针，防止传入了指向Go指针的Go指针</p>
<p>//go:linkname _cgoCheckResult runtime.cgoCheckResult
func _cgoCheckResult(interface{})               //  检查返回值，防止返回了一个Go指针
_cgoCheckPointer 检查传入 C 函数的参数，防止其中包含了指向 Go 指针的 Go 指针，防止间接指向的对象在 Go 调度中发生内存位置变化</p>
<p>_cgoCheckResult 与_cgoCheckPointer 类似 用于检测 C 函数调 Go 函数后，Go 函数的返回值。防止其包含了 Go 指针。</p>
<p>cgofncgo_53efb99bd95c_Cfunc_sum
//go:cgo_import_static _cgo_53efb99bd95c_Cfunc_sum
//go:linkname __cgofn__cgo_53efb99bd95c_Cfunc_sum _cgo_53efb99bd95c_Cfunc_sum
var __cgofn__cgo_53efb99bd95c_Cfunc_sum byte                // 指向C空间的sum函
var _cgo_53efb99bd95c_Cfunc_sum = unsafe.Pointer(&amp;__cgofn__cgo_53efb99bd95c_Cfunc_sum)  // 将sum函数指针赋值给_cgo_53efb99bd95c_Cfunc_sum
1)go:cgo_import_static 将 C 函数_cgo_53efb99bd95c_Cfunc_sum加载到 Go 空间中</p>
<p>go:linkname 将 Go 的 byte 对象__cgofn__cgo_53efb99bd95c_Cfunc_sum的内存空间链接到 C 函数 _cgo_53efb99bd95c_Cfunc_sum的内存空间
创建 Go 对象_cgo_53efb99bd95c_Cfunc_sum并赋值 C 函数地址。
前两行的_cgo_53efb99bd95c_Cfunc_sum指的是 C 函数的符号</p>
<p>最后一行的_cgo_53efb99bd95c_Cfunc_sum指的是 Go 的 unsafe 指针</p>
<p>通过上面三步，cgo 将 C 函数_cgo_53efb99bd95c_Cfunc_sum的地址赋值给了 Go 指针_cgo_53efb99bd95c_Cfunc_sum</p>
<p>_Cfunc_sum
_Cfunc_sum 是 C 函数 sum 在 Go 空间的入口。它的参数 p0，p1 通过_Cgo_use 逃逸到了堆上。</p>
<p>再将存储 C 函数地址的指针和参数列表传入_cgo_runtime_cgocall ，即可完成从 Go 调 C 函数。</p>
<p>//go:cgo_unsafe_args
func _Cfunc_sum(p0 _Ctype_int, p1 _Ctype_int) (r1 _Ctype_int) {
_cgo_runtime_cgocall(_cgo_53efb99bd95c_Cfunc_sum, uintptr(unsafe.Pointer(&amp;p0))) // 将参数塞到列表中，调用C函数
if _Cgo_always_false {
_Cgo_use(p0)            // 针对编译器的优化操作，为了将C函数的参数分配在堆上，实际永远不会执行
_Cgo_use(p1)
}
return
}
其函数调用流程如图示：</p>
<p>4.2、C 调 Go
C 调 Go 的过程相对 Go 调 C 来说更为复杂，又可以分为两种情况。一种是从 Go 调用 C，然后 C 再调 Go。另一种是原生的 C 线程调 Go。</p>
<p>在 test14 中，分别创建了 test14.go 和 hello.go，两者之间通过 C 函数调起。</p>
<p>// demo/hello.go
package main</p>
<p>/*
*/
import &ldquo;C&rdquo;
import &ldquo;fmt&rdquo;</p>
<p>//export GSayHello
func GSayHello(value *C.char) C.int{   // 如果函数有返回值，则要将返回值转换为C语言对应的类型
fmt.Print(C.GoString(value))
return C.int(1)
}</p>
<p>// demo/test14.go
package main</p>
<p>/*
void CSayHello(char * s, int a){
GSayHello(s, a);
}
*/
import &ldquo;C&rdquo;</p>
<p>func main(){
buff := C.CString(&ldquo;hello cgo&rdquo;)
C.CSayHello(buff, C.int(10))
}
可以看到 test14 的工作流程是，从 Go 调到 C 的CSayHello 函数，再从CSayHello调用 Go 的GSayHello函数。从 Go 调 C 的流程上节已经分析，这里主要关注从 C 调 Go 的部分。使用 cgo 工具对 hello.go 进行分析，C 调 Go 函数主要在_cgo_gotypes.go(Go 函数导出) 和 _cgo_export.c(C 调 Go 入口)。</p>
<p>_cgo_gotypes.go
首先对被 C 调用的GSayHello函数的分析。GSayHello的实现在_cgo_gotypes.go，剔除与 4.1 中重复部分，_cgo_gotypes.go 源码如下</p>
<p>// _cgo_gotypes.go</p>
<p>//go:cgo_export_dynamic GSayHello
//go:linkname _cgoexp_25bb4eb897ab_GSayHello _cgoexp_25bb4eb897ab_GSayHello
//go:cgo_export_static _cgoexp_25bb4eb897ab_GSayHello
//go:nosplit
//go:norace
func _cgoexp_25bb4eb897ab_GSayHello(a unsafe.Pointer, n int32, ctxt uintptr) {
fn := _cgoexpwrap_25bb4eb897ab_GSayHello
_cgo_runtime_cgocallback(**(**unsafe.Pointer)(unsafe.Pointer(&amp;fn)), a, uintptr(n), ctxt);
}</p>
<p>func _cgoexpwrap_25bb4eb897ab_GSayHello(p0 *_Ctype_char) (r0 _Ctype_int) {
return GSayHello(p0)
}
1）go:cgo_export_dynamic 在内链模式(internal linking)下将 Go 的 hello 函数符号暴露给 C</p>
<p>2）go:linkname _cgoexp_bb7421b6328a_hello _cgoexp_bb7421b6328a_hello 将 Go 函数_cgoexp_bb7421b6328a_hello链接到符号_cgoexp_bb7421b6328a_hello上</p>
<p>3）go:cgo_export_static _cgoexp_bb7421b6328a_hello在外链模式(external linking)下将_cgoexp_bb7421b6328a_hello符号暴露给 C</p>
<p>4）go:nosplit go:norace 关闭溢出检测 关闭竞态管理</p>
<p>_cgoexp_bb7421b6328a_hello 即为 C 调用 Go 函数的入口函数，之后调用到_cgoexpwrap_25bb4eb897ab_GSayHello ，最后调用到用户定义的 Go 函数GSayHello。</p>
<p>_cgo_export.c
_cgo_export.c 包含了 C 调用 Go 函数的入口 和 暴露给 Go 的内存分配函数_Cfunc__Cmalloc(void *v)。</p>
<p>C 代码较为简单，不过多分析</p>
<p>/* Code generated by cmd/cgo; DO NOT EDIT. */</p>
<p>#include &lt;stdlib.h&gt;
#include &ldquo;_cgo_export.h&rdquo;</p>
<p>#pragma GCC diagnostic ignored &ldquo;-Wunknown-pragmas&rdquo;
#pragma GCC diagnostic ignored &ldquo;-Wpragmas&rdquo;
#pragma GCC diagnostic ignored &ldquo;-Waddress-of-packed-member&rdquo;
extern void crosscall2(void (*fn)(void *, int, <strong>SIZE_TYPE</strong>), void *, int, <strong>SIZE_TYPE</strong>);         // 保存C环境的上下文，并调起Go函数
extern <strong>SIZE_TYPE</strong> _cgo_wait_runtime_init_done(void);
extern void _cgo_release_context(<strong>SIZE_TYPE</strong>);</p>
<p>extern char* _cgo_topofstack(void);
#define CGO_NO_SANITIZE_THREAD
#define _cgo_tsan_acquire()
#define _cgo_tsan_release()</p>
<p>#define _cgo_msan_write(addr, sz)</p>
<p>extern void _cgoexp_25bb4eb897ab_GSayHello(void *, int, <strong>SIZE_TYPE</strong>);</p>
<p>CGO_NO_SANITIZE_THREAD
int GSayHello(char* value)          // test1.cgo2.c中调用的 GSayHello
{
<strong>SIZE_TYPE</strong> _cgo_ctxt = _cgo_wait_runtime_init_done();
struct {
char* p0;
int r0;
char __pad0[4];
} <strong>attribute</strong>((<strong>packed</strong>, <strong>gcc_struct</strong>)) _cgo_a;
_cgo_a.p0 = value;
_cgo_tsan_release();
crosscall2(_cgoexp_25bb4eb897ab_GSayHello, &amp;_cgo_a, 16, _cgo_ctxt);
_cgo_tsan_acquire();
_cgo_release_context(_cgo_ctxt);
return _cgo_a.r0;
}
crosscall2对应的底层函数是 runtime.cgocallback，cgocallback 会恢复 Golang 运行时所需的环境包括 Go 函数地址，栈帧和上下文，然后会调用到 cgocallback_gofunc。</p>
<p>cgocallback_gofunc，首先判断当前线程是否为 Go 线程，再讲线程栈切到 Go 程栈，再将函数地址，参数地址等信息入 Go 程栈，最后调用到 cgocallbackg。</p>
<p>cgocallbackg确认 Go 程准备完毕后，就将线程从系统调用状态退出(见上节 exitsyscall)，此时程序运行在 G 栈上，进入 cgocallbackg1 函数。</p>
<p>cgocallbackg1调用 reflectcall，正式进入到用户定义的 Go 函数。</p>
<p>如下是函数调用关系：</p>
<p>从 Go 调入到 C 函数时，系统线程会被切到 G0 运行，之后从 C 再回调到 Go 时，会直接在同一个 M 上从 G0 切回到普通的 Go 程，在这个过程中并不会创建新的系统线程。</p>
<p>从原生 C 线程调用 Go 函数的流程与这个类似，C 程序在一开始就有两个线程，一个是 C 原生线程，一个是 Go 线程，当 C 函数调起 Go 函数时，会切到 Go 线程运行。</p>
<p>如下是 Go 调 C，C 再调 Go 过程中，MPG 的调度流程。</p>
<p>五、总结
CGO 是一个非常优秀的工具，大部分使用 CGO 所造成的问题，都是因为使用方法不规范造成的。希望本文可以帮助大家更好的使用 CGO。</p>
<pre tabindex="0"><code>libewf_handle_t *handle,
</code></pre><p><a href="https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html">2.1 快速入门 · Go语言高级编程 (studygolang.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/349197066">Go 与 C 的桥梁：cgo 入门，剖析与实践 - 知乎 (zhihu.com)</a></p>
<p><a href="https://bbs.huaweicloud.com/community/usersnew/id_1510903197647472">赵志强的博客_云社区-华为云 (huaweicloud.com)</a></p>
<p><a href="https://blog.csdn.net/wei_gw2012/article/details/86666506">(1105条消息) 使用cgo，由于内存释放导致内存无效，引起的http crash_go 内存申请失败_冬生0的博客-CSDN博客</a></p>
<p><a href="https://xiaorui.cc/archives/5408">cgo阻塞调用引起golang线程暴增 – 峰云就她了 (xiaorui.cc)</a></p>
<p><a href="https://bbs.huaweicloud.com/blogs/117132">【Free Style】CGO: Go与C互操作技术（三）：Go调C性能分析及优化-云社区-华为云 (huaweicloud.com)</a></p>
<pre tabindex="0"><code>C.libewf_handle_initialize(&amp;this.pFile, &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>该函数的作用是初始化一个ewf_handle_t类型的结构体，该结构体代表了一个EnCase数据文件(.E01)的处理器。
EnCase是一种数字取证软件，可以用来收集和分析电脑上的证据数据。EnCase数据文件是通过将证据数据打包成一个或多个E01文件来创建的，这些文件可以使用libewf库进行处理。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_initialize(ewf_handle_t handle, int verify)
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>handle</code>：需要进行初始化的ewf_handle_t类型的结构体指针；</li>
<li><code>verify</code>：在初始化过程中是否进行验证，0表示不验证，1表示验证，整数类型。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_open(this.pFile, &amp;cpath, 1, LIBEWF_ACCESS_FLAG_WRITE, &amp;this.poLibewfErr) != 1 
</code></pre><blockquote>
<p>该函数的作用是打开一个EnCase数据文件(.E01)并返回一个ewf_handle_t类型的结构体指针，该结构体代表了打开的EnCase数据文件。</p>
</blockquote>
<pre tabindex="0"><code>ewf_handle_t libewf_handle_open(const char *filename,
                                const char *password, 
                                int32_t offset,
                                int32_t read_only, 
                                int32_t verify)
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>filename</code>：需要打开的EnCase数据文件的文件名，字符串类型；</li>
<li><code>password</code>：打开EnCase数据文件所需的密码，如果不需要密码则为NULL，字符串类型；</li>
<li><code>offset</code>：EnCase数据文件的偏移量，以字节为单位，整数类型；</li>
<li><code>read_only</code>：打开EnCase数据文件的方式，0表示可读可写，1表示只读，整数类型；</li>
<li><code>verify</code>：在打开EnCase数据文件时是否进行验证，0表示不验证，1表示验证，整数类型。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_open_wide(this.pFile, &amp;cpath, 1, LIBEWF_ACCESS_FLAG_WRITE, &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>该函数返回一个ewf_handle_t类型的指针，代表已经打开的EnCase数据文件。这个指针可以被传递给其他libewf库中的函数，以进行数据的读取和处理。</p>
<p><code>C.libewf_handle_open_wide</code> 函数与 <code>C.libewf_handle_open</code> 函数相似，但其可以接受宽字符类型的文件名和密码。在处理Unicode或其他宽字符编码的文件名时，可以使用这个函数打开EnCase数据文件。</p>
</blockquote>
<pre tabindex="0"><code>ewf_handle_t libewf_handle_open_wide(const wchar_t *filename,
                                     const wchar_t *password,
                                     int32_t offset, 
                                     int32_t read_only,
                                     int32_t verify)
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>filename</code>：需要打开的EnCase数据文件的文件名，宽字符类型；</li>
<li><code>password</code>：打开EnCase数据文件所需的密码，如果不需要密码则为NULL，宽字符类型；</li>
<li><code>offset</code>：EnCase数据文件的偏移量，以字节为单位，整数类型；</li>
<li><code>read_only</code>：打开EnCase数据文件的方式，0表示可读可写，1表示只读，整数类型；</li>
<li><code>verify</code>：在打开EnCase数据文件时是否进行验证，0表示不验证，1表示验证，整数类型。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_set_format(this.pFile, (C.uchar)(this.format), &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>该函数返回一个整数类型的值，表示设置操作的状态。如果返回值为0，则表示设置成功；如果返回值为负数，则表示设置失败并且可能会返回错误代码。</p>
<p><code>C.libewf_handle_set_format</code> 函数的作用是设置代表EnCase数据文件的格式。EnCase数据文件可以采用多种格式，例如Encase 1、Encase 2、Encase 3、Encase 4等等。通过调用此函数，可以设置代表EnCase数据文件的格式，以便在处理数据时正确地解释和使用数据。该函数需要一个代表处理器的指针、一个代表EnCase数据文件格式的字符串和一个选项字符串作为参数。</p>
<p>选项字符串的格式因格式而异，可以为空字符串或包含各种参数。例如，对于Encase 6格式，选项字符串可以设置以下参数：sector_size、compression、cipher、key、iv等等。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_set_format(ewf_handle_t handle, const char *format, const char *option)
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>handle</code>：需要设置格式的ewf_handle_t类型的结构体指针；</li>
<li><code>format</code>：代表EnCase数据文件的格式的字符串；</li>
<li><code>option</code>：选项字符串。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_set_bytes_per_sector(this.pFile, 512, &amp;this.poLibewfErr) != 1 
</code></pre><blockquote>
<p>作用是设置EnCase数据文件中每个扇区的字节数。该函数需要一个代表EnCase数据文件的句柄、一个代表每个扇区的字节数的整数，以及一个选项字符串作为参数。默认情况下，每个扇区的字节数为 512 字节。可以使用该函数更改此值。请注意，更改此值可能会导致读取数据时出现问题，因此请谨慎使用此函数。</p>
<p>选项字符串的格式因格式而异，可以为空字符串或包含各种参数。例如，对于Encase 6格式，选项字符串可以设置以下参数：sector_size、compression、cipher、key、iv等等。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_set_bytes_per_sector(ewf_handle_t ewf_handle, uint32_t bytes_per_sector, const char *options)
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>ewf_handle</code>：代表EnCase数据文件的句柄；</li>
<li><code>bytes_per_sector</code>：每个扇区的字节数；</li>
<li><code>options</code>：选项字符串。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_set_sectors_per_chunk(this.pFile, (C.uint)(chunkSize/512), &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>作用是设置 EnCase 数据文件中每个块包含的扇区数。默认情况下，每个块包含 64 个扇区。可以使用该函数更改此值。请注意，更改此值可能会导致读取数据时出现问题，因此请谨慎使用此函数。</p>
<p>选项字符串的格式因格式而异，可以为空字符串或包含各种参数。例如，对于 Encase 6 格式，选项字符串可以设置以下参数：sector_size、compression、cipher、key、iv 等等。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_set_sectors_per_chunk(ewf_handle_t ewf_handle, uint32_t sectors_per_chunk, const char *options);
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>ewf_handle</code>：代表 EnCase 数据文件的句柄；</li>
<li><code>sectors_per_chunk</code>：每个块包含的扇区数；</li>
<li><code>options</code>：选项字符串。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_set_maximum_segment_size(this.pFile, (C.size64_t)(this.segSize), &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>作用是设置 EnCase 数据文件中每个分段的最大大小。默认情况下，每个分段的最大大小为 0，表示没有最大大小限制。可以使用该函数更改此值。请注意，更改此值可能会导致读取数据时出现问题，因此请谨慎使用此函数。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_set_maximum_segment_size(ewf_handle_t ewf_handle, uint32_t maximum_segment_size, const char *options);
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>ewf_handle</code>：代表 EnCase 数据文件的句柄；</li>
<li><code>maximum_segment_size</code>：每个分段的最大大小，单位是字节；</li>
<li><code>options</code>：选项字符串。</li>
</ul>
</blockquote>
<pre tabindex="0"><code>C.libewf_handle_set_compression_values(this.pFile, LIBEWF_COMPRESSION_FAST, 0, &amp;this.poLibewfErr) != 1
</code></pre><blockquote>
<p>作用是设置 EnCase 数据文件中的压缩选项。可以使用该函数指定压缩类型和压缩级别。默认情况下，不进行压缩。请注意，更改此选项可能会导致读取数据时出现问题，因此请谨慎使用此函数。</p>
</blockquote>
<pre tabindex="0"><code>int libewf_handle_set_compression_values(ewf_handle_t ewf_handle, const char *compression_type, uint8_t compression_level, const char *options);
</code></pre><blockquote>
<p>该函数的参数说明如下：</p>
<ul>
<li><code>ewf_handle</code>：代表 EnCase 数据文件的句柄；</li>
<li><code>compression_type</code>：压缩类型，如 <code>none</code>、<code>deflate</code>、<code>bzip2</code> 等；</li>
<li><code>compression_level</code>：压缩级别，取值范围为 0 到 9，0 表示不压缩；</li>
<li><code>options</code>：选项字符串。</li>
</ul>
</blockquote>
<h4 id="gobool">
  goBOOl
  <a class="anchor" href="#gobool">#</a>
</h4>
<p><code>goBOOL()</code> 是一个将值转换为Go的布尔值的表达式。</p>
<p>在CGO中，C函数的返回类型和Go函数的返回类型可能不完全匹配。为了将C函数的返回值转换为Go的布尔值，可以使用<code>goBOOL()</code>函数。</p>
<p><code>goBOOL()</code>函数是一个自定义的辅助函数，用于将C的整数类型转换为Go的布尔值。它通常定义为一个简单的条件语句，将C整数类型的值与0进行比较，并返回相应的Go布尔值。</p>
<p>以下是一个示例定义<code>goBOOL()</code>函数的方式：</p>
<pre tabindex="0"><code>func goBOOL(cInt C.int) bool {
    if cInt != 0 {
        return true
    }
    return false
}
</code></pre><p>在示例中，<code>goBOOL()</code>函数接受一个C整数类型的参数<code>cInt</code>，并在不为0时返回<code>true</code>，否则返回<code>false</code>。</p>
<h2 id="初始化示例">
  初始化示例
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%a4%ba%e4%be%8b">#</a>
</h2>
<h4 id="结构体">
  结构体
  <a class="anchor" href="#%e7%bb%93%e6%9e%84%e4%bd%93">#</a>
</h4>
<pre tabindex="0"><code>typedef struct tagNET_DVR_LOG_V30 {
    //结构体初始
} NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;
</code></pre><pre tabindex="0"><code> LPNET_DVR_LOG_V30 logData = new NET_DVR_LOG_V30();
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>    <span style="color:#75715e">// 分配内存并初始化结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">logData</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">NET_DVR_LOG_V30</span>)(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">malloc</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">sizeof_NET_DVR_LOG_V30</span>))
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 使用 logData
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最后记得释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">free</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">logData</span>))
</span></span></code></pre></div><pre tabindex="0"><code>DH_DEVICE_LOG_ITEM_EX* szLogInfos = new(DH_DEVICE_LOG_ITEM_EX[1024]);
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">szLogInfos</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">DH_DEVICE_LOG_ITEM_EX</span>, <span style="color:#ae81ff">1024</span>)
</span></span></code></pre></div><pre tabindex="0"><code>int len = 0;
sizeof(DH_DEV_ENABLE_INFO) 获取 DH_DEV_ENABLE_INFO 这个结构体的大小（以字节为单位）
len == sizeof(DH_DEV_ENABLE_INFO)
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">loglen</span> <span style="color:#a6e22e">C</span>.<span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">stDevEn</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">DH_DEV_ENABLE_INFO</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">sizeof_DH_DEV_ENABLE_INFO</span>
</span></span><span style="display:flex;"><span>int(<span style="color:#a6e22e">loglen</span>) <span style="color:#f92672">==</span> int(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">sizeof_DH_DEV_ENABLE_INFO</span>)
</span></span></code></pre></div><pre tabindex="0"><code>NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY stInparam;
memset(&amp;stInparam, 0, sizeof(stInparam));
定义了一个名为 stInparam 的结构体变量，并使用 memset 函数将该结构体变量的内存空间全部设置为0
stInparam.dwSize = sizeof(stInparam);
stInparam 结构体变量中的 dwSize 成员赋值。通常情况下，结构体中的 dwSize 成员用于指定结构体本身的大小，这样可以方便在函数调用时传递结构体参数并进行正确的处理。
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">stInparam</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">NET_IN_LOGIN_WITH_HIGHLEVEL_SECURITY</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">stInparam</span>.<span style="color:#a6e22e">dwSize</span> = <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">DWORD</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">stInparam</span>))
</span></span></code></pre></div><h4 id="位域结构体类型">
  位域结构体类型
  <a class="anchor" href="#%e4%bd%8d%e5%9f%9f%e7%bb%93%e6%9e%84%e4%bd%93%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<pre tabindex="0"><code>typedef struct _DHDEVTIME
{
    DWORD                second:6;                /// 秒    1-60        
    DWORD                minute:6;                /// 分    1-60        
    DWORD                hour:5;                  /// 时    1-24        
    DWORD                day:5;                   /// 日    1-31        
    DWORD                month:4;                 /// 月    1-12        
    DWORD                year:6;                  /// 年    2000-2063    
} DHDEVTIME, *LPDHDEVTIME;
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">stuOperateTime</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">szLogInfos</span>[<span style="color:#a6e22e">i</span>].<span style="color:#a6e22e">stuOperateTime</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//转成字节流
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">binary</span>.<span style="color:#a6e22e">LittleEndian</span>.<span style="color:#a6e22e">Uint32</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">GoBytes</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">stuOperateTime</span>), <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">sizeof_struct__DHDEVTIME</span>))
</span></span><span style="display:flex;"><span><span style="color:#75715e">//unsafe.Pointer(stuOperateTime) 将 stuOperateTime 转换为一个通用的指针类型 unsafe.Pointer，这是 Go 和 C 互操作时常见的做法。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//C.sizeof_struct__DHDEVTIME 是 DHDEVTIME 结构体的大小，表示我们要读取的字节数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 提取各个字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">second</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3F</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//0x3F 是十六进制数，表示 6 个二进制位的掩码（111111）。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//&amp; 是按位与操作，用来提取 dhTimeValue 的最低 6 位，这些位表示秒的值。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">minute</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">6</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3F</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//dhTimeValue &gt;&gt; 6 将 dhTimeValue 右移 6 位，忽略最低的 6 位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">hour</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1F</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">day</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">17</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x1F</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">month</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">22</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x0F</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">year</span> <span style="color:#f92672">:=</span> (<span style="color:#a6e22e">dhTimeValue</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">26</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x3F</span>
</span></span></code></pre></div><p><code>C.GoBytes</code> 是一个用于将 C 语言内存块转换为 Go 字节切片的函数。它的签名如下：</p>
<pre tabindex="0"><code>func GoBytes(ptr unsafe.Pointer, length C.int) []byte
</code></pre><p>它将从 <code>ptr</code> 指向的内存位置开始，读取 <code>length</code> 字节，并返回一个 Go 字节切片。</p>
<h4 id="数组">
  数组
  <a class="anchor" href="#%e6%95%b0%e7%bb%84">#</a>
</h4>
<pre tabindex="0"><code>BYTE    sPanelUser[MAX_NAMELEN]
</code></pre><pre tabindex="0"><code>hikvisionlog.HkUser = C.GoString((*C.char)(unsafe.Pointer(&amp;logData.sPanelUser[0])))
</code></pre><pre tabindex="0"><code> char    sInfo[LOG_INFO_LEN]
</code></pre><pre tabindex="0"><code>C.GoString(&amp;logData.sInfo[0])
</code></pre></article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#cgo入门">CGO入门</a>
          <ul>
            <li><a href="#启用cgo特性">启用CGO特性</a></li>
            <li><a href="#hello-cgo">Hello Cgo</a></li>
            <li><a href="#cgo-工具">cgo 工具</a></li>
          </ul>
        </li>
        <li><a href="#cgo-的-n-种用法">CGO 的 N 种用法</a>
          <ul>
            <li><a href="#go-调用自定义-c-程序">Go 调用自定义 C 程序</a></li>
            <li><a href="#go-调用-cc模块">Go 调用 C/C++模块</a></li>
            <li><a href="#c-调用-go-模块">C 调用 Go 模块</a></li>
          </ul>
        </li>
        <li><a href="#类型转换">类型转换</a>
          <ul>
            <li><a href="#数值类型">数值类型</a></li>
            <li><a href="#切片">切片</a></li>
            <li><a href="#字符串">字符串</a></li>
          </ul>
        </li>
        <li><a href="#初始化示例">初始化示例</a>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












