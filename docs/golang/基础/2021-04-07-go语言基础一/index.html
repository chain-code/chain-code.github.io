<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="第一章 概述 # go语言特征 # 简单
并发模型
go语言从根部将一切都并发化，运行时用Goroutine运行所有的一切，包括main.main入口函数。Goroutine是go的显著特征。它用类协程的方式处理并发单元，又在运行时层面做了更深度的优化处理。搭配channel,实现CSP模型。
csp模型
Actor 模型中 Actor 之间就是不能共享内存的，彼此之间通信只能依靠消息传递的方式。Golang 实现的 CSP 模型和 Actor 模型看上去非常相似，虽然 Golang 中协程之间，也能够以共享内存的方式通信，但是并不推荐；而推荐的以通信的方式共享内存，实际上指的就是协程之间以消息传递方式来通信。
Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。
Go语言的CSP模型是由协程Goroutine与通道Channel实现：
Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。 通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。 内存分配
刨去因配合垃圾回收器而修改的内容，内存分配器完整的保留了tcmalloc的原始架构。除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。
垃圾回收
​ go垃圾回收不咋地
静态链接 只须编译一个可执行文件，无须附加任何东西就能部署。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。
标准库 工具链 设计初衷 # 少即是多（less is more）：如果一个特性并不对解决任何问题有显著价值，那么go就不提供它；如果需要一个特性，那么只有一种方法去实现 面向接口编程：非侵入式接口，反对继承、反对虚函数和虚函数重载（多态）、删除构造和析构函数 正交&#43;组合的语言特性：语言的特性之间相互独立，不相互影响。比如类型和方法是互相独立的，类型之间也是相互独立的，没有子类，包也没有子包。不同特性用组合的方式来松耦合 并发在语言层面支持：并发更好利用多核，有更强的表现力来模拟真实世界 在设计上，Go秉承了C的简单粗暴。
为什么没有继承 # Go没有子类型的概念，只能把类型嵌入到另一个类型中，所以没有类型系统。Go的作者认为类型系统被过度使用了，应该在这个方向上退一步。
使用伸缩性良好的组合，而不是继承 数据和方法不再绑定在一起，数据的集合用struct，方法的集合用interface，保持正交 类似子类父类的系统造成非常脆弱的代码。类型的层次必须在早期进行设计，通常会是程序设计的第一步，但是一旦写出程序后，早期的决策就很难进行改变了。所以，类型层次结构会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。
作者附了一个例子，是一些以接口为参数并且其返回结果也是一个接口的函数：
// 入参是接口的函数，而不是成员方法func ReadAll(r io.Reader) ([]byte, error)// 封装器 - 出入参都是接口func LoggingReader(r io.Reader) io.Reader //读到的内容录入日志func LimitingReader(r io.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="go语言基础（一）" />
<meta property="og:description" content="第一章 概述 # go语言特征 # 简单
并发模型
go语言从根部将一切都并发化，运行时用Goroutine运行所有的一切，包括main.main入口函数。Goroutine是go的显著特征。它用类协程的方式处理并发单元，又在运行时层面做了更深度的优化处理。搭配channel,实现CSP模型。
csp模型
Actor 模型中 Actor 之间就是不能共享内存的，彼此之间通信只能依靠消息传递的方式。Golang 实现的 CSP 模型和 Actor 模型看上去非常相似，虽然 Golang 中协程之间，也能够以共享内存的方式通信，但是并不推荐；而推荐的以通信的方式共享内存，实际上指的就是协程之间以消息传递方式来通信。
Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。
Go语言的CSP模型是由协程Goroutine与通道Channel实现：
Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。 通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。 内存分配
刨去因配合垃圾回收器而修改的内容，内存分配器完整的保留了tcmalloc的原始架构。除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。
垃圾回收
​ go垃圾回收不咋地
静态链接 只须编译一个可执行文件，无须附加任何东西就能部署。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。
标准库 工具链 设计初衷 # 少即是多（less is more）：如果一个特性并不对解决任何问题有显著价值，那么go就不提供它；如果需要一个特性，那么只有一种方法去实现 面向接口编程：非侵入式接口，反对继承、反对虚函数和虚函数重载（多态）、删除构造和析构函数 正交&#43;组合的语言特性：语言的特性之间相互独立，不相互影响。比如类型和方法是互相独立的，类型之间也是相互独立的，没有子类，包也没有子包。不同特性用组合的方式来松耦合 并发在语言层面支持：并发更好利用多核，有更强的表现力来模拟真实世界 在设计上，Go秉承了C的简单粗暴。
为什么没有继承 # Go没有子类型的概念，只能把类型嵌入到另一个类型中，所以没有类型系统。Go的作者认为类型系统被过度使用了，应该在这个方向上退一步。
使用伸缩性良好的组合，而不是继承 数据和方法不再绑定在一起，数据的集合用struct，方法的集合用interface，保持正交 类似子类父类的系统造成非常脆弱的代码。类型的层次必须在早期进行设计，通常会是程序设计的第一步，但是一旦写出程序后，早期的决策就很难进行改变了。所以，类型层次结构会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。
作者附了一个例子，是一些以接口为参数并且其返回结果也是一个接口的函数：
// 入参是接口的函数，而不是成员方法func ReadAll(r io.Reader) ([]byte, error)// 封装器 - 出入参都是接口func LoggingReader(r io.Reader) io.Reader //读到的内容录入日志func LimitingReader(r io." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chain-code.github.io/docs/golang/%E5%9F%BA%E7%A1%80/2021-04-07-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%80/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-04-07T16:58:12+00:00" />
<meta property="article:modified_time" content="2021-04-07T16:58:12+00:00" />
<title>go语言基础（一） | Soulmate</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.f8de3645fe00591b41524aee174e19edd98a22255a2930a0cdc82a94835ba387.css" integrity="sha256-&#43;N42Rf4AWRtBUkruF04Z7dmKIiVaKTCgzcgqlINbo4c=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.6afb70210ee6d316d0c3f1b285dd52598071699979c6a9b9d5f9a33153362168.js" integrity="sha256-avtwIQ7m0xbQw/Gyhd1SWYBxaZl5xqm51fmjMVM2IWg=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>Soulmate</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>计算机基础</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1e99d92668627838818961f696faae00" class="toggle"  />
    <label for="section-1e99d92668627838818961f696faae00" class="flex justify-between">
      <a role="button" class="">八股文</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="">操作系统基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/linux%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="">Linux问题总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/" class="">数据库基础-牛客</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E7%89%9B%E5%AE%A2%E5%85%AB%E8%82%A1/" class="">牛客八股</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E8%A7%86%E9%A2%98%E6%80%BB%E7%BB%93%E4%B8%80/" class="">面视题总结（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E9%9D%A2%E8%A7%86%E9%A2%98%E6%80%BB%E7%BB%93%E4%BA%8C/" class="">面视题总结（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" class="">计算机网络基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/" class="">数据库基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" class="">布隆过滤器</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="">算法基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/linux%E5%9F%BA%E7%A1%80/" class="">Linux基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%AB%E8%82%A1%E6%96%87/git%E5%9F%BA%E7%A1%80/" class="">Git基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-00c75bd1eabdaaae0cac73d13168e71f" class="toggle"  />
    <label for="section-00c75bd1eabdaaae0cac73d13168e71f" class="flex justify-between">
      <a role="button" class="">其他</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/crontab%E4%BD%BF%E7%94%A8/" class="">crontab使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/libewf%E5%BA%93%E7%BC%96%E8%AF%91/" class="">libewf库编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/localhost%E4%B8%8E127.0.0.1/" class="">localhost与127.0.0.1</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/schtasks%E4%BD%BF%E7%94%A8/" class="">schtask使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/swagger/" class="">Swagger</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/vim%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" class="">Vim编程常用快捷键</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/" class="">代码整洁之道</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A/" class="">代码注释</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8github%E5%92%8Cgitlab/" class="">同时使用github和gitlab</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E8%8E%B7%E5%8F%96%E5%86%85%E7%BD%91%E6%B4%BB%E8%B7%83ip/" class="">获取内网活跃IP</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E9%80%9A%E8%BF%87%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97ip%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4/" class="">通过子网掩码计算IP地址范围</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E9%85%8D%E7%BD%AEkylinv10/" class="">配置 Kylin V10</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E8%99%9A%E6%8B%9F%E7%BB%84%E7%BD%91/" class="">虚拟组网</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3dcacc5e7a7c646c608757dc5f042d92" class="toggle"  />
    <label for="section-3dcacc5e7a7c646c608757dc5f042d92" class="flex justify-between">
      <a role="button" class="">LeetCode</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-10-14-golang%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%B8%80/" class="">golang力扣刷题（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E4%B8%80/" class="">每日一题（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/%E7%BC%96%E7%A8%8B%E9%A2%98/" class="">编程题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-11-04-golang%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98%E4%BA%8C/" class="">golang力扣刷题（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/%E5%BF%85%E5%88%B7top101/" class="">必刷top101</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/leetcode/2021-10-28-leetcode%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="">LeetCode算法总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Golang</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-670eda717a06f31447c52422ec93a159" class="toggle" checked />
    <label for="section-670eda717a06f31447c52422ec93a159" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-04-07-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%80/" class="active">go语言基础（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/channel/" class="">Channel</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go-%E4%B8%AD%E4%BD%BF%E7%94%A8-sync.pool-%E6%97%B6%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%99%B7%E9%98%B1/" class="">Go 中使用 sync.Pool 时可能遇到的陷阱</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golangci-lint/" class="">golangci-lint</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golang%E6%8E%A7%E6%B5%81/" class="">Golang控流</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/golang%E9%99%90%E6%B5%81%E5%AE%9E%E8%B7%B5/" class="">golang限流实践</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D/" class="">go泛型介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/panic/" class="">panic</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/pprof/" class="">pprof</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/protobuf/" class="">ProtoBuf</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/url/" class="">URL</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%8C%85%E7%AE%A1%E7%90%86/" class="">包管理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" class="">单元测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/io.copy/" class="">奇怪的io.copy</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81/" class="">常用业务代码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-10-26-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%BA%8C/" class="">go语言基础（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E4%B8%89/" class="">go语言基础（三）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-go/" class="">数据结构-go</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E5%9F%BA%E7%A1%80/" class="">go语言底层基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/2021-12-20-benchmark%E6%B5%8B%E8%AF%95/" class="">benchmark测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/" class="">Go安全指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/json%E5%BA%8F%E5%88%97%E5%8C%96/" class="">Json序列化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E4%BD%BF%E7%94%A8ollvm%E6%B7%B7%E6%B7%86hello-world/" class="">使用 Ollvm混淆 Hello World</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E5%90%88%E9%9B%86/" class="">经验分享合集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E5%9F%BA%E7%A1%80/goland%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" class="">Goland常用技巧</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-c453881a62c640f6a4cceec99c02477e" class="toggle"  />
    <label for="section-c453881a62c640f6a4cceec99c02477e" class="flex justify-between">
      <a role="button" class="">高阶</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" class="">Go高阶-语言基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/" class="">Go内存对齐</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="">并发编程</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" class="">Go避坑指南</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%BA%93/" class="">Go高阶 语言类库</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="">go性能优化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/go%E9%AB%98%E9%98%B6-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="">Go高阶 高级特性</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E9%AB%98%E9%98%B6/%E6%98%93%E9%94%99%E7%BB%86%E8%8A%82/" class="">易错细节</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f235e88e751d2cb18d527c1784763605" class="toggle"  />
    <label for="section-f235e88e751d2cb18d527c1784763605" class="flex justify-between">
      <a role="button" class="">Package</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/flag/" class="">Flag</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/atomic/" class="">Atomic</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/os/" class="">Os</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/strconv/" class="">Strconv</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/sort/" class="">Sort</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/strings/" class="">Strings</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/reflect/" class="">Reflect</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/context/" class="">context</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/filepath/" class="">filepath</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/math/" class="">math</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/time/" class="">Time</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/package/sync/" class="">Sync</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-98f45c00d30ea45270982f872bd1c0bb" class="toggle"  />
    <label for="section-98f45c00d30ea45270982f872bd1c0bb" class="flex justify-between">
      <a role="button" class="">第三方库</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/resty/" class="">resty</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/diskqueue/" class="">diskqueue</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gofpdf/" class="">gofpdf</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>AI</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9b671b3ce1ddd28af1b4312866c8b524" class="toggle"  />
    <label for="section-9b671b3ce1ddd28af1b4312866c8b524" class="flex justify-between">
      <a role="button" class="">Basic</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/cursor%E7%BB%AD%E6%9D%AF/" class="">cursor续杯</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/mcp%E6%9C%8D%E5%8A%A1/" class="">MCP服务</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/opencv_cuda%E7%BC%96%E8%AF%91/" class="">Opencv Cuda编译</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/pytorch%E9%A3%9F%E8%B0%B1/" class="">pytorch食谱</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/trae%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/" class="">Trae使用心得分享</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="">基础知识</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7%E5%BA%93/" class="">相关工具库</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/" class="">项目收藏</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/basic/ai%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/" class="">Ai知识普及</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-12d52a883bb94360d36ad3bbf0cb5fd3" class="toggle"  />
    <label for="section-12d52a883bb94360d36ad3bbf0cb5fd3" class="flex justify-between">
      <a role="button" class="">Computer Vision</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/ocr%E8%AF%86%E5%88%AB/" class="">Ocr识别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/reid%E6%95%B0%E6%8D%AE%E9%9B%86/" class="">Reid数据集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/reid%E8%A1%8C%E4%BA%BA%E9%87%8D%E8%AF%86%E5%88%AB/" class="">Reid行人重识别</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo-world/" class="">yolo-world</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="">yolo底层原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolo%E6%95%B0%E6%8D%AE%E9%9B%86/" class="">yolo数据集</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E5%9B%BE%E5%83%8F%E5%A2%9E%E5%BC%BA%E4%BB%8B%E7%BB%8D/" class="">图像增强介绍</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E5%9B%BE%E5%83%8F%E8%B6%85%E5%88%86%E5%8E%9F%E7%90%86/" class="">图像超分原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/%E8%A7%86%E9%A2%91%E8%B6%85%E5%88%86/" class="">视频超分</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/computer-vision/yolov8%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B&#43;%E5%AE%9E%E8%B7%B5/" class="">Yolov8快速上手 实践</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-948cfe1684759289af9e39747f026a40" class="toggle"  />
    <label for="section-948cfe1684759289af9e39747f026a40" class="flex justify-between">
      <a role="button" class="">Generative AI</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/qwen2.5-vl%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" class="">Qwen2.5-vl源码部署</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/xinference%E5%9F%BA%E7%A1%80/" class="">Xinference基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/ai/generative-ai/%E5%88%A9%E7%94%A8dspy%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90prompt/" class="">利用 Dspy自动生成 Prompt</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-ac8e4e2fda641053d78fc10cbbde236e" class="toggle"  />
    <label for="section-ac8e4e2fda641053d78fc10cbbde236e" class="flex justify-between">
      <a role="button" class="">C</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/c/c&#43;&#43;%E9%83%A8%E7%BD%B2paddleocr/" class="">C&#43;&#43;部署PaddleOCR</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/cgo/" class="">CGo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/cgo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="">CGO遇到的问题解决</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81/" class="">业务代码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/c/%E5%9C%A8cgo%E4%B8%AD%E9%9B%86%E6%88%90%E5%92%8C%E8%B0%83%E7%94%A8dll%E6%96%87%E4%BB%B6/" class="">在CGO中集成和调用DLL文件</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Python</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-9fa9875ee3af29ba8922d532968a7155" class="toggle"  />
    <label for="section-9fa9875ee3af29ba8922d532968a7155" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/" class="">python内存泄漏排查方法</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%9F%BA%E7%A1%80/" class="">python基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/python%E5%AE%89%E8%A3%85/" class="">python安装</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/" class="">venv虚拟环境</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B/" class="">开发实例</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/%E5%9F%BA%E7%A1%80/%E6%97%A5%E5%B8%B8%E5%B0%8F%E8%84%9A%E6%9C%AC/" class="">日常小脚本</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-76d10924673a9347dff74c68c3ea9d86" class="toggle"  />
    <label for="section-76d10924673a9347dff74c68c3ea9d86" class="flex justify-between">
      <a role="button" class="">Package</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/argparse/" class="">argparse</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/collections/" class="">collections</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/detetime/" class="">datetime</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/decord/" class="">Decord</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/uvicorn/" class="">uvicorn</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/python/package/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="">正则表达式</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>数据库</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-94f26238d1ca3b5bcd40eadc7a88d726" class="toggle"  />
    <label for="section-94f26238d1ca3b5bcd40eadc7a88d726" class="flex justify-between">
      <a role="button" class="">MySql</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" class="">MySql相关问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E9%94%81%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/" class="">MySql锁相关总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/2021-04-20-mysql%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/" class="">MySql基础总结</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mac%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/" class="">Mac连接数据库所遇到的问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" class="">数据库设计</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-01e4ef5e6295826a1eab8f1a7114ec2c" class="toggle"  />
    <label for="section-01e4ef5e6295826a1eab8f1a7114ec2c" class="flex justify-between">
      <a role="button" class="">Redis</a>
    </label>
  

          
  <ul>
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2022-03-21-redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" class="">Redis集群搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2022-03-20-redis%E5%9F%BA%E7%A1%80/" class="">Redis基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/2021-05-02-redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="">redis面试总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-8be9c2251abd1fe110e3c1520cac6177" class="toggle"  />
    <label for="section-8be9c2251abd1fe110e3c1520cac6177" class="flex justify-between">
      <a role="button" class="">SQLite</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/fts/" class="">fts</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/sqlite/" class="">Sqlite</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlite/sqlite%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96/" class="">Sqlite数据库插入优化</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-f65a9544b5a0dd9c3cbedb29b743305e" class="toggle"  />
    <label for="section-f65a9544b5a0dd9c3cbedb29b743305e" class="flex justify-between">
      <a role="button" class="">基础</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/mongodb%E5%AE%89%E8%A3%85/" class="">Mongodb安装</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="">分库分表</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96/" class="">数据库规范化</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/xorm/" class="">Xorm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/gorm/" class="">Gorm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E7%A1%80/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" class="">常见数据库的备份与恢复</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>系统架构</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%9F%BA%E7%A1%80/" class="">系统架构基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-083ca86fd1b56cca1f76a6d6b34dc093" class="toggle"  />
    <label for="section-083ca86fd1b56cca1f76a6d6b34dc093" class="flex justify-between">
      <a role="button" class="">设计模式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">创建型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">结构型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="">行为型设计模式</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%89%A9%E5%B1%95/" class="">设计模式扩展</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-a36f740001772a844eb3087eeb17eb6d" class="toggle"  />
    <label for="section-a36f740001772a844eb3087eeb17eb6d" class="flex justify-between">
      <a role="button" class="">分布式</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">Elastic Search面试题</a>
  

        </li>
      
    
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/" class="">分布式面试题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%9C%BA%E6%99%AF%E9%A2%98/" class="">场景题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/" class="">高并发高可用</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-266e66094f86ce336245af3b8aaf0e2e" class="toggle"  />
    <label for="section-266e66094f86ce336245af3b8aaf0e2e" class="flex justify-between">
      <a role="button" class="">微服务</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/grpc/" class="">Grpc</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/grpc%E6%8B%A6%E6%88%AA%E5%99%A8retry/" class="">grpc拦截器retry</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="">微服务</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-3d14fec58473cc9c35cafaca50699647" class="toggle"  />
    <label for="section-3d14fec58473cc9c35cafaca50699647" class="flex justify-between">
      <a role="button" class="">web框架</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/gin%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/" class="">Gin参数绑定</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/" class="">动态路由与静态路由</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/gin%E6%A1%86%E6%9E%B6/" class="">gin框架</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE/" class="">流式数据</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/web%E6%A1%86%E6%9E%B6/beego%E6%A1%86%E6%9E%B6/" class="">Beego框架</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-a4047feef6f367d46b68d1e8995f5851" class="toggle"  />
    <label for="section-a4047feef6f367d46b68d1e8995f5851" class="flex justify-between">
      <a role="button" class="">前端</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/restfulapi/" class="">Restful API</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vite&#43;vue%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="">Vite&#43;Vue快速搭建项目</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vue3/" class="">Vue3</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="">Vue环境搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/websocket/" class="">Web Socket</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%89%8D%E7%AB%AF/webstorm-debug/" class="">WebStorm-debug</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-5ee6dbeeb93d5d07b824c3368271f046" class="toggle"  />
    <label for="section-5ee6dbeeb93d5d07b824c3368271f046" class="flex justify-between">
      <a role="button" class="">区块链</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-76bfb65f46ce25a0ff78d6cc4ad47773" class="toggle"  />
    <label for="section-76bfb65f46ce25a0ff78d6cc4ad47773" class="flex justify-between">
      <a role="button" class="">Fabric</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-02-25-fabric%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/" class="">fabric相关机制与原理</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-10-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" class="">智能合约</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-08-fabric-sdk-go%E8%AF%A6%E8%A7%A3/" class="">fabric-sdk-go详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-15-fabric-ca%E8%AF%A6%E8%A7%A3/" class="">fabric-ca详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-1e3df3eda5cf08a9c7e8cc723288fefb" class="toggle"  />
    <label for="section-1e3df3eda5cf08a9c7e8cc723288fefb" class="flex justify-between">
      <a role="button" class="">环境测试</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/fabric%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%8A%A5%E9%94%99%E4%B8%80/" class="">fabric网络中的报错（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-22-fabric%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%8A%A5%E9%94%99%E4%BA%8C/" class="">fabric网络中的报错（二）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-24-fabric%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="">fabric环境搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-25-fabric-solo%E8%8A%82%E7%82%B9%E6%B5%8B%E8%AF%95/" class="">solo节点测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-25-fabric%E5%A4%9A%E6%9C%BA%E6%90%AD%E5%BB%BA/" class="">fabric多机搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-12-20-%E9%83%A8%E7%BD%B2tape%E6%B5%8B%E8%AF%95/" class="">部署tape测试</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-05-01-%E6%89%8B%E5%8A%A8%E7%94%9F%E6%88%90ca%E8%AF%81%E4%B9%A6%E6%90%AD%E5%BB%BAfabric%E7%BD%91%E7%BB%9C/" class="">手动生成ca证书搭建fabric网络</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E7%8E%AF%E5%A2%83%E6%B5%8B%E8%AF%95/2021-03-18-centos%E5%AE%89%E8%A3%85fabric1.2/" class="">centos安装fabric1.2</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-25aef1d59a561fcefcaecb043ef8afd2" class="toggle"  />
    <label for="section-25aef1d59a561fcefcaecb043ef8afd2" class="flex justify-between">
      <a role="button" class="">配置文件</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-05-01-cryptogen%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/" class="">cryptogen生成的证书详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-30-config-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">config.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-30-docker-compose-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">docker-compose.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-29-configtx-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">configtx.yaml文件详解</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/2021-03-29-crypto-config-yaml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" class="">crypto-config.yaml文件详解</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-04-14-%E5%8D%87%E7%BA%A7%E9%93%BE%E7%A0%81/" class="">升级链码</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2022-03-25-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%BD%91%E7%BB%9C%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/" class="">区块链网络添加组织</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-05-02-fabric%E6%B5%8F%E8%A7%88%E5%99%A8%E6%90%AD%E5%BB%BA/" class="">fabric浏览器搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-17-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%B7%B2%E6%9C%89%E7%BB%84%E7%BB%87%E4%B8%AD%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9/" class="">如何在已有组织中增加节点</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/fabric/2021-04-15-fabric1.4%E5%A4%9A%E9%80%9A%E9%81%93%E5%AE%9E%E9%AA%8C/" class="">Fabric1.4多通道实验</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-b07621083aa30b12de4c0333941e479f" class="toggle"  />
    <label for="section-b07621083aa30b12de4c0333941e479f" class="flex justify-between">
      <a role="button" class="">比特币</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E6%AF%94%E7%89%B9%E5%B8%81/2022-02-25-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9B%B8%E5%85%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/" class="">比特币相关机制与原理</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-ff5477999ef29208270c84e8b56b2758" class="toggle"  />
    <label for="section-ff5477999ef29208270c84e8b56b2758" class="flex justify-between">
      <a role="button" class="">IPFS</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-12-05-go-ipfs-api/" class="">go-ipfs-api</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-07-12-ipfs-webui%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%90%AD%E5%BB%BA/" class="">ipfs-webui可视化工具搭建</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-07-08-ipfs%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%80/" class="">IPFS基本原理（一）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/ipfs/2021-06-02-ipfs%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA/" class="">IPFS私有网络搭建</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-77a0a17b06e8d04cfb0fba9952941706" class="toggle"  />
    <label for="section-77a0a17b06e8d04cfb0fba9952941706" class="flex justify-between">
      <a role="button" class="">密码学</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2022-08-15-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" class="">区块链安全基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2021-04-12-%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86/" class="">椭圆曲线加密</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/2021-03-04-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/" class="">密码学基础</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-2e4d10b323fd668021dbd532575d8790" class="toggle"  />
    <label for="section-2e4d10b323fd668021dbd532575d8790" class="flex justify-between">
      <a role="button" class="">Docker</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/docker%E5%9F%BA%E7%A1%80/" class="">Docker基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/docker%E9%97%AE%E9%A2%98/" class="">Docker问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/dockerfile/" class="">Dockerfile</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/docker/2021-04-30-docker%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" class="">docker常用知识总结</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-70383d7f28a7ae4bf840a844eb61aa16" class="toggle"  />
    <label for="section-70383d7f28a7ae4bf840a844eb61aa16" class="flex justify-between">
      <a role="button" class="">共识算法</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" class="">共识算法基础</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2022-03-26-raft%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" class="">Raft共识算法</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <input type="checkbox" id="section-5f7b667081fbae0581cd216f66d5102f" class="toggle"  />
    <label for="section-5f7b667081fbae0581cd216f66d5102f" class="flex justify-between">
      <a role="button" class="">博客</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8D%9A%E5%AE%A2/2022-08-27-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAhugo/" class="">个人博客搭建Hugo</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAhexo/" class="">个人博客搭建Hexo</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%9B%BE%E4%B9%A6/" class="">图书</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%B7%A5%E5%85%B7%E5%BA%93/" class="">工具库</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E6%94%B6%E8%97%8F/" class="">开源项目收藏</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="https://gitee.com/chaincode"  target="_blank" rel="noopener">
        Gitee
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>go语言基础（一）</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-概述">第一章 概述</a>
      <ul>
        <li><a href="#go语言特征">go语言特征</a>
          <ul>
            <li><a href="#设计初衷">设计初衷</a></li>
            <li><a href="#为什么没有继承">为什么没有继承</a></li>
            <li><a href="#为什么没有异常">为什么没有异常？</a></li>
            <li><a href="#为什么没有x">为什么没有X？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二章-类型">第二章 类型</a>
      <ul>
        <li><a href="#变量">变量</a>
          <ul>
            <li><a href="#定义">定义</a></li>
            <li><a href="#退化赋值"><strong>退化赋值</strong></a></li>
            <li><a href="#多变量赋值"><strong>多变量赋值</strong></a></li>
            <li><a href="#匿名变量"><strong>匿名变量</strong></a></li>
          </ul>
        </li>
        <li><a href="#命名">命名</a>
          <ul>
            <li><a href="#命名建议"><strong>命名建议：</strong></a></li>
            <li><a href="#空标识符"><strong>空标识符</strong></a></li>
          </ul>
        </li>
        <li><a href="#常量">常量</a>
          <ul>
            <li><a href="#定义-1">定义</a></li>
            <li><a href="#枚举">枚举</a></li>
            <li><a href="#展开">展开</a></li>
          </ul>
        </li>
        <li><a href="#基本类型">基本类型</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#引用类型">引用类型</a></li>
        <li><a href="#类型转换">类型转换</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#自定义类型">自定义类型</a>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三章-表达式">第三章 表达式</a>
      <ul>
        <li><a href="#保留字">保留字</a></li>
        <li><a href="#运算符">运算符</a>
          <ul>
            <li><a href="#算术运算符">算术运算符</a></li>
            <li><a href="#关系运算符">关系运算符</a></li>
            <li><a href="#逻辑运算符"><strong>逻辑运算符</strong></a></li>
            <li><a href="#位运算符">位运算符</a></li>
            <li><a href="#赋值运算符">赋值运算符</a></li>
            <li><a href="#其他运算符">其他运算符</a></li>
            <li><a href="#运算符优先级">运算符优先级</a></li>
          </ul>
        </li>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#流程控制">流程控制</a>
          <ul>
            <li><a href="#ifelse">if&hellip;else&hellip;</a></li>
            <li><a href="#switch">switch</a></li>
            <li><a href="#for">for</a></li>
            <li><a href="#select语句">select语句</a></li>
            <li><a href="#goto-continuebreak">goto, continue,break</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四章-函数">第四章 函数</a>
      <ul>
        <li><a href="#定义-2">定义</a></li>
        <li><a href="#参数">参数</a>
          <ul>
            <li><a href="#变参">变参</a></li>
          </ul>
        </li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#匿名函数">匿名函数</a>
          <ul>
            <li><a href="#闭包">闭包</a></li>
          </ul>
        </li>
        <li><a href="#延迟调用">延迟调用</a></li>
        <li><a href="#错误处理">错误处理</a>
          <ul>
            <li><a href="#error">error</a></li>
            <li><a href="#panicrecover">panic,recover</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五章-数据">第五章 数据</a>
      <ul>
        <li><a href="#字符串">字符串</a>
          <ul>
            <li><a href="#字符串处理">字符串处理</a></li>
            <li><a href="#字符串转换">字符串转换</a></li>
            <li><a href="#unicode">unicode</a></li>
          </ul>
        </li>
        <li><a href="#数组">数组</a>
          <ul>
            <li><a href="#初始化-1">初始化</a></li>
            <li><a href="#指针">指针</a></li>
            <li><a href="#复制">复制</a></li>
          </ul>
        </li>
        <li><a href="#切片">切片</a>
          <ul>
            <li><a href="#reslice">reslice</a></li>
            <li><a href="#append">append</a></li>
            <li><a href="#copy">copy</a></li>
          </ul>
        </li>
        <li><a href="#字典">字典</a></li>
        <li><a href="#结构体">结构体</a>
          <ul>
            <li><a href="#json格式数据">JSON格式数据</a></li>
          </ul>
        </li>
        <li><a href="#指针-1">指针</a>
          <ul>
            <li><a href="#指向指针的指针">指向指针的指针</a></li>
            <li><a href="#指针作为函数参数">指针作为函数参数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六章-方法">第六章 方法</a>
      <ul>
        <li><a href="#定义-3">定义</a></li>
        <li><a href="#匿名字段">匿名字段</a></li>
        <li><a href="#方法集">方法集</a></li>
        <li><a href="#表达式">表达式</a>
          <ul>
            <li><a href="#method-expression">Method Expression</a></li>
            <li><a href="#method-value">Method Value</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第七章-接口">第七章 接口</a>
      <ul>
        <li><a href="#定义-4">定义</a></li>
        <li><a href="#执行机制">执行机制</a></li>
        <li><a href="#类型转换-1">类型转换</a></li>
        <li><a href="#技巧">技巧</a></li>
      </ul>
    </li>
    <li><a href="#第八章-并发">第八章 并发</a>
      <ul>
        <li><a href="#含义">含义</a>
          <ul>
            <li><a href="#wait">Wait</a></li>
            <li><a href="#gomaxprocs">GOMAXPROCS</a></li>
            <li><a href="#local-storage">Local Storage</a></li>
            <li><a href="#gosched">Gosched</a></li>
            <li><a href="#goexit">Goexit</a></li>
          </ul>
        </li>
        <li><a href="#通道">通道</a>
          <ul>
            <li><a href="#收发">收发</a></li>
            <li><a href="#单向">单向</a></li>
            <li><a href="#选择">选择</a></li>
            <li><a href="#模式">模式</a></li>
            <li><a href="#性能">性能</a></li>
            <li><a href="#资源泄漏">资源泄漏</a></li>
          </ul>
        </li>
        <li><a href="#同步">同步</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h1 id="第一章-概述">
  第一章 概述
  <a class="anchor" href="#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e6%a6%82%e8%bf%b0">#</a>
</h1>
<h2 id="go语言特征">
  go语言特征
  <a class="anchor" href="#go%e8%af%ad%e8%a8%80%e7%89%b9%e5%be%81">#</a>
</h2>
<ul>
<li>
<p>简单</p>
</li>
<li>
<p>并发模型</p>
<p>go语言从根部将一切都并发化，运行时用Goroutine运行所有的一切，包括main.main入口函数。Goroutine是go的显著特征。它用类协程的方式处理并发单元，又在运行时层面做了更深度的优化处理。搭配channel,实现CSP模型。</p>
<blockquote>
<p>csp模型</p>
<p>Actor 模型中 Actor  之间就是不能共享内存的，彼此之间通信只能依靠消息传递的方式。Golang 实现的 CSP 模型和 Actor 模型看上去非常相似，虽然 Golang  中协程之间，也能够以共享内存的方式通信，但是并不推荐；而推荐的以通信的方式共享内存，实际上指的就是协程之间以消息传递方式来通信。</p>
<p>Channel模型中，worker之间不直接彼此联系，而是通过不同channel进行消息发布和侦听。消息的发送者和接收者之间通过Channel松耦合，发送者不知道自己消息被哪个接收者消费了，接收者也不知道是哪个发送者发送的消息。</p>
<p>Go语言的CSP模型是由协程Goroutine与通道Channel实现：</p>
<ul>
<li>Go协程goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与Coroutine协程也有区别，能够在发现堵塞后启动新的微线程。</li>
<li>通道channel: 类似Unix的Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和Channel有着耦合。</li>
</ul>
</blockquote>
</li>
<li>
<p>内存分配</p>
<blockquote>
<p>刨去因配合垃圾回收器而修改的内容，内存分配器完整的保留了tcmalloc的原始架构。除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。</p>
</blockquote>
</li>
<li>
<p>垃圾回收</p>
</li>
</ul>
<p>​       go垃圾回收不咋地</p>
<ul>
<li>静态链接</li>
</ul>
<blockquote>
<p>只须编译一个可执行文件，无须附加任何东西就能部署。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。</p>
</blockquote>
<ul>
<li>标准库</li>
<li>工具链</li>
</ul>
<h3 id="设计初衷">
  设计初衷
  <a class="anchor" href="#%e8%ae%be%e8%ae%a1%e5%88%9d%e8%a1%b7">#</a>
</h3>
<ul>
<li>少即是多（less is more）：如果一个特性并不对解决任何问题有显著价值，那么go就不提供它；如果需要一个特性，那么只有一种方法去实现</li>
<li>面向接口编程：非侵入式接口，反对继承、反对虚函数和虚函数重载（多态）、删除构造和析构函数</li>
<li>正交+组合的语言特性：语言的特性之间相互独立，不相互影响。比如类型和方法是互相独立的，类型之间也是相互独立的，没有子类，包也没有子包。不同特性用组合的方式来松耦合</li>
<li>并发在语言层面支持：并发更好利用多核，有更强的表现力来模拟真实世界</li>
</ul>
<p>在设计上，Go秉承了C的简单粗暴。</p>
<h3 id="为什么没有继承">
  为什么没有继承
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b2%a1%e6%9c%89%e7%bb%a7%e6%89%bf">#</a>
</h3>
<p>Go没有子类型的概念，只能把类型嵌入到另一个类型中，所以没有类型系统。Go的作者认为类型系统被过度使用了，应该在这个方向上退一步。</p>
<ul>
<li>使用伸缩性良好的组合，而不是继承</li>
<li>数据和方法不再绑定在一起，数据的集合用struct，方法的集合用interface，保持正交</li>
</ul>
<blockquote>
<p>类似子类父类的系统造成非常脆弱的代码。类型的层次必须在早期进行设计，通常会是程序设计的第一步，但是一旦写出程序后，早期的决策就很难进行改变了。所以，类型层次结构会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。</p>
</blockquote>
<p>作者附了一个例子，是一些以接口为参数并且其返回结果也是一个接口的函数：</p>
<pre tabindex="0"><code>// 入参是接口的函数，而不是成员方法
func ReadAll(r io.Reader) ([]byte, error)
// 封装器 - 出入参都是接口
func LoggingReader(r io.Reader) io.Reader    //读到的内容录入日志
func LimitingReader(r io.Reader, n int64) io.Reader    //读n个字节停下来
func ErrorInjector(r io.Reader) io.Reader
</code></pre><p>这种组合+函数的模式是相当灵活的。如果用继承，我们可能会多三个io.Reader的定义；然后用多态去获得对应的功能</p>
<h3 id="为什么没有异常">
  为什么没有异常？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b2%a1%e6%9c%89%e5%bc%82%e5%b8%b8">#</a>
</h3>
<p>panic和recover这些函数是故意弄的不好用的，因为我们应该减少使用他们。不像Java库中使用异常那样，在go的库中这两个关键字几乎没有使用。</p>
<ol>
<li>业务中的错误并不是真正的异常情况，if和return完全可以胜任，无需控制流</li>
<li>如果错误要使用特殊的控制结构，错误处理就会扭曲程序的控制流，非常复杂</li>
<li>显式的错误检查会迫使程序员在错误出现的时候对错误进行思考，并进行相应的处理，而不是推给前面的调用堆栈</li>
</ol>
<p>毫无疑问这会使代码更长一些，但如此编码带来的清晰度和简单性可以弥补其冗长的缺点</p>
<h3 id="为什么没有x">
  为什么没有X？
  <a class="anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%b2%a1%e6%9c%89x">#</a>
</h3>
<p>总结：Go的设计着眼于编程的便利性、编译的速度、概念的正交性以及支持并发和垃圾回收等功能。如果你在Go中找不到其他语言的X特性，那么只能说明这个特性不适合Go，比如它会影响编译速度或设计的清晰度，或者使得基础系统变得特别复杂。</p>
<h1 id="第二章-类型">
  第二章 类型
  <a class="anchor" href="#%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e7%b1%bb%e5%9e%8b">#</a>
</h1>
<h2 id="变量">
  变量
  <a class="anchor" href="#%e5%8f%98%e9%87%8f">#</a>
</h2>
<h3 id="定义">
  定义
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>     <span style="color:#75715e">//会自动初始化为0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span>=<span style="color:#66d9ef">false</span>   <span style="color:#75715e">//自动推断为bool类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>=<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">y</span>=<span style="color:#ae81ff">2</span>            <span style="color:#75715e">//定义完变量后再赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> =<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">s</span>=<span style="color:#ae81ff">100</span>,<span style="color:#e6db74">&#34;abc&#34;</span>   <span style="color:#75715e">//初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">s</span>=<span style="color:#ae81ff">100</span>,<span style="color:#e6db74">&#34;abc&#34;</span>   <span style="color:#75715e">//字符串加“”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>              <span style="color:#75715e">//自动推导类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>,<span style="color:#e6db74">&#34;abc&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">注意</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">定义变量</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">同时显示初始化</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">不能提供数据类型</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">只能用在函数内部</span>
</span></span></code></pre></div><h3 id="退化赋值">
  <strong>退化赋值</strong>
  <a class="anchor" href="#%e9%80%80%e5%8c%96%e8%b5%8b%e5%80%bc">#</a>
</h3>
<p>退化赋值的前提条件是：最少有一个新变量被定义，且必须是同一作用域。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fun</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">200</span>,<span style="color:#e6db74">&#34;abc&#34;</span> <span style="color:#75715e">//退化赋值操作，只有y是变量定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fun</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">200</span>         <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在处理函数错误返回值时，<strong>退化赋值允许我们重复使用err变量</strong>。</p>
<h3 id="多变量赋值">
  <strong>多变量赋值</strong>
  <a class="anchor" href="#%e5%a4%9a%e5%8f%98%e9%87%8f%e8%b5%8b%e5%80%bc">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">fun</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span>=<span style="color:#a6e22e">y</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>,<span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span> <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><h3 id="匿名变量">
  <strong>匿名变量</strong>
  <a class="anchor" href="#%e5%8c%bf%e5%90%8d%e5%8f%98%e9%87%8f">#</a>
</h3>
<p>匿名变量，丢弃数据不进行处理, _匿名变量配合函数返回值使用才有价值.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">_</span>,<span style="color:#a6e22e">j</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>
</span></span></code></pre></div><p><strong>编译器将未使用的变量当作错误。</strong></p>
<h2 id="命名">
  命名
  <a class="anchor" href="#%e5%91%bd%e5%90%8d">#</a>
</h2>
<h3 id="命名建议">
  <strong>命名建议：</strong>
  <a class="anchor" href="#%e5%91%bd%e5%90%8d%e5%bb%ba%e8%ae%ae">#</a>
</h3>
<ul>
<li>以字母或下画线开始，由多个字母、数字和下画线组合而成。</li>
<li>区分大小写</li>
<li>使用驼峰拼写格式</li>
<li>局部变量优先使用短名</li>
<li>不要使用保留关键字</li>
<li>不建议使用与预定义常量、类型、内置函数相同的名字</li>
<li>专有名词通常会全部大写，eg: escapeHTML</li>
</ul>
<p>符号名字首字母大小写决定了其作用域。首字母大写的为导出成员，可被包外引用，而小写则仅能在包内使用。</p>
<h3 id="空标识符">
  <strong>空标识符</strong>
  <a class="anchor" href="#%e7%a9%ba%e6%a0%87%e8%af%86%e7%ac%a6">#</a>
</h3>
<p>通常作为忽略占位符使用，可作为表达式左值，无法读取内容。可用来临时规避编译器对未使用变量和导入包的错误检查。但它是预置成员，不能重新定义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#e6db74">&#34;12&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">x</span>)
</span></span></code></pre></div><h2 id="常量">
  常量
  <a class="anchor" href="#%e5%b8%b8%e9%87%8f">#</a>
</h2>
<h3 id="定义-1">
  定义
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89-1">#</a>
</h3>
<p>常量值必须是编译器可以确定对字符、字符串、数字或布尔值。</p>
<p>代码中不使用的常量不会发生编译错误，与变量不同。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>=<span style="color:#ae81ff">123</span>,<span style="color:#ae81ff">0x22</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">s</span> = <span style="color:#e6db74">&#34;hello,world&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">x</span> = <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">点点滴滴</span><span style="color:#960050;background-color:#1e0010">&#39;</span>           <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">f</span> =<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0.123</span>     <span style="color:#75715e">//int , float64(默认)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">b</span> =<span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">uint16</span>=<span style="color:#ae81ff">12</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">y</span>              <span style="color:#75715e">//与x类型，右值相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">s</span> =<span style="color:#e6db74">&#34;abc&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">z</span>              <span style="color:#75715e">//与s类型，右值相同
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ptrsize</span>=<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(uintptr(<span style="color:#ae81ff">0</span>))     <span style="color:#75715e">//返回数据类型的大小 uintptr是一个整数类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">strsize</span>=len(<span style="color:#e6db74">&#34;hello,world!&#34;</span>)  <span style="color:#75715e">//len返回长度，表示有几个元素，cap返回指定类型的容量，类型不同意义不同。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> (  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span> =<span style="color:#ae81ff">99</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">999</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">byte</span> =byte(<span style="color:#a6e22e">x</span>)    <span style="color:#75715e">// x被指定为int类型，须显式转换为byte类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">n</span>      =uint8(<span style="color:#a6e22e">y</span>)   <span style="color:#75715e">//错误        右值不能超过常量类型的取值范围。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>数字类型变量的字节数和取值范围如下：</p>
<ul>
<li>int8 1B     -128~127</li>
<li>int16 2B   -32768~32767</li>
<li>int32 4B   -2147483648~2147483647</li>
<li>int64 8B   -9223372036854775808~9223372036854775807</li>
</ul>
<h3 id="枚举">
  枚举
  <a class="anchor" href="#%e6%9e%9a%e4%b8%be">#</a>
</h3>
<blockquote>
<p>&laquo;  左移运算符将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p>
</blockquote>
<pre tabindex="0"><code>const(
  x = iota //0     自增
  y        //1
  z        //2
)
const(
 _ = iota  //0
 KB=1 &lt;&lt;(10*iota) //1&lt;&lt;(10*1)   
 MB               //1&lt;&lt;(10*2)
 GB               //1&lt;&lt;(10*3)
)
const(
 _,_ =iota,iota*10  //0,0*10
 a,b                //1,1*10
 c,d                //2,2*10
)
const(
 a =iota      //0
 b            //1
 c =100       //100
 d            //100 
 e =iota      //4(恢复itoa自增，计数包括c,d)
 f            //5
)
自增默认数据类型为int，可显式指定类型。
const(
 a =iota    //int
 b float32 =iota   //float32
 c         =iota   //int  (如果不指定iota,则与b数据类型相同)
)
</code></pre><p>在实际编码中，建议用自定义类型实现用途明确的枚举类型。但这并不能将取值范围限定在预定义的枚举值内。</p>
<pre tabindex="0"><code>type color byte      //自定义类型 byte取值范围 -128-127
const(
 black colot =iota   //指定常量类型
 red
 blue
)
</code></pre><h3 id="展开">
  展开
  <a class="anchor" href="#%e5%b1%95%e5%bc%80">#</a>
</h3>
<p>不同于变量在运行期分配存储内存（非优化状态），常量通常会被编译器在<strong>预处理阶段</strong>直接展开，作为<strong>指令数据</strong>使用。</p>
<p>就是说<strong>常量不会分配存储空间</strong>，<strong>无法获取地址</strong>。</p>
<h2 id="基本类型">
  基本类型
  <a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">默认值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">bool</td>
<td style="text-align:center">1</td>
<td style="text-align:center">false</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">uint8</td>
</tr>
<tr>
<td style="text-align:center">int,uint</td>
<td style="text-align:center">4,8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">默认整数类型，依据目标平台，32或64位</td>
</tr>
<tr>
<td style="text-align:center">int8,uint8</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-128~127,0~255</td>
</tr>
<tr>
<td style="text-align:center">int16,uint16</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-32768~32767,0~65535</td>
</tr>
<tr>
<td style="text-align:center">int32,uint32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-21亿～21亿，0～42亿</td>
</tr>
<tr>
<td style="text-align:center">int64,uint64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">float32</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">float64</td>
<td style="text-align:center">8</td>
<td style="text-align:center">0.0</td>
<td style="text-align:center">默认浮点数类型</td>
</tr>
<tr>
<td style="text-align:center">complex64</td>
<td style="text-align:center">8</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">complex128</td>
<td style="text-align:center">16</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">rune</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Unicode Code Point,int32</td>
</tr>
<tr>
<td style="text-align:center">uintptr</td>
<td style="text-align:center">4,8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">足以存储指针的uint</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center"></td>
<td style="text-align:center">&quot;&quot;</td>
<td style="text-align:center">字符串，默认值为空字符串，而非NULL</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">数组</td>
</tr>
<tr>
<td style="text-align:center">struct</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">结构体</td>
</tr>
<tr>
<td style="text-align:center">function</td>
<td style="text-align:center"></td>
<td style="text-align:center">nil</td>
<td style="text-align:center">函数</td>
</tr>
<tr>
<td style="text-align:center">interface</td>
<td style="text-align:center"></td>
<td style="text-align:center">nil</td>
<td style="text-align:center">接口</td>
</tr>
<tr>
<td style="text-align:center">map</td>
<td style="text-align:center"></td>
<td style="text-align:center">nil</td>
<td style="text-align:center">字典，引用类型</td>
</tr>
<tr>
<td style="text-align:center">slice</td>
<td style="text-align:center"></td>
<td style="text-align:center">nil</td>
<td style="text-align:center">切片，引用类型</td>
</tr>
<tr>
<td style="text-align:center">channel</td>
<td style="text-align:center"></td>
<td style="text-align:center">nil</td>
<td style="text-align:center">通道，引用类型</td>
</tr>
</tbody>
</table>
<h4 id="strconv">
  strconv
  <a class="anchor" href="#strconv">#</a>
</h4>
<p>strconv包提供了字符串与简单数据类型之间的类型转换功能。可以将简单类型转换为字符串，也可以将字符串转换为其它简单类型。</p>
<blockquote>
<p>golang strconv**.ParseInt** 是将字符串转换为数字的函数,功能灰常之强大,看的我口水直流.</p>
<p>func ParseInt(s string, base int, bitSize int) (i int64, err error)</p>
<p>参数1 数字的字符串形式</p>
<p>参数2 数字字符串的进制 比如二进制 八进制 十进制 十六进制</p>
<p>参数3 返回结果的bit大小 也就是int8 int16 int32 int64</p>
</blockquote>
<h4 id="别名">
  别名
  <a class="anchor" href="#%e5%88%ab%e5%90%8d">#</a>
</h4>
<pre tabindex="0"><code class="language-g0" data-lang="g0">byte    alias for uint8
rune    alias for int32
</code></pre><p><strong>别名</strong>类型无需转换，可以直接赋值。</p>
<table>
<thead>
<tr>
<th style="text-align:center">格式化指令</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%%</td>
<td style="text-align:left">字面上的百分号，并非值的占位符</td>
</tr>
<tr>
<td style="text-align:center">%b</td>
<td style="text-align:left">一个二进制整数，将一个整数格式转化为二进制的表达方式</td>
</tr>
<tr>
<td style="text-align:center">%c</td>
<td style="text-align:left">一个Unicode的字符</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:left">十进制整数</td>
</tr>
<tr>
<td style="text-align:center">%o</td>
<td style="text-align:left">八进制整数</td>
</tr>
<tr>
<td style="text-align:center">%x</td>
<td style="text-align:left">小写的十六进制数值</td>
</tr>
<tr>
<td style="text-align:center">%X</td>
<td style="text-align:left">大写的十六进制数值</td>
</tr>
<tr>
<td style="text-align:center">%U</td>
<td style="text-align:left">一个Unicode表示法表示的整型码值</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:left">输出字符串表示（string类型或[]byte)</td>
</tr>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:left">以true或者false的方式输出布尔值</td>
</tr>
<tr>
<td style="text-align:center">%q</td>
<td style="text-align:left">双引号围绕的字符串，由Go语法安全地转义</td>
</tr>
<tr>
<td style="text-align:center">%p</td>
<td style="text-align:left">十六进制表示，前缀 0x</td>
</tr>
<tr>
<td style="text-align:center">%T</td>
<td style="text-align:left">相应值的类型</td>
</tr>
<tr>
<td style="text-align:center">%v</td>
<td style="text-align:left">只输出所有的值  相应值的默认格式</td>
</tr>
<tr>
<td style="text-align:center">%+v</td>
<td style="text-align:left">先输出字段类型，再输出该字段的值</td>
</tr>
<tr>
<td style="text-align:center">%#v</td>
<td style="text-align:left">先输出结构体名字值，再输出结构体（字段类型+字段的值）</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:left">备用格式：为八进制添加前导 0（%#o）。 为十六进制添加前导 0x（%#x）</td>
</tr>
</tbody>
</table>
<h4 id="go语言fmt包中占位符使用">
  Go语言fmt包中%(占位符)使用
  <a class="anchor" href="#go%e8%af%ad%e8%a8%80fmt%e5%8c%85%e4%b8%ad%e5%8d%a0%e4%bd%8d%e7%ac%a6%e4%bd%bf%e7%94%a8">#</a>
</h4>
<p>具体看下面链接</p>
<p><a href="https://blog.csdn.net/zp17834994071/article/details/108619759">https://blog.csdn.net/zp17834994071/article/details/108619759</a></p>
<h4 id="math包中常用的方法">
  <strong>math包中常用的方法</strong>
  <a class="anchor" href="#math%e5%8c%85%e4%b8%ad%e5%b8%b8%e7%94%a8%e7%9a%84%e6%96%b9%e6%b3%95">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;math&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取绝对值,函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Abs(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[-3.14]的绝对值为:[%.2f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Abs</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">3.14</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取x的y次方，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Pow(x, y float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[2]的16次方为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">16</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取余数，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Pow10(n int) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;10的[3]次方为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Pow10</span>(<span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取x的开平方，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Sqrt(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[64]的开平方为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Sqrt</span>(<span style="color:#ae81ff">64</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取x的开立方，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Cbrt(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[27]的开立方为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Cbrt</span>(<span style="color:#ae81ff">27</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        向上取整，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Ceil(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[3.14]向上取整为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Ceil</span>(<span style="color:#ae81ff">3.14</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        向下取整，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Floor(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[8.75]向下取整为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Floor</span>(<span style="color:#ae81ff">8.75</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        取余数，函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Floor(x float64) float64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[10/3]的余数为:[%.f]\n&#34;</span>, <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        分别取整数和小数部分,函数签名如下:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">            func Modf(f float64) (int float64, frac float64)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Integer</span>, <span style="color:#a6e22e">Decimal</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">Modf</span>(<span style="color:#ae81ff">3.14159265358979</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;[3.14159265358979]的整数部分为:[%.f],小数部分为:[%.14f]\n&#34;</span>, <span style="color:#a6e22e">Integer</span>, <span style="color:#a6e22e">Decimal</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="引用类型">
  引用类型
  <a class="anchor" href="#%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p><strong>特指slice、map、channel这三种预定义类型</strong>。相比数字、数组等类型，引用类型拥有更复杂的存储结构。除分配内存外，他们还须初始化一系列属性，诸如、长度，甚至包括哈希分布、数据队列等。</p>
<p>内置函数new按指定类型长度分配零值内存，返回指针，并不关心类型内部构造和初始化方式。而<strong>引用类型则必须使用make函数创建</strong>，编译器会将make转换为目标类型专用的创建函数（或指令），以确保完成全部内存分配和相关属性初始化。</p>
<pre tabindex="0"><code>就一句话 slice、map、channel只能用make函数创建。
</code></pre><blockquote>
<p>new函数也可以为引用类型分配内存，但这不是完整的创建。以字典map为例，它仅分配零字典类型本身（实际就是个指针包装）所需内存，并没有分配键值存储内存，也没有初始化散列桶等内部属性，因此它无法正常工作。</p>
<pre tabindex="0"><code>func main(){
  p:=new(map[string]int)    //函数new返回指针
  m:=*p
  m[&#34;a&#34;]=1                  //错误
  fmt.println(m)
}
</code></pre></blockquote>
<h2 id="类型转换">
  类型转换
  <a class="anchor" href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2">#</a>
</h2>
<p>go强制要求使用显示类型转换。</p>
<pre tabindex="0"><code>a :=10
b :=byte(a)
c :=a + int(b)  //混合类型表达式必须确保类型一致
</code></pre><h4 id="语法歧义">
  语法歧义
  <a class="anchor" href="#%e8%af%ad%e6%b3%95%e6%ad%a7%e4%b9%89">#</a>
</h4>
<p>如果转换的目标是指针、单向通道或没有返回值的函数类型，那么必须使用括号，以避免造成语法分解错误。</p>
<pre tabindex="0"><code>func main(){
 x :=100
 p :=*int(&amp;x)        //错误
 p :=(*int)(&amp;x)      // 让编译器将*int解析为指针类型
 println(p)
}
</code></pre><h2 id="自定义类型">
  自定义类型
  <a class="anchor" href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e7%b1%bb%e5%9e%8b">#</a>
</h2>
<p>使用关键字type定义用户自定义类型。</p>
<blockquote>
<p>即便指定了基础类型，也只表明它们有相同底层数据结构，两者间不存在任何关系，属于完全不同的两种类型。<strong>除操作符外，自定义类型不会继承基础类型的其他信息（包括方法）。不能视作别名，不能隐式转换，不能直接用于比较表达式。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span> =<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">d</span>     <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">d</span> <span style="color:#f92672">==</span><span style="color:#a6e22e">x</span>)    <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></blockquote>
<h4 id="未命名类型">
  未命名类型
  <a class="anchor" href="#%e6%9c%aa%e5%91%bd%e5%90%8d%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<p>数组、切片、字典、通道等类型与具体元素类型或长度等属性有关，故称作未命名类型。可用type为其提供具体名称，将其改变为命名类型。</p>
<blockquote>
<p>具有相同声明的未命名类型被视作同一类型。</p>
<ul>
<li>具有相同基类型的指针</li>
<li>具有相同元素类型和长度的数组</li>
<li>具有相同元素类型的切片</li>
<li>具有相同键值类型的字典</li>
<li>具有相同数据类型及操作方向的通道</li>
<li>具有相同字段序列的结构体</li>
<li>具有相同签名的函数</li>
<li>具有相同方法集的接口</li>
</ul>
</blockquote>
<p>未命名类型转换规则：</p>
<ul>
<li>所属类型相同</li>
<li>基础类型相同，且其中一个是未命名类型</li>
<li>数据类型相同，将双向通道赋值给单向通道，且其中一个为未命名类型</li>
<li>将默认值nil赋值给切片、字典、通道、指针、函数或接口</li>
<li>对象实现了目标接口</li>
</ul>
<h1 id="第三章-表达式">
  第三章 表达式
  <a class="anchor" href="#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h1>
<h2 id="保留字">
  保留字
  <a class="anchor" href="#%e4%bf%9d%e7%95%99%e5%ad%97">#</a>
</h2>
<p>go语言仅25个保留关键字（keyword)。</p>
<h2 id="运算符">
  运算符
  <a class="anchor" href="#%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h2>
<p><strong>没有乘幂和绝对值运算符，对应的是标准库math里的Pow、Abs函数实现。</strong></p>
<h3 id="算术运算符">
  算术运算符
  <a class="anchor" href="#%e7%ae%97%e6%9c%af%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<p>假定 A 值为 10，B 值为 20。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">相加</td>
<td style="text-align:left">A + B 输出结果 30</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">相减</td>
<td style="text-align:left">A - B 输出结果 -10</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">相乘</td>
<td style="text-align:left">A * B 输出结果 200</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">相除</td>
<td style="text-align:left">B / A 输出结果 2</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">求余</td>
<td style="text-align:left">B % A 输出结果 0</td>
</tr>
<tr>
<td style="text-align:left">++</td>
<td style="text-align:left">自增</td>
<td style="text-align:left">A++ 输出结果 11</td>
</tr>
<tr>
<td style="text-align:left">&ndash;</td>
<td style="text-align:left">自减</td>
<td style="text-align:left">A&ndash; 输出结果 9</td>
</tr>
</tbody>
</table>
<h3 id="关系运算符">
  关系运算符
  <a class="anchor" href="#%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等于</td>
<td>4  == 3</td>
<td>false</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>4  != 3</td>
<td>true</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>4  &lt; 3</td>
<td>false</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>4  &gt; 3</td>
<td>true</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>4  &lt;= 3</td>
<td>false</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>4  &gt;= 1</td>
<td>true</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符">
  <strong>逻辑运算符</strong>
  <a class="anchor" href="#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>术语</strong></th>
<th><strong>示例</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>非</td>
<td>!a</td>
<td>如果a为假，则!a为真；  如果a为真，则!a为假。</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>a  &amp;&amp; b</td>
<td>如果a和b都为真，则结果为真，否则为假。</td>
</tr>
<tr>
<td>||</td>
<td>或</td>
<td>a  || b</td>
<td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td>
</tr>
</tbody>
</table>
<p>有逻辑运算符连接的表达式叫做逻辑表达式</p>
<h3 id="位运算符">
  位运算符
  <a class="anchor" href="#%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<p>位运算符对整数在内存中的二进制位进行操作。</p>
<p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p>
<table>
<thead>
<tr>
<th style="text-align:left">p</th>
<th style="text-align:left">q</th>
<th style="text-align:left">p &amp; q</th>
<th style="text-align:left">p | q</th>
<th style="text-align:left">p ^ q</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>假定 A = 60; B = 13; 其二进制数转换为：</p>
<pre tabindex="0"><code>A = 0011 1100
B = 0000 1101
-----------------
A&amp;B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
</code></pre><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">按位与运算符&quot;&amp;&ldquo;是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td>
<td style="text-align:left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td>
</tr>
<tr>
<td style="text-align:left">|</td>
<td style="text-align:left">按位或运算符&rdquo;|&ldquo;是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td>
<td style="text-align:left">(A | B) 结果为 61, 二进制为 0011 1101</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">按位异或运算符&rdquo;^&ldquo;是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td>
<td style="text-align:left">(A ^ B) 结果为 49, 二进制为 0011 0001</td>
</tr>
<tr>
<td style="text-align:left">&laquo;</td>
<td style="text-align:left">左移运算符&rdquo;&laquo;&ldquo;是双目运算符。左移n位就是乘以2的n次方。 其功能把&rdquo;&laquo;&ldquo;左边的运算数的各二进位全部左移若干位，由&rdquo;&laquo;&ldquo;右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td style="text-align:left">A &laquo; 2 结果为 240 ，二进制为 1111 0000</td>
</tr>
<tr>
<td style="text-align:left">&raquo;</td>
<td style="text-align:left">右移运算符&rdquo;&raquo;&ldquo;是双目运算符。右移n位就是除以2的n次方。 其功能是把&rdquo;&raquo;&ldquo;左边的运算数的各二进位全部右移若干位，&quot;&raquo;&ldquo;右边的数指定移动的位数。</td>
<td style="text-align:left">A &raquo; 2 结果为 15 ，二进制为 0000 1111</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>位移右操作数必须是无符号整数，或可以转换的无显式类型常量。</strong></p>
<pre tabindex="0"><code>func main(){
 b:=23      //b是有符号int类型变量
 a:=1 &lt;&lt; b    //错误
 println(a)
}
</code></pre></blockquote>
<ul>
<li>按位 <strong>与</strong> 的运算规则是，如果两数对应的二进制位都为 1，那么结果为 1， 否则结果为 0。</li>
<li>按位 <strong>或</strong> 的运算规则是，如果两数对应的二进制位有一个为 1，那么结果为 1， 否则结果为 0。</li>
<li>按位 <strong>异或</strong> 的运算规则是如果两数对应的二进制位不同，那么结果为 1， 否则结果为 0。</li>
</ul>
<pre tabindex="0"><code>a := 16 &gt;&gt; 3 *// 16除以2的3次方*
a := 1 &lt;&lt; 3 // 2的3次方*1
</code></pre><h3 id="赋值运算符">
  赋值运算符
  <a class="anchor" href="#%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
<td style="text-align:left">C = A + B 将 A + B 表达式结果赋值给 C</td>
</tr>
<tr>
<td style="text-align:left">+=</td>
<td style="text-align:left">相加后再赋值</td>
<td style="text-align:left">C += A 等于 C = C + A</td>
</tr>
<tr>
<td style="text-align:left">-=</td>
<td style="text-align:left">相减后再赋值</td>
<td style="text-align:left">C -= A 等于 C = C - A</td>
</tr>
<tr>
<td style="text-align:left">*=</td>
<td style="text-align:left">相乘后再赋值</td>
<td style="text-align:left">C *= A 等于 C = C * A</td>
</tr>
<tr>
<td style="text-align:left">/=</td>
<td style="text-align:left">相除后再赋值</td>
<td style="text-align:left">C /= A 等于 C = C / A</td>
</tr>
<tr>
<td style="text-align:left">%=</td>
<td style="text-align:left">求余后再赋值</td>
<td style="text-align:left">C %= A 等于 C = C % A</td>
</tr>
<tr>
<td style="text-align:left">&laquo;=</td>
<td style="text-align:left">左移后赋值</td>
<td style="text-align:left">C &laquo;= 2 等于 C = C &laquo; 2</td>
</tr>
<tr>
<td style="text-align:left">&raquo;=</td>
<td style="text-align:left">右移后赋值</td>
<td style="text-align:left">C &raquo;= 2 等于 C = C &raquo; 2</td>
</tr>
<tr>
<td style="text-align:left">&amp;=</td>
<td style="text-align:left">按位与后赋值</td>
<td style="text-align:left">C &amp;= 2 等于 C = C &amp; 2</td>
</tr>
<tr>
<td style="text-align:left">^=</td>
<td style="text-align:left">按位异或后赋值</td>
<td style="text-align:left">C ^= 2 等于 C = C ^ 2</td>
</tr>
<tr>
<td style="text-align:left">|=</td>
<td style="text-align:left">按位或后赋值</td>
<td style="text-align:left">C |= 2 等于 C = C | 2</td>
</tr>
</tbody>
</table>
<h3 id="其他运算符">
  其他运算符
  <a class="anchor" href="#%e5%85%b6%e4%bb%96%e8%bf%90%e7%ae%97%e7%ac%a6">#</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">返回变量存储地址</td>
<td style="text-align:left">&amp;a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">指针变量。</td>
<td style="text-align:left">*a; 是一个指针变量</td>
</tr>
</tbody>
</table>
<h3 id="运算符优先级">
  运算符优先级
  <a class="anchor" href="#%e8%bf%90%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7">#</a>
</h3>
<p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p>
<table>
<thead>
<tr>
<th style="text-align:left">优先级</th>
<th style="text-align:left">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">* / % &laquo; &raquo; &amp; &amp;^</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">+ - | ^</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">== != &lt; &lt;= &gt; &gt;=</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">&amp;&amp;</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">||</td>
</tr>
</tbody>
</table>
<h2 id="初始化">
  初始化
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96">#</a>
</h2>
<pre tabindex="0"><code>type data struct{
 x int
 s string
}

d:=data{
 1,
 &#34;abc&#34;    //错误，须以逗号或者右花括号结束
}
</code></pre><h2 id="流程控制">
  流程控制
  <a class="anchor" href="#%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6">#</a>
</h2>
<h3 id="ifelse">
  if&hellip;else&hellip;
  <a class="anchor" href="#ifelse">#</a>
</h3>
<blockquote>
<p>比较特别的是对初始化语句的支持，可定义块局部变量或执行初始化函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">xinit</span>();<span style="color:#a6e22e">x</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>{    <span style="color:#75715e">//优先执行xinit函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  println(<span style="color:#e6db74">&#34;a&#34;</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span><span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">a</span>&lt;<span style="color:#a6e22e">b</span>{  <span style="color:#75715e">//定义一个或多个局部变量（也可以是函数返回值）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  println(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span> }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>局部变量的有效范围包含整个if/else块。</p>
</blockquote>
<p><strong>死代码：<strong>是指永远不会执行的代码，可使用</strong>专门的工具</strong>或用<strong>代码覆盖率测试</strong>进行检查。</p>
<h3 id="switch">
  switch
  <a class="anchor" href="#switch">#</a>
</h3>
<p>switch-case结构语法如下：</p>
<p>switch 变量或者表达式的值{</p>
<p>​      case 值1:</p>
<p>​           要执行的代码</p>
<p>​      case 值2:</p>
<p>​           要执行的代码</p>
<p>​      case 值3:</p>
<p>​           要执行的代码</p>
<p>​      ………………………………..</p>
<p>​      default:</p>
<p>​           要执行的代码</p>
<p>}</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">b</span>,<span style="color:#a6e22e">c</span>,<span style="color:#a6e22e">d</span>,<span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">x</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">b</span>:   <span style="color:#75715e">//多个匹配条件中其一即可。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println(<span style="color:#e6db74">&#34;a | b&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span>:
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;c&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">4</span>:
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;d&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;z&#34;</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">a</span> | <span style="color:#a6e22e">b</span>
</span></span></code></pre></div><p>switch 同样支持初始化语句，按从上到下、从左到右顺序匹配case执行。只有全部匹配失败时，才会执行default块。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">5</span>;<span style="color:#a6e22e">x</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">default</span>:     <span style="color:#75715e">//不会先执行这个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">x</span><span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>    println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>    println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>相邻的空case不构成多条件匹配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">x</span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">a</span>:    <span style="color:#75715e">//隐式：case a : break
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">b</span>:
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>无须显式执行break语句，case执行完毕后自动中断。如需贯通后续case，须执行fallthrough，但不再匹配后续条件表达式。fallthrough必须放在case块结尾，可用break语句阻止。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>{
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">5</span>;<span style="color:#a6e22e">x</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//break        终止 不再执行后续语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">fallthrough</span>    <span style="color:#75715e">//继续执行下一case，不在匹配条件表达式 也不会执行dēfault
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">6</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="for">
  for
  <a class="anchor" href="#for">#</a>
</h3>
<p>语法结构如下：</p>
<p>for 表达式1;表达式2;表达式3{</p>
<p>​      循环体</p>
<p>}</p>
<h4 id="for-range">
  for range
  <a class="anchor" href="#for-range">#</a>
</h4>
<p>可用for&hellip;range完成数据迭代。</p>
<p>允许返回单值</p>
<p><strong>无论是for循环，还是range迭代，其定义的局部变量都会重复使用。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span>[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">string</span>{<span style="color:#e6db74">&#34;a&#34;</span>,<span style="color:#e6db74">&#34;b&#34;</span>,<span style="color:#e6db74">&#34;c&#34;</span>}
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">data</span>{
</span></span><span style="display:flex;"><span>  println(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">i</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>    <span style="color:#75715e">//重复使用地址。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">0xc82003fe98</span> <span style="color:#ae81ff">0xc82003fec8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xc82003fe98</span> <span style="color:#ae81ff">0xc82003fec8</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xc82003fe98</span> <span style="color:#ae81ff">0xc82003fec8</span>
</span></span></code></pre></div><p>range会复制目标数据</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">30</span>}
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">data</span> {   <span style="color:#75715e">//从data复制品中取值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">300</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;x: %d,data: %d\n&#34;</span>,<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">data</span>[:]{  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">300</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;x: %d,data: %d\n&#34;</span>,<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">10</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">110</span>   <span style="color:#75715e">//range返回的依旧是复制值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">20</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">220</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">30</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">330</span>
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">110</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">210</span>  <span style="color:#75715e">//当i==0修改data时，x已取值，所以是110
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">420</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">420</span>  <span style="color:#75715e">//复制的仅是slice自身，底层array依旧是原对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">x</span>:<span style="color:#ae81ff">630</span>,<span style="color:#a6e22e">data</span>:<span style="color:#ae81ff">630</span>
</span></span></code></pre></div><p><strong>如果range目标表达式是函数调用，也仅被执行一次。</strong></p>
<h3 id="select语句">
  select语句
  <a class="anchor" href="#select%e8%af%ad%e5%8f%a5">#</a>
</h3>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<p>Go 编程语言中 select 语句的语法如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">communication</span> <span style="color:#a6e22e">clause</span>  :
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statement</span>(<span style="color:#a6e22e">s</span>);    
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">communication</span> <span style="color:#a6e22e">clause</span>  :
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statement</span>(<span style="color:#a6e22e">s</span>); 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 你可以定义任意数量的 case */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">default</span> : <span style="color:#75715e">/* 可选 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">statement</span>(<span style="color:#a6e22e">s</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以下描述了 select 语句的语法：</p>
<ul>
<li>
<p>每个 case 都必须是一个通信</p>
</li>
<li>
<p>所有 channel 表达式都会被求值</p>
</li>
<li>
<p>所有被发送的表达式都会被求值</p>
</li>
<li>
<p>如果任意某个通信可以进行，它就执行，其他被忽略。</p>
</li>
<li>
<p>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<ol>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ol>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c1</span>, <span style="color:#a6e22e">c2</span>, <span style="color:#a6e22e">c3</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i1</span>, <span style="color:#a6e22e">i2</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i1</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c1</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;received &#34;</span>, <span style="color:#a6e22e">i1</span>, <span style="color:#e6db74">&#34; from c1\n&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c2</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i2</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;sent &#34;</span>, <span style="color:#a6e22e">i2</span>, <span style="color:#e6db74">&#34; to c2\n&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">i3</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c3</span>): <span style="color:#f92672">*</span><span style="color:#75715e">// same as: i3, ok := &lt;-c3*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;received &#34;</span>, <span style="color:#a6e22e">i3</span>, <span style="color:#e6db74">&#34; from c3\n&#34;</span>)
</span></span><span style="display:flex;"><span>     } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;c3 is closed\n&#34;</span>)
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;no communication\n&#34;</span>)
</span></span><span style="display:flex;"><span>  }   
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上代码执行结果为：</p>
<pre tabindex="0"><code>no communication
</code></pre><h3 id="goto-continuebreak">
  goto, continue,break
  <a class="anchor" href="#goto-continuebreak">#</a>
</h3>
<table>
<thead>
<tr>
<th style="text-align:left">控制语句</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">break 语句</td>
<td style="text-align:left">经常用于中断当前 for 循环或跳出 switch 语句或select语句。</td>
</tr>
<tr>
<td style="text-align:left">continue 语句</td>
<td style="text-align:left">仅用于for循环，跳过当前循环的剩余语句，然后继续进行下一轮循环。</td>
</tr>
<tr>
<td style="text-align:left">goto 语句</td>
<td style="text-align:left">将控制转移到被标记的语句。</td>
</tr>
</tbody>
</table>
<h4 id="goto">
  goto
  <a class="anchor" href="#goto">#</a>
</h4>
<p>语法格式如下：</p>
<pre tabindex="0"><code>goto label;
..
.
label: statement;
</code></pre><p><strong>未使用的标签会引发编译错误。</strong></p>
<p>goto 语句流程图如下：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/06/xsTjcmiTVayxBjYe.png" alt="img" /></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">LOOP</span>: <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#ae81ff">20</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">15</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">LOOP</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a的值为 : %d\n&#34;</span>, <span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">a</span><span style="color:#f92672">++</span>   
</span></span><span style="display:flex;"><span>  } 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>以上实例执行结果为：</p>
<pre tabindex="0"><code>a的值为 : 10
a的值为 : 11
a的值为 : 12
a的值为 : 13
a的值为 : 14
a的值为 : 16
a的值为 : 17
a的值为 : 18
a的值为 : 19
</code></pre><blockquote>
<p>不能跳转到其他函数，或内层代码块</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>:
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;test&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span>&lt;<span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">loop</span>:
</span></span><span style="display:flex;"><span>      println(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">test</span>   <span style="color:#75715e">//不能跳转到其他函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">loop</span>   <span style="color:#75715e">//不能跳转到内层代码块内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></blockquote>
<h1 id="第四章-函数">
  第四章 函数
  <a class="anchor" href="#%e7%ac%ac%e5%9b%9b%e7%ab%a0-%e5%87%bd%e6%95%b0">#</a>
</h1>
<h2 id="定义-2">
  定义
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89-2">#</a>
</h2>
<p>Go 语言函数定义格式如下：</p>
<pre tabindex="0"><code>func 函数名( 参数列表 ) 返回类型 {
   函数体
}
</code></pre><p>函数只能判断是否为nil，不支持其他比较操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">a</span>(){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">b</span>(){}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">b</span>) <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>建议命名规则：</strong></p>
<ul>
<li>通常是动词和介词加上名称，例如scanWords。</li>
<li>避免不必要的缩写，printError要比printErr更好一些</li>
<li>避免使用类型关键字，比如buildUserStruct看上去会很别扭</li>
<li>避免歧义，不能有多种用途的解释造成误解</li>
<li>避免只能通过大小写区分的同名函数</li>
<li>避免与内置函数同名，这会导致误用</li>
<li>避免使用数字，除非是特定专有名词，例如utf8</li>
<li>避免添加作用域提示前缀</li>
<li>统一使用camel/pascal case拼写风格</li>
<li>使用相同术语，保持一致性</li>
<li>使用习惯用语，比如init表示初始化，is/has返回布尔值结果</li>
<li>使用反义词组命名行为相反的函数，比如get/set、min/max等</li>
</ul>
<h2 id="参数">
  参数
  <a class="anchor" href="#%e5%8f%82%e6%95%b0">#</a>
</h2>
<p>go不支持有默认值对可选参数，不支持命名参数。调用时，必须按签名顺序传递指定类型和数量的实参，就算以_命名的参数也不能忽略。</p>
<blockquote>
<p>形参是指函数定义中的参数，实参则是函数调用时所传递的参数。行参类似函数的局部变量，而实参则是函数外部对象，可以是常量，变量，表达式或函数等。</p>
</blockquote>
<p>参数可视作函数局部变量，因此不能在相同层次定义同名变量。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>     <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>  <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不管是指针、应用类型、还是其他类型参数，都是值拷贝传递。区别无非是拷贝目标对象，还是拷贝指针而已。在函数调用前，会为行参和返回值分配内存空间，并将实参拷贝到形参内存。<strong>尽管实参和形参都指向同一目标，但传递指针时依然被复制。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">p</span> <span style="color:#f92672">**</span><span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>=<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){   <span style="color:#75715e">//二级指针的使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span> println(<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="变参">
  变参
  <a class="anchor" href="#%e5%8f%98%e5%8f%82">#</a>
</h3>
<p>变参本质上就是一个切片。只能接收一到多个同类型参数，且必须放在列表尾部。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>,<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%T,%v\n&#34;</span>,<span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">a</span>)      <span style="color:#75715e">//显示类型和值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;abc&#34;</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>将切片作为变参时，须进行展开操作。如果是数组，先将其转换为切片。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">a</span><span style="color:#f92672">:=</span>[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>[:]<span style="color:#f92672">...</span>)<span style="color:#75715e">//如果是数组，先将其转换为切片。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>既然变参是切片，那么参数复制的仅是切片自身，并不包括底层数组，<strong>也因此可修改原数据</strong>。如果需要，可用内置函数copy复制底层数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">a</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">a</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">a</span><span style="color:#f92672">:=</span>[]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">30</span>}
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">110</span> <span style="color:#ae81ff">120</span> <span style="color:#ae81ff">130</span>]
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span>[<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>){ <span style="color:#75715e">//这里要加容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> make([][<span style="color:#ae81ff">3</span>]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">//记住这种特殊情况 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*---------------*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">int</span>){ <span style="color:#75715e">//这里要加容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s2</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e">//记住这种特殊情况 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">s2</span>[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="返回值">
  返回值
  <a class="anchor" href="#%e8%bf%94%e5%9b%9e%e5%80%bc">#</a>
</h2>
<p>有返回值的函数，必须有明确的return终止语句。</p>
<p>除非有panic,或者无break的死循环，则无须return终止语句。</p>
<p>稍有不便的是没有元组类型，也不能用数组、切片接收，但可以用_忽略掉不想要的返回值。多返回值可用作其他函数调用实参，或当作结果直接返回。</p>
<h2 id="匿名函数">
  匿名函数
  <a class="anchor" href="#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0">#</a>
</h2>
<p>匿名函数是指没有定义名字符号的函数。</p>
<blockquote>
<p>我们可以在函数内定义匿名函数，形成类似嵌套效果。匿名函数可直接调用，保存到变量，作为参数或返回值。</p>
</blockquote>
<p>直接使用</p>
<pre tabindex="0"><code>func main(){
 func(s string){
   println(s)
 }(&#34;hello,world!&#34;)   //匿名函数的参数
}
</code></pre><p>赋值给变量</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">add</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>)<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作为参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>  println(<span style="color:#e6db74">&#34;hello,world&#34;</span>)
</span></span><span style="display:flex;"><span> })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作为返回值</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>()<span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span> , <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">retrun</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">+</span><span style="color:#a6e22e">y</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">add</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>将匿名函数赋值给变量，与为普通函数提供名字标识符有着根本的区别。但编译器会为匿名函数生成一个“随机”符号名。</p>
<p>普通函数和匿名函数都可以作为结构体字段，或经通道传递。</p>
<p>除闭包因素外，匿名函数也是一种常见的重构手段。可将大函数分解成多个相对独立的匿名函数块，然后用相对简洁的调用完成逻辑流程，实现框架和细节分离。</p>
<p>相比语句块，匿名函数的作用域被隔离（不使用闭包），不会引发外部污染，更加灵活。没有定义顺序限制，必要时可抽离，便于实现干净、清晰的代码层次。</p>
</blockquote>
<h3 id="闭包">
  闭包
  <a class="anchor" href="#%e9%97%ad%e5%8c%85">#</a>
</h3>
<p>闭包是在其词法上下文中引用了自由变量的函数，或者说是函数和其引用环境的组合体。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">123</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test返回的匿名函数会引起上下文环境变量x</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">当该函数在main中执行时</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">它依然可以正确读取x的值</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">这种现象就称作闭包</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">闭包直接引用了原环境变量</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">返回的不仅仅是匿名函数</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">还包括所引用的环境变量指针</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><blockquote>
<p>正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存。另外，还有所谓“延迟求值”的特性。</p>
</blockquote>
<h2 id="延迟调用">
  延迟调用
  <a class="anchor" href="#%e5%bb%b6%e8%bf%9f%e8%b0%83%e7%94%a8">#</a>
</h2>
<p>语句defer向当前函数注册稍后执行的函数调用。这些调用被称作延迟调用，因为它们直到当前函数执行结束前才被执行，常用于资源释放、解除锁定，以及错误处理等操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f</span>,<span style="color:#a6e22e">err</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;./main.go&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span><span style="color:#f92672">!=</span><span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">defer</span>  <span style="color:#a6e22e">f</span>.close()    <span style="color:#75715e">//仅注册，直到main退出前才执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#f92672">...</span> <span style="color:#a6e22e">do</span> <span style="color:#a6e22e">something</span> <span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>延迟调用注册的是调用，必须提供执行所需参数（哪怕为空）。参数值在注册时被复制并缓存起来。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#f92672">:=</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span>  println(<span style="color:#e6db74">&#34;defer x,y =&#34;</span>,<span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">y</span>)     <span style="color:#75715e">//y为闭包引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }<span style="color:#960050;background-color:#1e0010">（</span><span style="color:#a6e22e">x</span>)     <span style="color:#75715e">//给匿名函数传参  注册时复制调用参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">101</span> <span style="color:#ae81ff">202</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> =<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">202</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">延迟调用可修改当前函数命名返回值</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">但其自身返回值被抛弃</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><blockquote>
<p>多个延迟调用安装FILO先进先出次序执行。</p>
</blockquote>
<p>编译器通过插入额外指令来实现延迟调用执行，而return和Panic语句都会终止当前函数流程，引发延迟调用。另外，return不是ret汇编指令，它会先更新返回值。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() (<span style="color:#a6e22e">z</span> <span style="color:#66d9ef">int</span>){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>    println(<span style="color:#e6db74">&#34;defer:&#34;</span>,<span style="color:#a6e22e">z</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">z</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  }()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span> (){
</span></span><span style="display:flex;"><span>  println(<span style="color:#e6db74">&#34;test:&#34;</span>,<span style="color:#a6e22e">test</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">defer</span>:<span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test</span>:<span style="color:#ae81ff">200</span>
</span></span></code></pre></div><h2 id="错误处理">
  错误处理
  <a class="anchor" href="#%e9%94%99%e8%af%af%e5%a4%84%e7%90%86">#</a>
</h2>
<h3 id="error">
  error
  <a class="anchor" href="#error">#</a>
</h3>
<p>标准库将error定义为接口类型，以便实现自定义错误类型。</p>
<pre tabindex="0"><code>type error interface{
   Error() string
}
</code></pre><p>error总是最后一个返回参数。标准库提供了相关创建函数，可方便地创建包含简单错误文本的error对象。</p>
<blockquote>
<p>错误变量通常以err作为前缀，且字符串内部全部小写，没有结束标点，以便于嵌入到其他格式化字符串中输出。</p>
<p>全局错误变量并非没有问题，因为它们可被用户重新赋值，这就可能导致结果不匹配。</p>
<p>与errors.New类似的还有fat.Errorf，它返回一个格式化内容的错误对象。</p>
</blockquote>
<p>自定义错误类型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">DivError</span> <span style="color:#66d9ef">struct</span>{       <span style="color:#75715e">//自定义错误类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">DivError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>{     <span style="color:#75715e">//实现error接口方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;division by zero&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">div</span>(<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">error</span>){
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">y</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>,<span style="color:#a6e22e">DivError</span>{<span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span>}
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span><span style="color:#f92672">/</span><span style="color:#a6e22e">y</span>,<span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">自定义错误类型通常以Error为名称后缀</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">在用switch按类型匹配时</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">注意case顺序</span><span style="color:#960050;background-color:#1e0010">。</span><span style="color:#a6e22e">应将自定义类型放在前面</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">优先匹配更具体的错误类型</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><blockquote>
<p>大量函数和方法返回error，会使得代码很难看，解决思路有：</p>
<ul>
<li>使用专门的检查函数处理错误逻辑（比如记录日志），简化检查代码。</li>
<li>在不影响逻辑的情况下，使用defer延后处理错误状态（err退化赋值）。</li>
<li>在不中断逻辑的情况下，将错误作为内部状态保存，等最终“提交”时再处理。</li>
</ul>
</blockquote>
<h3 id="panicrecover">
  panic,recover
  <a class="anchor" href="#panicrecover">#</a>
</h3>
<p>panic会立即中断当前函数流程，执行延迟调用。而在延迟调用函数中，recover可捕获并返回panic提交的错误对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">deefer</span> <span style="color:#66d9ef">func</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span><span style="color:#f92672">:=</span>recover();<span style="color:#a6e22e">err</span><span style="color:#f92672">!=</span><span style="color:#66d9ef">nil</span>{      <span style="color:#75715e">//捕获错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> }()
</span></span><span style="display:flex;"><span>   panic(<span style="color:#e6db74">&#34;i am dead&#34;</span>)             <span style="color:#75715e">//引发错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   println(<span style="color:#e6db74">&#34;exit.&#34;</span>)            <span style="color:#75715e">//永不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>error返回的是一般性的错误，但是panic函数返回的是让程序崩溃的错误。</p>
<p>也就是当遇到不可恢复的错误状态的时候，如数组访问越界、空指针引用等，这些运行时错误会引起painc异常，在一般情况下，我们不应通过调用panic函数来报告普通的错误，而应该只把它作为报告致命错误的一种方式。当某些不应该发生的场景发生时，我们就应该调用panic。</p>
<p>一般而言，当panic异常发生时，程序会中断运行。随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。</p>
<p>当然，如果直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。</p>
<p>我们<strong>在实际的开发过程中并不会直接调用panic( )函数</strong>，但是当我们编程的程序遇到致命错误时，<strong>系统会自动调用该函数来终止整个程序的运行</strong>，也就是系统内置了panic函数。</p>
<p>Go语言为我们提供了专用于“拦截”运行时panic的内建函数——recover。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。</p>
<p>因为Panic参数是空接口类型，因此可以使用任何对象作为错误状态。而recover返回结果同样要做转型才能获得具体信息。</p>
<p>无论是否执行recover，所有延迟调用都会被执行。但中断性错误会沿调用堆栈向外传递，要么被外层捕获，要么导致进程奔溃。</p>
<h1 id="第五章-数据">
  第五章 数据
  <a class="anchor" href="#%e7%ac%ac%e4%ba%94%e7%ab%a0-%e6%95%b0%e6%8d%ae">#</a>
</h1>
<h2 id="字符串">
  字符串
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2">#</a>
</h2>
<p>字符串是个不可变字节（byte）序列，其本身是一个复合结构。</p>
<p>头部指针指向字节数组，但没有NULL结尾。默认以UTF-8编码存储Unicode字符，字面量里允许使用十六进制、八进制和UTF编码格式。</p>
<p>内置函数len返回字节数组长度，cap不接受字符串类型参数。</p>
<p><strong>字符串默认值不是nil ,而是“”。</strong></p>
<p>使用&rdquo;`&ldquo;定义不做转义处理的原始字符串（raw string),支持跨行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#e6db74">`line\r\n,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">   line 2`</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">line</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#a6e22e">r</span><span style="color:#960050;background-color:#1e0010">\</span><span style="color:#a6e22e">n</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">line</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">编译器不会解析原始字符串内的注释语句</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">且前置锁进空格也属于字符串内容</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>允许索引号访问字节数组（非字符），但不能获取元素地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#e6db74">&#34;abc&#34;</span>
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span> println(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">1</span>])      <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>以切片语法（起始和结束索引号）返回子串时，其内部依旧指向原字节数组。</p>
<p>使用for遍历字符串时，分byte和rune两种方式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span><span style="color:#e6db74">&#34;雨痕&#34;</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">0</span>;<span style="color:#a6e22e">i</span>&lt;len(<span style="color:#a6e22e">s</span>);<span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>{   <span style="color:#75715e">//byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d:[%c]\n&#34;</span>,<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">s</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">c</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">rangs</span> <span style="color:#a6e22e">s</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d:[%c]\n&#34;</span>,<span style="color:#a6e22e">i</span>,<span style="color:#a6e22e">c</span>)    <span style="color:#75715e">//rune:返回数组索引号，以及unicode字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>:[<span style="color:#a6e22e">e</span><span style="color:#960050;background-color:#1e0010">`</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>:[]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>:[<span style="color:#a6e22e">雨</span>]
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>:[<span style="color:#a6e22e">痕</span>]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rune是Go语言中一种特殊的数据类型</span>,<span style="color:#a6e22e">它是int32的别名</span>,<span style="color:#a6e22e">几乎在所有方面等同于int32</span>,<span style="color:#a6e22e">用于区分字符值和整数值</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><h3 id="字符串处理">
  字符串处理
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%a4%84%e7%90%86">#</a>
</h3>
<p><strong>Contains</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span>  <span style="color:#a6e22e">Contains</span> (<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">substrstring</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">字符串s中是否包含substr</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">返回bool值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span> =<span style="color:#e6db74">&#34;hellogo&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">contains</span>(<span style="color:#a6e22e">str</span>,<span style="color:#e6db74">&#34;go&#34;</span>))  <span style="color:#75715e">//返回值为true
</span></span></span></code></pre></div><p><strong>Join</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Join</span> (<span style="color:#a6e22e">a</span>[]<span style="color:#66d9ef">string</span>,<span style="color:#a6e22e">sepstring</span>) <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">字符串链接</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">把slicea通过sep链接起来</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span>[]string(<span style="color:#e6db74">&#34;abc&#34;</span>,<span style="color:#e6db74">&#34;hello&#34;</span>,<span style="color:#e6db74">&#34;mike&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span><span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Join</span>(<span style="color:#a6e22e">s</span>,<span style="color:#e6db74">&#34;|&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;buf=&#34;</span>,<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span>=<span style="color:#a6e22e">abc</span>|<span style="color:#a6e22e">hello</span>|<span style="color:#a6e22e">mike</span>
</span></span></code></pre></div><p><strong>Index</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Index</span> (<span style="color:#a6e22e">s</span>,<span style="color:#a6e22e">sepstring</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">在字符串s中查找sep所在的位置</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">返回位置值</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">找不到返回</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#e6db74">&#34;abcdhello&#34;</span>,<span style="color:#e6db74">&#34;hello&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#e6db74">&#34;abcdhello&#34;</span>,<span style="color:#e6db74">&#34;go&#34;</span>))  <span style="color:#75715e">//不包含返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p><strong>Repeat</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Repeat</span> (<span style="color:#a6e22e">sstring</span>,<span style="color:#a6e22e">countint</span>) <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">重复s字符串count次</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">最后返回重复的字符串</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Repeat</span>(<span style="color:#e6db74">&#34;go&#34;</span>,<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;buf=&#34;</span>,<span style="color:#a6e22e">buf</span>)  <span style="color:#75715e">//&#34;gogogo&#34;
</span></span></span></code></pre></div><p><strong>Replace</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Replace</span> (<span style="color:#a6e22e">s</span>,<span style="color:#a6e22e">old</span>,<span style="color:#a6e22e">newstring</span>,<span style="color:#a6e22e">nint</span>)<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">在s字符串中</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">把old字符串替换为new字符串</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">n表示替换的次数</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">小于0表示全部替换</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#66d9ef">string</span>.<span style="color:#a6e22e">Replace</span>(<span style="color:#e6db74">&#34;oink oink oink&#34;</span>,<span style="color:#e6db74">&#34;k&#34;</span>,<span style="color:#e6db74">&#34;ky&#34;</span>,<span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#66d9ef">string</span>.<span style="color:#a6e22e">Replace</span>(<span style="color:#e6db74">&#34;oink oink oink&#34;</span>,<span style="color:#e6db74">&#34;k&#34;</span>,<span style="color:#e6db74">&#34;moo&#34;</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">oinky</span> <span style="color:#a6e22e">oinky</span> <span style="color:#a6e22e">oink</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">moo</span> <span style="color:#a6e22e">moo</span> <span style="color:#a6e22e">moo</span>
</span></span></code></pre></div><p><strong>Split</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Split</span> (<span style="color:#a6e22e">s</span>,<span style="color:#a6e22e">sepstring</span>)[]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">把s字符串按照sep分割</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">返回slice</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span><span style="color:#f92672">:=</span><span style="color:#e6db74">&#34;hello@go@mike&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">buf</span>,<span style="color:#e6db74">&#34;@&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;s2=&#34;</span>,<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">s2</span>=[<span style="color:#a6e22e">hello</span> <span style="color:#a6e22e">abc</span> <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">mike</span>]
</span></span></code></pre></div><p><strong>Trim</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Trim</span> (<span style="color:#a6e22e">sstring</span>,<span style="color:#a6e22e">cutsetstring</span>)<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">在s字符串的头部和尾部去除cutset指定的字符串</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Trim</span>(<span style="color:#e6db74">&#34;   are u ok?   &#34;</span>,<span style="color:#e6db74">&#34; &#34;</span>) <span style="color:#75715e">//去掉两头空格
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;buf=#%s#\n&#34;</span>,<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">buf</span>=<span style="color:#960050;background-color:#1e0010">#</span><span style="color:#a6e22e">are</span> <span style="color:#a6e22e">u</span> <span style="color:#a6e22e">ok</span><span style="color:#960050;background-color:#1e0010">?#</span>
</span></span></code></pre></div><p><strong>Fields</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Fields</span> (<span style="color:#a6e22e">sstring</span>)[]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">功能</span><span style="color:#960050;background-color:#1e0010">：</span><span style="color:#a6e22e">去除s字符串的空格符</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">并且按照空格分割返回slice</span>
</span></span></code></pre></div><h3 id="字符串转换">
  字符串转换
  <a class="anchor" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bd%ac%e6%8d%a2">#</a>
</h3>
<p>要修改字符串，须将其转换为可变类型（[]rune或[]byte),待完成后再转换回来。但不管如何转换，都须重新分配内存，并复制数据。</p>
<p>相应的字符串转换函数都在”strconv”包。</p>
<p><strong>Format 系列函数把其他类型的转换为字符串。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//将bool类型转换为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">FormatBool</span>(<span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//将整型转换为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Itoa</span>(<span style="color:#ae81ff">666</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">str</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//将浮点数转换为字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">str</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">str</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">FormatFloat</span>(<span style="color:#ae81ff">3.14</span>,<span style="color:#e6db74">&#39;f&#39;</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">64</span>)<span style="color:#75715e">//&#39;f&#39;指打印格式，以小数方式，3指小数点位数，64以float64处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">str</span>)
</span></span></code></pre></div><p><strong>Parse系列函数把字符串转换为其他类型</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//字符串转化其他类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">flag</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">flag</span>,<span style="color:#a6e22e">err</span>=<span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseBool</span>(<span style="color:#e6db74">&#34;true&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span><span style="color:#f92672">==</span><span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;flag=&#34;</span>,<span style="color:#a6e22e">flag</span>)
</span></span><span style="display:flex;"><span>}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;err=&#34;</span>,<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//把字符串转换为整型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#e6db74">&#34;456&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;a=&#34;</span>,<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">b</span>,<span style="color:#a6e22e">err</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">ParseFlat</span>(<span style="color:#e6db74">&#34;123.34&#34;</span>,<span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span><span style="color:#66d9ef">nil</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;flag=&#34;</span>,<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;err=&#34;</span>,<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Append</strong> 系列函数将整数等转换为字符串后，添加到现有的字节数组中</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">slice</span> <span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">byte</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1024</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">AppendBool</span>(<span style="color:#a6e22e">slice</span>,<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">AppendInt</span>(<span style="color:#a6e22e">slice</span>,<span style="color:#ae81ff">1234</span>,<span style="color:#ae81ff">10</span>)  <span style="color:#75715e">//第二个数为要追加的数，第三个为指定10进制方式追加。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">slice</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">APPendQute</span>(<span style="color:#a6e22e">slice</span>,<span style="color:#e6db74">&#34;abc&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">fmt</span>.println(<span style="color:#e6db74">&#34;slice=&#34;</span>,string(<span style="color:#a6e22e">slice</span>)) <span style="color:#75715e">//转换string后再打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">结果</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">slice</span>=<span style="color:#a6e22e">true1234</span><span style="color:#e6db74">&#34;abc&#34;</span>
</span></span></code></pre></div><h3 id="unicode">
  unicode
  <a class="anchor" href="#unicode">#</a>
</h3>
<p>类型rune专门用来存储Unicode码点（code point),它是int32的别名，相当于UCS-4/UTF-32编码格式。使用单引号的字面量，其默认类型就是rune。</p>
<p>除[]rune 外，还可以直接在rune,byte,string间进行转换。</p>
<h2 id="数组">
  数组
  <a class="anchor" href="#%e6%95%b0%e7%bb%84">#</a>
</h2>
<p>定义数组类型时，数组长度必须是非负整型常量表达式，长度是类型组成部分。也就是说元素类型相同，但长度不同的数组不属于同一类型。</p>
<h3 id="初始化-1">
  初始化
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96-1">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>      <span style="color:#75715e">//元素自动初始化为零      [0 0 0 0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">b</span><span style="color:#f92672">:=</span>[<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">5</span>}    <span style="color:#75715e">//未提供初始值的元素自动化初始为0    [2 5 0 0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">c</span><span style="color:#f92672">:=</span>[<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">10</span>}  <span style="color:#75715e">//可指定索引位置初始化     [5 0 0 10]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">d</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}  <span style="color:#75715e">//按初始化值数量确定数组长度   [1 2 3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">e</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">100</span>} <span style="color:#75715e">//支持索引初始化，但注意数组长度与此有关  [10 0 0 100]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>对于结构等复合类型，可省略元素初始化类型标签。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">d</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#a6e22e">user</span>{
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">&#34;tom&#34;</span>,<span style="color:#ae81ff">20</span>},
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">&#34;mare&#34;</span>,<span style="color:#ae81ff">23</span>},  <span style="color:#75715e">//省略了类型标签
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在定义多维数组时，仅第一维度允许使用”&hellip;“。</p>
<h3 id="指针">
  指针
  <a class="anchor" href="#%e6%8c%87%e9%92%88">#</a>
</h3>
<p>指针数组：是指元素为指针类型的数组。</p>
<p>数组指针：是获取数组变量的地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span>,<span style="color:#a6e22e">y</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">a</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>{<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">y</span>}    <span style="color:#75715e">//元素为指针的指针数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">p</span><span style="color:#f92672">:=&amp;</span><span style="color:#a6e22e">a</span>                  <span style="color:#75715e">//存储数组地址的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>可获取任意元素地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">a</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>}
</span></span><span style="display:flex;"><span>println(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">0</span>],<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xc82003ff20</span>  <span style="color:#ae81ff">0xc82003ff20</span>  <span style="color:#ae81ff">0xc82003ff28</span>
</span></span></code></pre></div><p>数组指针可直接用来操作元素。</p>
<h3 id="复制">
  复制
  <a class="anchor" href="#%e5%a4%8d%e5%88%b6">#</a>
</h3>
<p>go数组是值类型，赋值和传参操作都会复制整个数组数据。</p>
<h2 id="切片">
  切片
  <a class="anchor" href="#%e5%88%87%e7%89%87">#</a>
</h2>
<p>切片本身并非动态数组或数组指针。它内部通过指针引用底层数组，设定相关属性将数据读写操作限定在指定区域内。<strong>切片本身是个只读对象，其工作机制类似数组指针的一种包装。</strong></p>
<p>切片：切片与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大，所以可以将切片理解成“动态数组”，但是，它不是数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">cap</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>s:=[ ]int{ }     //定义空切片</p>
<p>s:=[]int{1,2,3}   //初始化切片</p>
<p>s =append(s,5,6,7)  //通过append函数向切片中追加数据</p>
<p>fmt.println(s)</p>
<p>输出结果：[1 2 3 5 6 7]</p>
<p>var s1 []int    //声明切片和声明数组一样，只是少了长度，此为空(nil)切片</p>
<p>//借助make函数, 格式 make(切片类型, 长度, 容量)</p>
<p><strong>s := make([]int, 5, 10)</strong></p>
</blockquote>
<p>属性cap表示切片所引用数组片段的真实长度，len用于限定可读的写元素数量。另外，数组必须是addressable，否则会引发错误。</p>
<p>可直接创建切片对象，无须预先准备数组。因为是引用类型，须使用make函数或显示初始化语句，它会自动完成底层数组内存分配。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s1</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>)      <span style="color:#75715e">//指定le、cap，底层数组初始化为零
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">s2</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">s</span>)        <span style="color:#75715e">//省略cap,和len相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">s3</span><span style="color:#f92672">:=</span>[]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">30</span>}    <span style="color:#75715e">//按初始化元素分配底层数组，并设置len、cap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">s3</span>,len(<span style="color:#a6e22e">s3</span>),cap(<span style="color:#a6e22e">s3</span>))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>[<span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">30</span>]  <span style="color:#ae81ff">6</span>  <span style="color:#ae81ff">6</span>
</span></span></code></pre></div><blockquote>
<pre tabindex="0"><code>func main(){
 var a []int
 b:=[]int{}
 println(a==inl,b==nil)
}
输出：true false
</code></pre><p>前者仅定义了一个[]int类型变量，并未执行初始化操作，而后者则用初始化表达式完成了全部创建过程。</p>
<p>变量b的内部指针被赋值，a==nil，仅表示他是个未初始化的切片对象，切片本身依然会分配所需内存。</p>
</blockquote>
<p>不支持比较操作，就算元素类型支持也不行，仅能判断是否为nil</p>
<pre tabindex="0"><code>func mian(){
 a:=make([]int,1)
 b:=make([]int,1)
 println(a==b)     //错误。不能比较
}
</code></pre><p><strong>二维切片初始化，都是0</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">bp</span><span style="color:#f92672">:=</span>make([][]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">bp</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">bp</span>[<span style="color:#a6e22e">i</span>]=make([]<span style="color:#66d9ef">int</span>,<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以获取元素地址，但不能向数组那样直接用指针访问元素内容。</p>
<pre tabindex="0"><code>func main(){
 s:=[]int{0,1,2,3,4}
 p:=&amp;s       //取header地址
 p0:=&amp;s[0]   //取array[0]地址
 p1:=&amp;s[1]
 println(p,p0,p1)
 (*p)[0]+=100     //*[]int 不支持索引操作，须先返回[]int 对象
 *p +=100         //直接用元素指针操作
 fmt.println(s)
}
</code></pre><pre tabindex="0"><code>输出：
0xc82003ff00 0xc8200141e0  0xc8200141e8
[100 101 2 3 4]
</code></pre><p>如果元素类型也是切片，那么就可以实现类似交错数组的功能</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span>[][]<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>,<span style="color:#ae81ff">30</span>},
</span></span><span style="display:flex;"><span>   {<span style="color:#ae81ff">100</span>},
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">2</span>]=append(<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">2</span>],<span style="color:#ae81ff">200</span>,<span style="color:#ae81ff">300</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">x</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>输出：
[10 20 30]
[100 200 300]
</code></pre><blockquote>
<p>切片只是很小的结构体对象，用来代替数组传参可避免复制开销。make函数允许在运行期动态指定数组长度，绕开了数组类型必须使用编译器常量的限制。</p>
<p>并非所有时候都适合用切片代替数组，因为切片底层数组可能会在堆上分配内存。而且小数组在栈上拷贝的消耗也未必就比make代价大。</p>
</blockquote>
<h3 id="reslice">
  reslice
  <a class="anchor" href="#reslice">#</a>
</h3>
<p>将切片视作[cap]slice数据源，据此创建新切片对象。不能超出cap,但不受len限制。</p>
<blockquote>
<p>s2=s1 [2:4:6]</p>
<p>len:2   cap:4</p>
<p><strong>s[low:high:max]</strong></p>
<p>从切片s的索引位置low到high处所获得的切片，len=high-low，cap=max-low</p>
</blockquote>
<p>新建切片对象依旧指向原底层数组，也就是说修改对所有关联切片可见。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">d</span><span style="color:#f92672">:=</span>[<span style="color:#f92672">...</span>]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>}
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s1</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">d</span>[<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">7</span>]
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">s2</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">s1</span>[<span style="color:#ae81ff">1</span>:<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">s2</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s2</span>[<span style="color:#a6e22e">i</span>]<span style="color:#f92672">+=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">s1</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">rpintln</span>(<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>输出：
[0 1 2 3 104 105 6 7 8 9]
[3 104 105 6]      //就是说 修改会全部修改
[104 105]
</code></pre><h3 id="append">
  append
  <a class="anchor" href="#append">#</a>
</h3>
<p>向切片尾部（slice[len])添加数据，返回新的切片对象。</p>
<p>数据被追加到原底层数组。如超出cap限制，则为新切片对象重新分配数组</p>
<blockquote>
<p>正因为存在重新分配底层数组的缘故，在某些场合建议预留足够多的空间，避免中途内存分配和数据复制开销。</p>
</blockquote>
<h4 id="删除第i个元素">
  删除第i个元素
  <a class="anchor" href="#%e5%88%a0%e9%99%a4%e7%ac%aci%e4%b8%aa%e5%85%83%e7%b4%a0">#</a>
</h4>
<p>a = append(a[:i], a[i+1:]&hellip;) // 删除中间1个元素</p>
<p>a = append(a[:i], a[i+N:]&hellip;) // 删除中间N个元素</p>
<p><img src="https://blockchaincode.oss-cn-hangzhou.aliyuncs.com/Hexo_img/202208252051362.jpeg" alt="" /></p>
<p>Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。</p>
<h4 id="在第i个位置增加元素">
  在第i个位置增加元素
  <a class="anchor" href="#%e5%9c%a8%e7%ac%aci%e4%b8%aa%e4%bd%8d%e7%bd%ae%e5%a2%9e%e5%8a%a0%e5%85%83%e7%b4%a0">#</a>
</h4>
<p>因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：</p>
<pre tabindex="0"><code>var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
</code></pre><p>每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。</p>
<h3 id="copy">
  copy
  <a class="anchor" href="#copy">#</a>
</h3>
<p>在两个切片对象间复制数据，允许指向同一底层数组，允许目标区间重叠。最终所复制长度以较短的切片长度（len)为准。<strong>将第二个切片里面的元素，拷贝到第一个切片中。</strong></p>
<p>返回值为int型，为返回复制的元素个数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s</span><span style="color:#f92672">:=</span>[]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">7</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">9</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">5</span>:<span style="color:#ae81ff">8</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span><span style="color:#f92672">:=</span>copy(<span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">4</span>:],<span style="color:#a6e22e">s1</span>)    <span style="color:#75715e">//在同一底层数组的不同区间复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>,<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">s2</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">int</span>,<span style="color:#ae81ff">6</span>)    <span style="color:#75715e">//在不数组间复制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">n</span>=copy(<span style="color:#a6e22e">s2</span>,<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">n</span>,<span style="color:#a6e22e">s2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>输出：
3 [0 1 2 3 5 6 7 7 8 9]
6 [0 1 2 3 5 6]
</code></pre><p>还可直接从字符串中复制数据到[]byte</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">b</span><span style="color:#f92672">:=</span>make([]<span style="color:#66d9ef">byte</span>,<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span><span style="color:#f92672">:=</span>copy(<span style="color:#a6e22e">b</span>,<span style="color:#e6db74">&#34;abcde&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.println(<span style="color:#a6e22e">n</span>,<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span> [<span style="color:#ae81ff">97</span> <span style="color:#ae81ff">98</span> <span style="color:#ae81ff">99</span>]  
</span></span></code></pre></div><h2 id="字典">
  字典
  <a class="anchor" href="#%e5%ad%97%e5%85%b8">#</a>
</h2>
<p>字典（哈希表）是一种使用频率极高的数据结构。</p>
<p>作为无序键值对集合，字典要求key必须是支持相等运算符（== ，!=)的数据类型。比如，数字、字符串、指针</p>
<p>数组、结构体，以及对应接口类型。</p>
<p>字典是引用类型，使用make函数或初始化表达语句来创建。</p>
<pre tabindex="0"><code>func main(){
 m:=make(map[string]int)
 m[&#34;a&#34;]=1
 m[&#34;b&#34;]=2
 m2:=map[int]struct{  //值为匿名结构体类型
    x int
 }{
    1: {x:100},      //可省略key,value类型标签
    2: {x:200},
 }
  fmt.println(m,m2)
}
</code></pre><p>访问不存在的键值，默认返回零值，不会引发错误。但推荐使用ok-idiom模式，毕竟通过零值无法判断键值是否存在，或许存储的value本就是零。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">map</span> [<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;a&#34;</span>:<span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#e6db74">&#34;b&#34;</span>:<span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;a&#34;</span>]=<span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;c&#34;</span>]=<span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">v</span>,<span style="color:#a6e22e">ok</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;d&#34;</span>];<span style="color:#a6e22e">ok</span>{   <span style="color:#75715e">//使用ok-idiom判断key是否存在，返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  println(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> delete(<span style="color:#a6e22e">m</span>,<span style="color:#e6db74">&#34;d&#34;</span>)       <span style="color:#75715e">//删除键值对。不存在时，不会出错
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>map是无序的，对字典进行迭代，每次返回的键值次序都不同。</p>
<p>函数len返回当前键值对数量，cap不接受字典类型。字典是“not addressable&rdquo;,故不能直接修改value成员（结构或数组）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">age</span>  <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#a6e22e">sting</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">1</span>:{<span style="color:#e6db74">&#34;tom&#34;</span>,<span style="color:#ae81ff">19</span>},
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>   <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>正确做法是返回整个value，待修改后再设置字典键值，会直接用指针类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">age</span>  <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#a6e22e">user</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#ae81ff">1</span>:{<span style="color:#e6db74">&#34;tom&#34;</span>,<span style="color:#ae81ff">19</span>},
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">u</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span>[<span style="color:#ae81ff">1</span>] =<span style="color:#a6e22e">u</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m2</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#f92672">*</span><span style="color:#a6e22e">user</span>{   <span style="color:#75715e">//value是指针类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#ae81ff">1</span>:<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">user</span>{<span style="color:#e6db74">&#34;jak&#34;</span>,<span style="color:#ae81ff">20</span>}
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m2</span>[<span style="color:#ae81ff">1</span>].<span style="color:#a6e22e">age</span><span style="color:#f92672">++</span>     <span style="color:#75715e">//返回的是指针，可透过指针修改目标对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>不能对nil字典进行写操作，但能读</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m1</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">string</span>   <span style="color:#75715e">//只是声明一个map，没有初始化, 为空(nil)map
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)  <span style="color:#75715e">//true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//m1[1] = &#34;Luffy&#34;      //nil的map不能使用err, panic: assignment to entry in nil map
</span></span></span></code></pre></div><pre tabindex="0"><code> m4 := make(map[int]string, 10)      //第2个参数指定容量
</code></pre><h2 id="结构体">
  结构体
  <a class="anchor" href="#%e7%bb%93%e6%9e%84%e4%bd%93">#</a>
</h2>
<p>结构体将多个不同类型命名字段序列打包成一个复合类型。</p>
<p>字段名必须唯一，可用“—”补位，支持使用自身指针类型成员。字段名、排列顺序属类型组成部分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">_</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n1</span>:<span style="color:#a6e22e">node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">id</span>:<span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n2</span>:<span style="color:#a6e22e">node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">id</span>:<span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">next</span>:<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n1</span>,
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可按顺序初始化全部字段，或使用命名方式初始化指定字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">age</span>  <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">u1</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">user</span>{<span style="color:#e6db74">&#34;tom&#34;</span>,<span style="color:#ae81ff">12</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">u2</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">user</span>{<span style="color:#e6db74">&#34;tom&#34;</span>}   <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="json格式数据">
  JSON格式数据
  <a class="anchor" href="#json%e6%a0%bc%e5%bc%8f%e6%95%b0%e6%8d%ae">#</a>
</h3>
<p>该程序成功得到了JSON格式的数据，但存在一个小问题是JSON字段普遍使用驼峰命名，上面我们得到的则是大写开头的。只需添加标签即可解决这个问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Name</span>    <span style="color:#66d9ef">string</span>  <span style="color:#e6db74">`json:&#34;name&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Age</span>     <span style="color:#66d9ef">int</span>     <span style="color:#e6db74">`json:&#34;age&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Hobbies</span>[] <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;hobbies&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们还可以在标签种加上omitempty，使程序在将结构体数据转换为JSON格式是忽略空值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Name</span>    <span style="color:#66d9ef">string</span>  <span style="color:#e6db74">`json:&#34;name,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Age</span>     <span style="color:#66d9ef">int</span>     <span style="color:#e6db74">`json:&#34;age,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Hobbies</span>[] <span style="color:#66d9ef">string</span> <span style="color:#e6db74">`json:&#34;hobbies,omitempty&#34;`</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="指针-1">
  指针
  <a class="anchor" href="#%e6%8c%87%e9%92%88-1">#</a>
</h2>
<p>内存地址是内存中每个字节单元的唯一编号，而指针则是一个实体。<strong>指针会分配内存空间</strong>，相当于一个专门用来保存地址的整型变量。</p>
<blockquote>
<p>指针运算为左值时，我们可更新目标对象状态，而为右值时则为了获取目标状态。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">x</span><span style="color:#f92672">:=</span><span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span> =<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>    <span style="color:#75715e">//取地址，保存到指针变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#f92672">*</span><span style="color:#a6e22e">p</span> <span style="color:#f92672">+=</span><span style="color:#ae81ff">20</span>           <span style="color:#75715e">//用指针间接引用，并更新对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> println(<span style="color:#a6e22e">p</span>,<span style="color:#f92672">*</span><span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>并非所有对象都能进行取地址操作</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">m</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{<span style="color:#e6db74">&#34;a&#34;</span>:<span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>println(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">m</span>[<span style="color:#e6db74">&#34;a&#34;</span>])      <span style="color:#75715e">//错误g
</span></span></span></code></pre></div></blockquote>
<p><strong>指针类型支持相等运算符，但不能做加减法运算和类型转换。</strong></p>
<p><strong>可通过unsafe.Pointer将指针转换为uintptr后进行加减法运算，但可能会造成非法访问。</strong></p>
<p><strong>Go语言保留了指针，但与C语言指针有所不同。主要体现在：</strong></p>
<ul>
<li>
<p>默认值 nil</p>
</li>
<li>
<p>操作符 &ldquo;&amp;&rdquo; 取变量地址， &ldquo;*&rdquo; 通过指针访问目标对象</p>
</li>
<li>
<p>不支持指针运算，不支持 &ldquo;-&gt;&rdquo; 运算符，直接⽤ &ldquo;.&rdquo; 访问目标成员</p>
</li>
</ul>
<h3 id="指向指针的指针">
  指向指针的指针
  <a class="anchor" href="#%e6%8c%87%e5%90%91%e6%8c%87%e9%92%88%e7%9a%84%e6%8c%87%e9%92%88">#</a>
</h3>
<p>如果一个指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。</p>
<p>当定义一个指向指针的指针变量时，第一个指针存放第二个指针的地址，第二个指针存放变量的地址：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/06/pointer_to_pointer.jpg" alt="img" /></p>
<p>指向指针的指针变量声明格式如下：</p>
<pre tabindex="0"><code>var ptr **int;
</code></pre><p>以上指向指针的指针变量为整型。</p>
<p>访问指向指针的指针变量值需要使用两个 * 号。</p>
<h3 id="指针作为函数参数">
  指针作为函数参数
  <a class="anchor" href="#%e6%8c%87%e9%92%88%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0">#</a>
</h3>
<p>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。</p>
<p><strong>指针作为参数进行传递时，为引用传递，也就是传递的地址。</strong></p>
<p>以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值，：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>= <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;交换前 a 的值 : %d\n&#34;</span>, <span style="color:#a6e22e">a</span> )
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;交换前 b 的值 : %d\n&#34;</span>, <span style="color:#a6e22e">b</span> )
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* 调用函数用于交换值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     &amp;a 指向 a 变量的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     &amp;b 指向 b 变量的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">swap</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;交换后 a 的值 : %d\n&#34;</span>, <span style="color:#a6e22e">a</span> )
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;交换后 b 的值 : %d\n&#34;</span>, <span style="color:#a6e22e">b</span> )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">swap</span>(<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">temp</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">temp</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">x</span>   <span style="color:#75715e">/* 保存 x 地址的值 */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">x</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">y</span>     <span style="color:#75715e">/* 将 y 赋值给 x */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">y</span> = <span style="color:#a6e22e">temp</span>   <span style="color:#75715e">/* 将 temp 赋值给 y */</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">以上实例允许输出结果为</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span></code></pre></div><pre tabindex="0"><code>交换前 a 的值 : 100
交换前 b 的值 : 200
交换后 a 的值 : 200
交换后 b 的值 : 100
</code></pre><h1 id="第六章-方法">
  第六章 方法
  <a class="anchor" href="#%e7%ac%ac%e5%85%ad%e7%ab%a0-%e6%96%b9%e6%b3%95">#</a>
</h1>
<h2 id="定义-3">
  定义
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89-3">#</a>
</h2>
<p>方法是与对象实例绑定的特殊函数。方法是有关联状态的，而函数通常没有。</p>
<p>可以为当前包，以及除接口和指针以外的任何类型定义方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/* 定义结构体 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Circle</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">radius</span> <span style="color:#66d9ef">float64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c1</span> <span style="color:#a6e22e">Circle</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c1</span>.<span style="color:#a6e22e">radius</span> = <span style="color:#ae81ff">10.00</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;圆的面积 = &#34;</span>, <span style="color:#a6e22e">c1</span>.<span style="color:#a6e22e">getArea</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">//该 method 属于 Circle 类型对象中的方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">Circle</span>) <span style="color:#a6e22e">getArea</span>() <span style="color:#66d9ef">float64</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//c.radius 即为 Circle 类型对象中的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">3.14</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">radius</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">radius</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法同样不支持重载（overload)。receiver参数名没有限制，按惯例会选用简短有意义的名称（不推荐使用this、self）。如方法内部并不引用实例，可省略参数名，仅保留类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;hi!&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>方法可看作特殊的函数，那么receiver的类型自然可以是基础类型或指针类型。这会关系到调用时对象实例是否被复制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">value</span> (){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;v:%p,%v\n&#34;</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>,<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">pointer</span>(){
</span></span><span style="display:flex;"><span>  (<span style="color:#f92672">*</span><span style="color:#a6e22e">n</span>)<span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;p:%p,%v\n&#34;</span>,<span style="color:#a6e22e">n</span>,<span style="color:#f92672">*</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">N</span>=<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">value</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">pointer</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;a:%p,%v\n&#34;</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>,<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>输出：
v:0xc8200741c8,26
p:0xc8200741c0,26
a:0xc8200741c0,26
</code></pre><p>可以使用实例值或指针调用方法，编译器会根据方法receiver类型自动在基础类型和指针类型之间转换。</p>
<p>不能用多级指针调用方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#a6e22e">N</span>=<span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span><span style="color:#f92672">:=&amp;</span><span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p2</span><span style="color:#f92672">:=&amp;</span><span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p2</span>.<span style="color:#a6e22e">value</span>() <span style="color:#75715e">//错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">p2</span>.<span style="color:#a6e22e">pointer</span>()  <span style="color:#75715e">//错误g
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>指针类型的receiver必须是合法指针（包括nil），或能获取实例地址。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">X</span>)<span style="color:#a6e22e">test</span>(){
</span></span><span style="display:flex;"><span>  println(<span style="color:#e6db74">&#34;hi&#34;</span>,<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">x</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">test</span>()   <span style="color:#75715e">//相当于test(nil)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">x</span>{},<span style="color:#a6e22e">test</span>() <span style="color:#75715e">// 错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>如何选择方法的receiver类型？</p>
<ul>
<li>要修改实例状态，用*T。</li>
<li>无须修改状态的小对象或固定值，建议用T。</li>
<li>大对象建议用*T，以减少复制成本。</li>
<li>引用类型、字符串、函数等指针包装对象，直接用T。</li>
<li>若包含Mutex等同步字段，用*T，避免因复制造成锁操作无效。</li>
<li>其他无法确定的情况，都用*T。</li>
</ul>
<h2 id="匿名字段">
  匿名字段
  <a class="anchor" href="#%e5%8c%bf%e5%90%8d%e5%ad%97%e6%ae%b5">#</a>
</h2>
<p><strong>可以像访问匿名字段成员那样调用其方法</strong>，由编译器负责查找。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">buf</span> [<span style="color:#ae81ff">1024</span>]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">data</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Lock</span>()    <span style="color:#75715e">//编译会处理为sync.(*Mutex).Lock()调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>同名遮蔽问题</strong>，利用这种特性，可实现类似覆盖（override)操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">user</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">manager</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">user</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">user</span>) <span style="color:#a6e22e">toString</span>() <span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;user&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">manager</span>) <span style="color:#a6e22e">toString</span>()<span style="color:#66d9ef">string</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">retrun</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">toString</span>()<span style="color:#f92672">+</span><span style="color:#e6db74">&#34;;manager&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#a6e22e">manager</span>
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">user</span>.<span style="color:#a6e22e">toString</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>输出：
user;manager
user
尽管能直接访问匿名字段的成员和方法，但它们依然不属于继承关系。
</code></pre><h2 id="方法集">
  方法集
  <a class="anchor" href="#%e6%96%b9%e6%b3%95%e9%9b%86">#</a>
</h2>
<p>类型有一个与之相关的方法集（method set），这决定了它是否实现某个接口。</p>
<ul>
<li>类型 T 方法集包含所有 receiver T 方法。</li>
<li>类型 *T 方法集包含所有 receiver T + *T 方法。</li>
<li>匿名嵌入 S，T 方法集包含所有 receiver S 方法。</li>
<li>匿名嵌入 *S，T 方法集包含所有 receiver S + *S 方法。</li>
<li>匿名嵌入 S 或 *S，*T 方法集包含所有 receiver S + *S 方法。</li>
<li>可利用反射（reflect）测试这些规则。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">S</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">S</span>                  <span style="color:#75715e">// 匿名嵌入字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">S</span>) <span style="color:#a6e22e">sVal</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">S</span>) <span style="color:#a6e22e">sPtr</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">tVal</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">tPtr</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">methodSet</span>(<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{}) {     <span style="color:#75715e">// 显示方法集里所有方法名字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">NumMethod</span>(); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Method</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Type</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">T</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">methodSet</span>(<span style="color:#a6e22e">t</span>)                 <span style="color:#75715e">// 显示 T 方法集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> println(<span style="color:#e6db74">&#34;----------&#34;</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">methodSet</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>)                <span style="color:#75715e">// 显示 *T 方法集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>sVal func(main.T)
tVal func(main.T)
----------------------
sPtr func(*main.T)
sVal func(*main.T)
tPtr func(*main.T)
tVal func(*main.T)
</code></pre><p>输出结果符合预期，但我们也注意到某些方法的 receiver 类型发生了改变。真实情况是，这些都是由编译器按方法集所需自动生成的额外包装方法。</p>
<p>方法集仅影响接口实现和方法表达式转换，与通过实例或实例指针调用方法无关。实例 并不使用方法集，而是直接调用（或通过隐式字段名）。 很显然，匿名字段就是为方法集准备的。</p>
<blockquote>
<p>组合没有父子依赖，不会破坏封装。且整体和局部松耦合，可任意增加来实现扩展。各单元持 有单一职责，互无关联，实现和维护更加简单。</p>
<p>尽管接口也是多态的一种实现形式，但我认为应该和基于继承体系的多态分离开来。</p>
</blockquote>
<h2 id="表达式">
  表达式
  <a class="anchor" href="#%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h2>
<p>方法和函数一样，除直接调用外，还可赋值给变量，或作为参数传递。依照具体引用方 式的不同，可分为 expression 和 value 两种状态。</p>
<h3 id="method-expression">
  Method Expression
  <a class="anchor" href="#method-expression">#</a>
</h3>
<p>通过类型引用的 method expression 会被还原为普通函数样式，receiver 是第一参数，调 用时须显式传参。至于类型，可以是 T 或 *T，只要目标方法存在于该类型方法集中即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;test.n: %p, %d\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span> = <span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;main.n: %p, %d\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">N</span>.<span style="color:#a6e22e">test</span>                           <span style="color:#75715e">// func(n N)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">f1</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>).<span style="color:#a6e22e">test</span> <span style="color:#75715e">// func(n *N)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">f2</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>)                      <span style="color:#75715e">// 按方法集中的签名传递正确类型的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main.n: 0xc82000a140, 25
test.n: 0xc82000a158, 25
test.n: 0xc82000a168, 25
</code></pre><p>*<em>尽管 <em>N 方法集包装的 test 方法 receiver 类型不同，但编译器会保证按原定义类型拷贝传值。</em></em></p>
<p>当然，也可直接以表达式方式调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span> = <span style="color:#ae81ff">25</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">N</span>.<span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>).<span style="color:#a6e22e">test</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>)           <span style="color:#75715e">// 注意: *N 须使用括号，以免语法解析错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="method-value">
  Method Value
  <a class="anchor" href="#method-value">#</a>
</h3>
<p>基于实例或指针引用的 method value，参数签名不会改变，依旧按正常方式调用。</p>
<p>但当 method value 被赋值给变量或作为参数传递时，会立即计算并复制该方法执行所需 的 receiver 对象，与其绑定，以便在稍后执行时，能隐式传入 receiver 参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;test.n: %p, %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">test</span>                      <span style="color:#75715e">// 因为 test 方法的 receiver 是 N 类型，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                    <span style="color:#75715e">// 所以复制 n，等于 101
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">test</span>                      <span style="color:#75715e">// 复制 *p，等于 102
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;main.n: %p, %v\n&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f1</span>()
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f2</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main.n: 0xc820076028, 103
test.n: 0xc820076060, 101
test.n: 0xc820076070, 102
</code></pre><p><strong>编译器会为 method value 生成一个包装函数，实现间接调用。至于 receiver 复制，和闭包的实 现方法基本相同，打包成 funcval，经由 DX 寄存器传递。</strong></p>
<p>当 method value 作为参数时，会复制含 receiver 在内的整个 method value。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">m</span> <span style="color:#66d9ef">func</span>()) {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">m</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;main.n: %p, %v\n&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">test</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main.n: 0xc82000a288, 100
test.n: 0xc82000a2c0, 101
test.n: 0xc82000a2d0, 102
</code></pre><p>当然，如果目标方法的 receiver 是指针类型，那么被复制的仅是指针。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">test</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;test.n: %p, %v\n&#34;</span>, <span style="color:#a6e22e">n</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span> = <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">test</span>                 <span style="color:#75715e">// 因为 test 方法的 receiver 是 *N 类型，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                            <span style="color:#75715e">// 所以复制 &amp;n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">test</span>               <span style="color:#75715e">// 复制 p 指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;main.n: %p, %v\n&#34;</span>, <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">f1</span>()                       <span style="color:#75715e">// 延迟调用，n == 103
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">f2</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main.n: 0xc82000a298, 103
test.n: 0xc82000a298, 103
test.n: 0xc82000a298, 103
</code></pre><p>只要 receiver 参数类型正确，使用 nil 同样可以执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">value</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">pointer</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">pointer</span>()                      <span style="color:#75715e">// method value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>)(<span style="color:#66d9ef">nil</span>).<span style="color:#a6e22e">pointer</span>()              <span style="color:#75715e">// method value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>).<span style="color:#a6e22e">pointer</span>(<span style="color:#66d9ef">nil</span>)                 <span style="color:#75715e">// method expression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// p.value()        // 错误: invalid memory address or nil pointer dereference
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="第七章-接口">
  第七章 接口
  <a class="anchor" href="#%e7%ac%ac%e4%b8%83%e7%ab%a0-%e6%8e%a5%e5%8f%a3">#</a>
</h1>
<h2 id="定义-4">
  定义
  <a class="anchor" href="#%e5%ae%9a%e4%b9%89-4">#</a>
</h2>
<p>接口代表一种调用契约，是多个方法声明的集合。</p>
<p>在某些动态语言里，接口（interface）也被称作协议（protocol）。准备交互的双方，共 同遵守事先约定的规则，使得在无须知道对方身份的情况下进行协作。接口要实现的是 做什么，而不关心怎么做，谁来做。</p>
<p>接口解除了类型依赖，有助于减少用户可视方法，屏蔽内部结构和实现细节。接口最常见 的使用场景，是对包外提供访问，或预留扩展空间。</p>
<p>Go 接口实现机制很简洁，**只要目标类型方法集内包含接口声明的全部方法，就被视为 实现了该接口，无须做显示声明。**当然，目标类型可实现多个接口。</p>
<p>从内部实现来看，接口自身也是一种结构类型，只是编译器会对其做出很多限制。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>不能有字段</li>
<li>不能定义自己的方法</li>
<li>只能声明方法，不能实现</li>
<li>可嵌入其他接口类型</li>
</ul>
<p><strong>接口通常以 er 作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tester</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span> string() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">data</span>) <span style="color:#a6e22e">test</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">data</span>) string() <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// var t tester = d                  // 错误: data does not implement tester
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                        <span style="color:#75715e">// (test method has pointer receiver)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">tester</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">t</span>.string())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>编译器根据方法集来判断是否实现了接口，显然在上例中只有 *data 才复合 tester 的要求。
</code></pre><p>如果接口没有任何方法声明，那么就是一个空接口（interface{}），它的用途类似面向对象里的根类型 Object，可被赋值为任何类型的对象。</p>
<p>接口变量默认值是 nil。如果实现接口的类型支持，可做相等运算。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">t2</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">t1</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">t1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t2</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">t2</span> = <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">t1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t2</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t1</span>, <span style="color:#a6e22e">t2</span> = <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{}, <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">int</span>{}
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">t1</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">t2</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>true true
true
panic: runtime error: comparing uncomparable type map[string]int
</code></pre><p><strong>可以像匿名字段那样，嵌入其他接口。目标类型方法集中必须拥有包含嵌入接口方法在 内的全部方法才算实现了该接口。</strong></p>
<blockquote>
<p>嵌入其他接口类型，相当于将其声明的方法集导入。这就要求不能有同名方法，因为不支持重 载。还有，不能嵌入自身或循环嵌入，那会导致递归错误。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">stringer</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span> string() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tester</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">stringer</span>                    <span style="color:#75715e">// 嵌入其他接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">data</span>) <span style="color:#a6e22e">test</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">data</span>) string() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">tester</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">t</span>.string())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>超集接口变量可隐式转换为子集，反过来不行。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pp</span>(<span style="color:#a6e22e">a</span> <span style="color:#a6e22e">stringer</span>) {
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">a</span>.string())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">tester</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pp</span>(<span style="color:#a6e22e">t</span>)                             <span style="color:#75715e">// 隐式转换为子集接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">s</span> <span style="color:#a6e22e">stringer</span> = <span style="color:#a6e22e">t</span>                <span style="color:#75715e">// 超级转换为子集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  println(<span style="color:#a6e22e">s</span>.string())
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// var t2 tester = s              // 错误: stringer does not implement tester
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                                    <span style="color:#75715e">// (missing test method)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>支持匿名接口类型，可直接用于变量定义，或作为结构字段类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">data</span>) string() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">interface</span> {                <span style="color:#75715e">// 匿名接口类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> string() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">interface</span> {               <span style="color:#75715e">// 定义匿名接口变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> string() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span> } = <span style="color:#a6e22e">data</span>{}
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">node</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">data</span>: <span style="color:#a6e22e">t</span>,
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> println(<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">data</span>.string())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="执行机制">
  执行机制
  <a class="anchor" href="#%e6%89%a7%e8%a1%8c%e6%9c%ba%e5%88%b6">#</a>
</h2>
<p>接口使用一个名为 itab 的结构存储运行期所需的相关类型信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tab</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>                <span style="color:#75715e">// 类型信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>      <span style="color:#75715e">// 实际对象指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">itab</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>     <span style="color:#75715e">// 接口类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>             <span style="color:#75715e">// 实际对象类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fun</span> [<span style="color:#ae81ff">1</span>]<span style="color:#66d9ef">uintptr</span>           <span style="color:#75715e">// 实际对象方法地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>利用调试器，我们可查看这些结构存储的具体内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Ner</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">a</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">b</span>(<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">c</span>(<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">N</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">a</span>() {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">b</span>(<span style="color:#66d9ef">int</span>) {}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">N</span>) <span style="color:#a6e22e">c</span>(<span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> { <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">n</span> <span style="color:#a6e22e">N</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">Ner</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">a</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>$ go build -gcflags &#34;-N -l&#34;
$ gdb test
...
(gdb) info locals                    # 设置断点，运行，查看局部变量信息
&amp;n = 0xc82000a130
t = {
 tab = 0x12f028,
 data = 0xc82000a130
}
(gdb) p *t.tab.inter.typ._string    # 接口类型名称
$17 = 0x737f0 &#34;main.Ner&#34;
(gdb) p *t.tab._type._string        # 实际对象类型
$20 = 0x707a0 &#34;*main.N&#34;
(gdb) p t.tab.inter.mhdr            # 接口类型方法集
$27 = {
 array = 0x60158 &lt;type.*+72888&gt;,
 len = 3,
 cap = 3
}
(gdb) p *t.tab.inter.mhdr.array[0].name       # 接口方法名称
$30 = 0x70a48 &#34;a&#34;
(gdb) p *t.tab.inter.mhdr.array[1].name
$31 = 0x70b08 &#34;b&#34;
(gdb) p *t.tab.inter.mhdr.array[2].name
$32 = 0x70ba0 &#34;c&#34;
(gdb) info symbol t.tab.fun[0]                # 实际对象方法地址
main.(*N).a in section .text
(gdb) info symbol t.tab.fun[1]
main.(*N).b in section .text
(gdb) info symbol t.tab.fun[2]
main.(*N).c in section .text
</code></pre><p>很显然，相关类型信息里保存了接口和实际对象的元数据。同时，itab 还用 fun 数组 （不定长结构）保存了实际方法地址，从而实现在运行期对目标方法的动态调用。</p>
<p>除此之外，接口还有一个重要特征：将对象赋值给接口变量时，会复制该对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>{<span style="color:#ae81ff">100</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">t</span>.(<span style="color:#a6e22e">data</span>).<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>$ go build -gcflags &#34;-N -l&#34;
$ gdb test
(gdb) info locals           # 输出局部变量
d = {
 x = 100
}
t = {
 _type = 0x5ec00 &lt;type.*+67296&gt;,
 data = 0xc820035f20       # 接口变量存储的对象地址
}
(gdb) p/x &amp;d               # 局部变量地址。显然和接口存储的不是同一对象
$1 = 0xc820035f10
</code></pre><p>我们甚至无法修改接口存储的复制品，因为它也是 unaddressable 的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>{<span style="color:#ae81ff">100</span>}
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.(<span style="color:#a6e22e">data</span>)                    <span style="color:#75715e">// 错误: cannot take the address of t.(data)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">t</span>.(<span style="color:#a6e22e">data</span>).<span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">200</span>                  <span style="color:#75715e">// 错误: cannot assign to t.(data).x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>即便将其复制出来，用本地变量修改后，依然无法对 iface.data 赋值。解决方法就是将 对象指针赋值给接口，那么接口内存储的就是指针的复制品。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>{<span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">t</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">data</span>).<span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">t</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">data</span>).<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>$ go build -gcflags &#34;-N -l&#34; &amp;&amp; ./test
200
$ gdb test
(gdb) info locals               # 显示局部变量
d = {
 x = 100
}
t = {
 _type = 0x50480 &lt;type.*+8096&gt;,
 data = 0xc820035f10
}
(gdb) p/x &amp;d                    # 显然和接口内 data 存储的地址一致
$1 = 0xc820035f10
</code></pre><p>只有当接口变量内部的两个指针（itab, data）都为 nil 时，接口才等于 nil。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">interface</span>{} = (<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>true false
(gdb) info locals
b = {
  _type = 0x500c0 &lt;type.*+7616&gt;,          # 显然 b 包含了类型信息
  data = 0x0
}
a = {
  _type = 0x0,
  data = 0x0
}
</code></pre><p>由此造成的错误并不罕见，尤其是在函数返回 error 时。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TestError</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">TestError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;error&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">TestError</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">err</span> = new(<span style="color:#a6e22e">TestError</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">err</span>                       <span style="color:#75715e">// 注意: 这个 err 是有类型的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatalln</span>(<span style="color:#e6db74">&#34;err != nil&#34;</span>)              <span style="color:#75715e">// 此处被执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>2020/01/01 19:48:27 err != nil
exit status 1
(gdb) info locals           # 很显然 x 没问题，但 err 并不等于 nil
x = 200
err = {
  tab = 0x2161e8, # tab != nil
  data = 0x0
}
</code></pre><p>正确做法是明确返回 nil。</p>
<pre tabindex="0"><code>func test(x int) (int, error) {
  if x &lt; 0 {
  return 0, new(TestError)
 }
  return x + 100, nil
}
</code></pre><h2 id="类型转换-1">
  类型转换
  <a class="anchor" href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2-1">#</a>
</h2>
<p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;data:%d&#34;</span>, <span style="color:#a6e22e">d</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span> = <span style="color:#ae81ff">15</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span>.(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Stringer</span>); <span style="color:#a6e22e">ok</span> { <span style="color:#75715e">// 转换为更具体的接口类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">d2</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span>.(<span style="color:#a6e22e">data</span>); <span style="color:#a6e22e">ok</span> { <span style="color:#75715e">// 转换回原始类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d2</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span>.(<span style="color:#66d9ef">error</span>) <span style="color:#75715e">// 错误: main.data is not error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">e</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>data:15
data:15
panic: interface conversion: main.data is not error: missing method Error
</code></pre><p>使用 ok-idiom 模式，即便转换失败也不会引发 panic。还可用 switch 语句在多种类型间 做出推断匹配，这样空接口就有更多发挥空间。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>   			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;d:%d&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">x</span>.(<span style="color:#66d9ef">type</span>) { <span style="color:#75715e">// 局部变量 v 是类型转换后的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
</span></span><span style="display:flex;"><span>   			println(<span style="color:#e6db74">&#34;nil&#34;</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>:
</span></span><span style="display:flex;"><span>  		  println(<span style="color:#f92672">*</span><span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">func</span>(<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">string</span>:
</span></span><span style="display:flex;"><span>   			println(<span style="color:#a6e22e">v</span>(<span style="color:#ae81ff">100</span>))
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Stringer</span>:
</span></span><span style="display:flex;"><span>   			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>   			println(<span style="color:#e6db74">&#34;unknown&#34;</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>d:100
提示：type switch 不支持 fallthrought。
</code></pre><h2 id="技巧">
  技巧
  <a class="anchor" href="#%e6%8a%80%e5%b7%a7">#</a>
</h2>
<p>让编译器检查，确保类型实现了指定接口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">init</span>() {                                  <span style="color:#75715e">// 包初始化函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Stringer</span> = <span style="color:#a6e22e">x</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>cannot use x(0) (type x) as type fmt.Stringer in assignment:
 x does not implement fmt.Stringer (missing String method)
</code></pre><p>定义函数类型，让相同签名的函数自动实现某个接口。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FuncString</span> <span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">f</span> <span style="color:#a6e22e">FuncString</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Stringer</span> = <span style="color:#a6e22e">FuncString</span>(<span style="color:#66d9ef">func</span>() <span style="color:#66d9ef">string</span> { <span style="color:#75715e">// 转换类型，使其实现 Stringer接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;hello, world!&#34;</span>
</span></span><span style="display:flex;"><span> })
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="第八章-并发">
  第八章 并发
  <a class="anchor" href="#%e7%ac%ac%e5%85%ab%e7%ab%a0-%e5%b9%b6%e5%8f%91">#</a>
</h1>
<h2 id="含义">
  含义
  <a class="anchor" href="#%e5%90%ab%e4%b9%89">#</a>
</h2>
<p>并发（concurrency）和并行（parallesim）的区别。</p>
<ul>
<li>并发：逻辑上具备同时处理多个任务的能力。</li>
<li>并行：物理上在同一时刻执行多个并发任务。</li>
</ul>
<p>我们通常会说程序是并发设计的，也就是说它允许多个任务同时执行，但实际上并不一 定真在同一时刻发生。在单核处理器上，它们能以间隔方式切换执行。而并行则依赖多 核处理器等物理设备，让多个任务真正在同一时刻执行，它代表了当前程序运行状态。 简单点说，并行是并发设计的理想执行模式。</p>
<p>多线程或多进程是并行的基本条件，但单线程也可用协程（coroutine）做到并发。尽管 协程在单个线程上通过主动切换来实现多任务并发，但它也有自己的优势。除了将因阻 塞而浪费的时间找回来外，还免去了线程切换开销，有着不错的执行效率。协程上运行 的多个任务本质上是依旧串行的，加上可控自主调度，所以并不需要做同步处理。</p>
<blockquote>
<p>即便采用多线程也未必就能并行。Python 就因 GIL 限制，默认只能并发而不能并行，所以很多 时候转而使用“多进程 + 协程”架构。</p>
</blockquote>
<p>很难说哪种方式更好一些，它们有各自适用的场景。<strong>通常情况下，用多进程来实现分布式和负载平衡，减轻单进程垃圾回收压力；用多线程（LWP）抢夺更多的处理器资源； 用协程来提高处理器时间片利用率。</strong></p>
<p>简单将 goroutine 归纳为协程并不合适。运行时会创建多个线程来执行并发任务，且任务单元可被调度到其他线程并行执行。<strong>这更像是多线程和协程的综合体，能最大限度提升执行效率，发挥多核处理能力。</strong></p>
<p>只须在函数调用前添加 go 关键字即可创建并发任务。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">go</span> println(<span style="color:#e6db74">&#34;hello, world!&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>  println(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}(<span style="color:#e6db74">&#34;hello, world!&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">注意是函数调用</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#a6e22e">所以必须提供相应的参数</span><span style="color:#960050;background-color:#1e0010">。</span>
</span></span></code></pre></div><p>关键字 go 并非执行并发操作，而是创建一个并发任务单元。新建任务被放置在系统队 列中，等待调度器安排合适系统线程去获取执行权。当前流程不会阻塞，不会等待该任 务启动，且运行时也不保证并发任务的执行次序。</p>
<p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间。相比系 统 默认 MB 级别的线程栈，goroutine 自定义栈初始仅须 2 KB，所以才能创建成千上万 的并发任务。自定义栈采取按需分配策略，在需要时进行扩容，最大能到 GB 规模。</p>
<p>与 defer 一样，goroutine 也会因“延迟执行”而立即计算并复制执行参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">counter</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)         <span style="color:#75715e">// 让 goroutine 在 main 逻辑之后执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;go:&#34;</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span>)
</span></span><span style="display:flex;"><span> }(<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">counter</span>())                     <span style="color:#75715e">// 立即计算并复制参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">a</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;main:&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">counter</span>())
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>)       <span style="color:#75715e">// 等待 goroutine 结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main: 200 2
go: 100 1
</code></pre><h3 id="wait">
  Wait
  <a class="anchor" href="#wait">#</a>
</h3>
<p>进程退出时不会等待并发任务结束，可用通道（channel）阻塞，然后发出退出信号。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> 		<span style="color:#a6e22e">exit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})  <span style="color:#75715e">// 创建通道。因为仅是通知，数据并没有实际意义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	  <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>       println(<span style="color:#e6db74">&#34;goroutine done.&#34;</span>)
</span></span><span style="display:flex;"><span>       close(<span style="color:#a6e22e">exit</span>)               <span style="color:#75715e">// 关闭通道，发出信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }()
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;main ...&#34;</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">exit</span>                      <span style="color:#75715e">// 如通道关闭，立即解除阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;main exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main ...
goroutine done.
main exit.
</code></pre><p><strong>除关闭通道外，写入数据也可解除阻塞。channel 的更多信息，后面再做详述。</strong></p>
<p>如要等待多个任务结束，推荐使用 sync.WaitGroup。通过设定计数器，让每个 goroutine 在退出前递减，直至归零时解除阻塞。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	 <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	 <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)                                    <span style="color:#75715e">// 累加计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()                               <span style="color:#75715e">// 递减计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>       println(<span style="color:#e6db74">&#34;goroutine&#34;</span>, <span style="color:#a6e22e">id</span>, <span style="color:#e6db74">&#34;done.&#34;</span>)
</span></span><span style="display:flex;"><span> }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;main ...&#34;</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()                                      <span style="color:#75715e">// 阻塞，直到计数归零
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;main exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>main ...
goroutine 9 done.
goroutine 4 done.
goroutine 2 done.
goroutine 6 done.
goroutine 8 done.
goroutine 3 done.
goroutine 5 done.
goroutine 1 done.
goroutine 0 done.
goroutine 7 done.
main exit.
</code></pre><p>尽管 WaitGroup.Add 实现了原子操作，但建议在 goroutine 外累加计数器，以免 Add 尚 未执行，Wait 已经退出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> 		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>  	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)                               <span style="color:#75715e">// 来不及设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println(<span style="color:#e6db74">&#34;hi!&#34;</span>)
</span></span><span style="display:flex;"><span> }()
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可在多处使用 Wait 阻塞，它们都能接收到通知。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()                         <span style="color:#75715e">// 等待归零，解除阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;wait exit.&#34;</span>)
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;done.&#34;</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()                        <span style="color:#75715e">// 递减计数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()                          <span style="color:#75715e">// 等待归零，解除阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   println(<span style="color:#e6db74">&#34;main exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>done.
wait exit.
main exit.
</code></pre><h3 id="gomaxprocs">
  GOMAXPROCS
  <a class="anchor" href="#gomaxprocs">#</a>
</h3>
<p>运行时可能会创建很多线程，但任何时候仅有限的几个线程参与并发任务执行。该数量 默认与处理器核数相等，可用 runtime.GOMAXPROCS 函数（或环境变量）修改。</p>
<p><strong>如参数小于 1，GOMAXPROCS 仅返回当前设置值，不做任何调整。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 测试目标函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">count</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MaxUint32</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">x</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 循环执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">count</span>()
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 并发执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test2</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">count</span>()
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// test2(n)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code>$ time ./test
9223372030412324865
9223372030412324865
9223372030412324865
9223372030412324865
real 0m8.395s
user 0m8.281s
sys 0m0.056s
$ time ./test2
9223372030412324865
9223372030412324865
9223372030412324865
9223372030412324865
real 0m3.907s   // 程序实际执行时间
user 0m14.438s   // 多核执行时间累加
sys 0m0.041s
</code></pre><h3 id="local-storage">
  Local Storage
  <a class="anchor" href="#local-storage">#</a>
</h3>
<p>与线程不同，goroutine 任务无法设置优先级，无法获取编号，没有局部存储（TLS）， 甚至连返回值都会被抛弃。但除优先级外，其他功能都很容易实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">gs</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">struct</span> {        <span style="color:#75715e">// 用于实现类似 TLS 功能
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>                    <span style="color:#75715e">// 编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">result</span> <span style="color:#66d9ef">int</span>                <span style="color:#75715e">// 返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">gs</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>) {          <span style="color:#75715e">// 使用参数避免闭包延迟求值  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">gs</span>[<span style="color:#a6e22e">id</span>].<span style="color:#a6e22e">id</span> = <span style="color:#a6e22e">id</span>
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">gs</span>[<span style="color:#a6e22e">id</span>].<span style="color:#a6e22e">result</span> = (<span style="color:#a6e22e">id</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span> }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%+v\n&#34;</span>, <span style="color:#a6e22e">gs</span>)
</span></span><span style="display:flex;"><span>}  
</span></span></code></pre></div><pre tabindex="0"><code>{id:0 result:100} {id:1 result:200} {id:2 result:300} {id:3 result:400} {id:4 result:500}
如使用 map 作为局部存储容器，建议做同步处理，因为运行时会对其做并发读写检查。
</code></pre><h3 id="gosched">
  Gosched
  <a class="anchor" href="#gosched">#</a>
</h3>
<p>暂停，释放线程去执行其他任务。当前任务被放回队列，等待下次调度时恢复执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">GOMAXPROCS</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">exit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {               <span style="color:#75715e">// 任务 a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">exit</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {              <span style="color:#75715e">// 任务 b。放在此处，是为了确保 a 优先执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   println(<span style="color:#e6db74">&#34;b&#34;</span>)
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">4</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;a:&#34;</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {             <span style="color:#75715e">// 让出当前线程，调度执行 b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	 <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Gosched</span>()
</span></span><span style="display:flex;"><span>   		}
</span></span><span style="display:flex;"><span>   	}
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">exit</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>a: 0
a: 1
b
a: 2
a: 3
</code></pre><p>该函数很少被使用，因为运行时会主动向长时间运行（10 ms）的任务发出抢占调度。 只是当前版本实现的算法稍显粗糙，不能保证调度总能成功，所以主动切换还有适用场 合。</p>
<h3 id="goexit">
  Goexit
  <a class="anchor" href="#goexit">#</a>
</h3>
<p>Goexit 立即终止当前任务，运行时确保所有已注册延迟调用被执行。该函数不会影响其 他并发任务，不会引发 panic，自然也就无法捕获。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span> 	<span style="color:#a6e22e">exit</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">exit</span>) <span style="color:#75715e">// 执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">defer</span> println(<span style="color:#e6db74">&#34;a&#34;</span>) <span style="color:#75715e">// 执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 	<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     println(<span style="color:#e6db74">&#34;b&#34;</span>, recover() <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// 执行，recover 返回 nil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	 }()
</span></span><span style="display:flex;"><span>	 <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 在多层调用中执行 Goexit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;c&#34;</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Goexit</span>() <span style="color:#75715e">// 立即终止整个调用堆栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     println(<span style="color:#e6db74">&#34;c done.&#34;</span>) <span style="color:#75715e">// 不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 	}()
</span></span><span style="display:flex;"><span>		 println(<span style="color:#e6db74">&#34;b done.&#34;</span>) <span style="color:#75715e">// 不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }()
</span></span><span style="display:flex;"><span> 		 println(<span style="color:#e6db74">&#34;a done.&#34;</span>) <span style="color:#75715e">// 不会执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> }()
</span></span><span style="display:flex;"><span>	 <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">exit</span>
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;main exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>c
b true
a
main exit.
</code></pre><p>如果在 main.main 里调用 Goexit，它会等待其他任务结束，然后让进程直接崩溃。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">n</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%c: %d\n&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">n</span>)
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Millisecond</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">Goexit</span>()             <span style="color:#75715e">// 等待所有任务结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   println(<span style="color:#e6db74">&#34;main exit.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>b: 0
a: 0
b: 1
a: 1
fatal error: no goroutines (main called runtime.Goexit) - deadlock!

无论身处哪一层，Goexit 都能立即终止整个调用堆栈，这与 return 仅退出当前函数不同。
标准库函数 os.Exit 可终止进程，但不会执行延迟调用。
</code></pre><h2 id="通道">
  通道
  <a class="anchor" href="#%e9%80%9a%e9%81%93">#</a>
</h2>
<p>相比 Erlang，Go 并未实现严格的并发安全。</p>
<p>允许全局变量、指针、引用类型这些非安全内存共享操作，就需要开发人员自行维护数 据一致和完整性。Go 鼓励使用 CSP 通道，以通信来代替内存共享，实现并发安全。</p>
<p>通过消息来避免竞态的模型除了 CSP，还有 Actor。但两者有较大区别。</p>
<p>作为 CSP 核心，通道（channel）是显式的，要求操作双方必须知道数据类型和具体通 道，并不关心另一端操作者身份和数量。可如果另一端未准备妥当，或消息未能及时处 理时，会阻塞当前端。</p>
<p>相比起来，Actor 是透明的，它不在乎数据类型及通道，只要知道接收者信箱即可。默 认就是异步方式，发送方对消息是否被接收和处理并不关心。</p>
<p>从底层实现上来说，通道只是一个队列。同步模式下，发送和接收双方配对，然后直接 复制数据给对方。如配对失败，则置入等待队列，直到另一方出现后才被唤醒。异步模 式抢夺的则是数据缓冲槽。发送方要求有空槽可供写入，而接收方则要求有缓冲数据可 读。需求不符时，同样加入等待队列，直到有另一方写入数据或腾出空槽后被唤醒。</p>
<p>除传递消息（数据）外，通道还常被用作事件通知。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}) <span style="color:#75715e">// 结束事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">string</span>) <span style="color:#75715e">// 数据传输通道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span> <span style="color:#75715e">// 接收消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   	 println(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>     close(<span style="color:#a6e22e">done</span>) <span style="color:#75715e">// 关闭通道，作为结束通知
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#e6db74">&#34;hi!&#34;</span> <span style="color:#75715e">// 发送消息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span> <span style="color:#75715e">// 阻塞，直到有数据或管道关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code>hi!
</code></pre><p>同步模式必须有配对操作的 goroutine 出现，否则会一直阻塞。而异步模式在缓冲区未 满或数据未读完前，不会阻塞。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>) <span style="color:#75715e">// 创建带 3 个缓冲槽的异步通道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 缓冲区未满，不会阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>   println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>) <span style="color:#75715e">// 缓冲区尚有数据，不会阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   println(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>1
2

多数时候，异步通道有助于提升性能，减少排队阻塞。
</code></pre><p>缓冲区大小仅是内部属性，不属于类型组成部分。另外通道变量本身就是指针，可用相 等操作符判断是否为同一对象或 nil。</p>
<pre tabindex="0"><code>func main() {
   var a, b chan int = make(chan int, 3), make(chan int)
   var c chan bool
   println(a == b)
   println(c == nil)
   fmt.Printf(&#34;%p, %d\n&#34;, a, unsafe.Sizeof(a))
}
</code></pre><pre tabindex="0"><code>false
true
0xc820076000, 8

虽然可传递指针来避免数据复制，但须额外注意数据并发安全。
</code></pre><p>内置函数 cap 和 len 返回缓冲区大小和当前已缓冲数量；而对于同步通道则都返回 0， 据此可判断通道是同步还是异步。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>), make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;a:&#34;</span>, len(<span style="color:#a6e22e">a</span>), cap(<span style="color:#a6e22e">a</span>))
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;b:&#34;</span>, len(<span style="color:#a6e22e">b</span>), cap(<span style="color:#a6e22e">b</span>))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>a: 0 0
b: 2 3
</code></pre><h3 id="收发">
  收发
  <a class="anchor" href="#%e6%94%b6%e5%8f%91">#</a>
</h3>
<p>除使用简单的发送和接收操作符外，还可用 ok-idom 或 range 模式处理数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">done</span>) <span style="color:#75715e">// 确保发出结束通知
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> { <span style="color:#75715e">// 据此判断通道是否被关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>     	println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>   close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>1
2
3
</code></pre><p>对于循环接收数据，range 模式更简洁一些。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">done</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> { <span style="color:#75715e">// 循环获取消息，直到通道被关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  	 println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   }()
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>     close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>及时用 close 函数关闭通道引发结束通知，否则可能会导致死锁。</p>
<pre tabindex="0"><code>fatal error: all goroutines are asleep - deadlock!
</code></pre><p>通知可以是群体性的。也未必就是通知结束，可以是任何需要表达的事件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span> 	<span style="color:#a6e22e">ready</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span> 	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span> 		<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">id</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>       println(<span style="color:#a6e22e">id</span>, <span style="color:#e6db74">&#34;: ready.&#34;</span>) <span style="color:#75715e">// 运动员准备就绪
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ready</span> <span style="color:#75715e">// 等待发令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       println(<span style="color:#a6e22e">id</span>, <span style="color:#e6db74">&#34;: running...&#34;</span>)
</span></span><span style="display:flex;"><span>		 }(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>   println(<span style="color:#e6db74">&#34;Ready? Go!&#34;</span>)
</span></span><span style="display:flex;"><span>   close(<span style="color:#a6e22e">ready</span>) <span style="color:#75715e">// 砰！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>0 : ready.
2 : ready.
1 : ready.
Ready? Go!
1 : running...
0 : running...
2 : running...

一次性事件用 close 效率更好，没有多余开销。连续或多样性事件，可传递不同数据标志实现。
还可使用 sync.Cond 实现单播或广播事件。
</code></pre><p>对于 closed 或 nil 通道，发送和接收操作都有相应规则：</p>
<ul>
<li>向已关闭通道发送数据，引发 panic。</li>
<li>从已关闭接收数据，返回已缓冲数据或零值。</li>
<li>无论收发，nil 通道都会阻塞。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>   close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; cap(<span style="color:#a6e22e">c</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>     println(<span style="color:#a6e22e">i</span>, <span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#a6e22e">ok</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}	
</span></span></code></pre></div><pre tabindex="0"><code>0 : true 10
1 : true 20
2 : false 0
3 : false 0
</code></pre><p>重复关闭，或关闭 nil 通道都会引发 panic 错误。</p>
<pre tabindex="0"><code>panic: close of closed channel
panic: close of nil channel
</code></pre><h3 id="单向">
  单向
  <a class="anchor" href="#%e5%8d%95%e5%90%91">#</a>
</h3>
<p>通道默认是双向的，并不区分发送和接收端。但某些时候，我们可限制收发操作的方向 来获得更严谨的操作逻辑。</p>
<p>尽管可用 make 创建单向通道，但那没有任何意义。通常使用类型转换来获取单向通 道，并分别赋予操作双方。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">send</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">recv</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">recv</span> {
</span></span><span style="display:flex;"><span>        println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span> }()
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">send</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>     	}
</span></span><span style="display:flex;"><span>     }()
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>不能在单向通道上做逆向操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">send</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">recv</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>     <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">send</span> <span style="color:#75715e">// 无效操作: &lt;-send (receive from send-only type chan&lt;- int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#a6e22e">recv</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// 无效操作: recv &lt;- 1 (send to receive-only type &lt;-chan int)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>同样，close 不能用于接收端。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">recv</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">c</span>
</span></span><span style="display:flex;"><span>   close(<span style="color:#a6e22e">recv</span>) <span style="color:#75715e">// 无效操作: close(recv) (cannot close receive-only channel)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>无法将单向通道重新转换回去。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">a</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">recv</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">send</span> <span style="color:#66d9ef">chan</span><span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">b</span> = (<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">recv</span>) <span style="color:#75715e">// 错误: cannot convert recv (type &lt;-chan int) to type chan int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">b</span> = (<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">send</span>) <span style="color:#75715e">// 错误: cannot convert send (type chan&lt;- int) to type chan int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="选择">
  选择
  <a class="anchor" href="#%e9%80%89%e6%8b%a9">#</a>
</h3>
<p>如要同时处理多个通道，可选用 select 语句。它会随机选择一个可用通道做收发操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>), make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 接收端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">name</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">x</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">ok</span>   <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>			)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> { <span style="color:#75715e">// 随机选择可用 channel 接收数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">a</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;a&#34;</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">b</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;b&#34;</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> { <span style="color:#75715e">// 如果任一通道关闭，则终止接收
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			println(<span style="color:#a6e22e">name</span>, <span style="color:#a6e22e">x</span>) <span style="color:#75715e">// 输出接收的数据信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 发送端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> { <span style="color:#75715e">// 随机选择发送 channel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>:
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>b 0
a 1
a 2
b 30
a 4
a 5
b 60
b 70
a 8
b 90
</code></pre><p>如要等全部通道消息处理结束（closed），可将已完成通道设置为 nil。这样它就会被阻 塞，不再被 select 选中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>), make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 接收端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">a</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> { <span style="color:#75715e">// 如果通道关闭，则设置为 nil，阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#a6e22e">a</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				println(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">b</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">b</span> = <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				println(<span style="color:#e6db74">&#34;b&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> { <span style="color:#75715e">// 全部结束，退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 发送端 a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">a</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">a</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 发送端 b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>b 0
b 10
b 20
b 30
b 40
a 0
a 1
a 2
</code></pre><p>即便是同一通道，也会随机选择 case 执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 接收端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> { <span style="color:#75715e">// 随机选择 case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
</span></span><span style="display:flex;"><span>				println(<span style="color:#e6db74">&#34;a1:&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">ok</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
</span></span><span style="display:flex;"><span>				println(<span style="color:#e6db74">&#34;a2:&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() { <span style="color:#75715e">// 发送端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> { <span style="color:#75715e">// 随机选择 case
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>:
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>a1: 0
a2: 10
a2: 2
a1: 30
a1: 40
a2: 50
a2: 60
a2: 7
a1: 8
a1: 90
a1: 0
</code></pre><p>当所有通道都不可用时，select 会执行 default 语句。如此可避开 select 阻塞，但须注意 处理外层循环，以免陷入空耗。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">done</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;data:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// 避免 select 阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>())
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>2016-04-01 17:22:07
2016-04-01 17:22:08
2016-04-01 17:22:09
2016-04-01 17:22:10
2016-04-01 17:22:11
data: 100
2016-04-01 17:22:12
</code></pre><p>也可用 default 处理一些默认逻辑。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>{ <span style="color:#75715e">// 数据缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> close(<span style="color:#a6e22e">done</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">data</span>[len(<span style="color:#a6e22e">data</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">i</span>: <span style="color:#75715e">// 生产数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// 当前通道已满，生成新的缓存通道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">data</span>, make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">done</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">data</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// 显示所有数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>		close(<span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">c</span> {
</span></span><span style="display:flex;"><span>			println(<span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="模式">
  模式
  <a class="anchor" href="#%e6%a8%a1%e5%bc%8f">#</a>
</h3>
<p>通常使用工厂方法将 goroutine 和通道绑定</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">receiver</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newReceiver</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">receiver</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">receiver</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">data</span>: make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">int</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> { <span style="color:#75715e">// 接收消息，直到通道被关闭
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			println(<span style="color:#e6db74">&#34;recv:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newReceiver</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span>) <span style="color:#75715e">// 关闭通道，发出结束通知
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Wait</span>() <span style="color:#75715e">// 等待接收者处理结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><pre tabindex="0"><code>recv: 1
recv: 2
</code></pre><p>鉴于通道本身就是一个并发安全的队列，可用作 ID generator、Pool 等用途。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pool</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newPool</span>(<span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">pool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">cap</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pool</span>) <span style="color:#a6e22e">get</span>() []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">v</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">v</span> = <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">p</span>: <span style="color:#75715e">// 返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// 返回失败，新建
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">v</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pool</span>) <span style="color:#a6e22e">put</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">b</span>: <span style="color:#75715e">// 放回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">default</span>: <span style="color:#75715e">// 放回失败，放弃
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>用通道实现信号量（semaphore）。</p>
<pre tabindex="0"><code>func main() {
	runtime.GOMAXPROCS(4)
	var wg sync.WaitGroup
	sem := make(chan struct{}, 2) // 最多允许 2 个并发同时执行
	for i := 0; i &lt; 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			sem &lt;- struct{}{} // acquire: 获取信号
			defer func() { &lt;-sem }() // release: 释放信号
			time.Sleep(time.Second * 2)
			fmt.Println(id, time.Now())
		}(i)
	}
	wg.Wait()
}
</code></pre><pre tabindex="0"><code>4 2016-02-19 18:24:09
0 2016-02-19 18:24:09
2 2016-02-19 18:24:11
1 2016-02-19 18:24:11
3 2016-02-19 18:24:13
</code></pre><p>标准库 time 提供了 timeout 和 tick channel 实现。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">After</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span>):
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;timeout ...&#34;</span>)
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Exit</span>(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tick</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Tick</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">tick</span>:
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>())
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;-</span>(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{})(<span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// 直接用 nil channel 阻塞进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>捕获 INT、TERM 信号，顺便实现一个简易的 atexit 函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">exits</span> = <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">RWMutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">funcs</span> []<span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">signals</span> <span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Signal</span>
</span></span><span style="display:flex;"><span>}{}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">atexit</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>()) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">funcs</span> = append(<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">funcs</span>, <span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">waitExit</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">signals</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">signals</span> = make(<span style="color:#66d9ef">chan</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Signal</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">signal</span>.<span style="color:#a6e22e">Notify</span>(<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">signals</span>, <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">SIGINT</span>, <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">SIGTERM</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">RLock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">f</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">funcs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">f</span>()         <span style="color:#75715e">// 即便某些函数 panic，延迟调用也能确保后续函数执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}                   <span style="color:#75715e">// 延迟调用按 FILO 顺序执行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">RUnlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">exits</span>.<span style="color:#a6e22e">signals</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atexit</span>(<span style="color:#66d9ef">func</span>() { println(<span style="color:#e6db74">&#34;exit1 ...&#34;</span>) })
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">atexit</span>(<span style="color:#66d9ef">func</span>() { println(<span style="color:#e6db74">&#34;exit2 ...&#34;</span>) })
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">waitExit</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="性能">
  性能
  <a class="anchor" href="#%e6%80%a7%e8%83%bd">#</a>
</h3>
<p>将发往通道的数据打包，减少传输次数，可有效提升性能。从实现上来说，通道队列依 旧使用锁同步机制，单次获取更多数据（批处理），可改善因频繁加锁造成的性能问 题。</p>
<p>虽然单次消耗更多内存，但性能提升非常明显。如将数组改成切片会造成更多内存分配次数。</p>
<h3 id="资源泄漏">
  资源泄漏
  <a class="anchor" href="#%e8%b5%84%e6%ba%90%e6%b3%84%e6%bc%8f">#</a>
</h3>
<p>通道可能会引发 goroutine leak，确切地说，是指 goroutine 处于发送或接收阻塞状态， 但一直未被唤醒。垃圾回收器并不收集此类资源，导致它们会在等待队列里长久休眠， 形成资源泄漏。</p>
<h2 id="同步">
  同步
  <a class="anchor" href="#%e5%90%8c%e6%ad%a5">#</a>
</h2>
<p>通道并非用来取代锁的，它们有各自不同的使用场景。通道倾向于解决逻辑层次的并发 处理架构，而锁则用来保护局部范围内的数据安全。</p>
<p>标准库 sync 提供了互斥和读写锁，另有原子操作等，可基本满足日常开发需要。 Mutex、RWMutex 的使用并不复杂，只有几个地方需要注意。</p>
<p>将 Mutex 作为匿名字段时，相关方法必须实现为 pointer-receiver，否则会因复制导致锁 机制失效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>) <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">5</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		println(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Sleep</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;read&#34;</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;write&#34;</span>)
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>write 0
read 0
read 1
write 1
write 2
read 2
read 3
write 3
write 4
read 4

锁失效，将 receiver 类型改为 *data 后正常。
也可用嵌入 *Mutex 来避免复制问题，但那需要专门初始化。
</code></pre><p>应将 Mutex 锁粒度控制在最小范围内，及早释放。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 错误用法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">url</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cache</span>[<span style="color:#e6db74">&#34;key&#34;</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">url</span>)      <span style="color:#75715e">// 该操作并不需要锁保护
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 正确用法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">doSomething</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">url</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cache</span>[<span style="color:#e6db74">&#34;key&#34;</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Unlock</span>()       <span style="color:#75715e">// 如使用 defer，则依旧将 Get 保护在内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#a6e22e">url</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Mutex 不支持递归锁，即便在同一 goroutine 下也会导致死锁。</p>
<pre tabindex="0"><code>func main() {
	var m sync.Mutex
	m.Lock()
	{
		m.Lock()
		m.Unlock()
	}
	m.Unlock()
}
</code></pre><pre tabindex="0"><code>fatal error: all goroutines are asleep - deadlock!
</code></pre><p>在设计并发安全类型时，千万注意此类问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cache</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cache</span>) <span style="color:#a6e22e">count</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cache</span>) <span style="color:#a6e22e">get</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">d</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">count</span>(); <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// count 重复锁定，导致死锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">d</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">d</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cache</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">data</span>: []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	println(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">get</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>fatal error: all goroutines are asleep - deadlock!
</code></pre><p>相关建议：</p>
<ul>
<li>对性能要求较高时，应避免使用 defer Unlock。</li>
<li>读写并发时，用 RWMutex 性能会更好一些。</li>
<li>对单个数据读写保护，可尝试用原子操作。</li>
<li>执行严格测试，尽可能打开数据竞争检查。</li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-概述">第一章 概述</a>
      <ul>
        <li><a href="#go语言特征">go语言特征</a>
          <ul>
            <li><a href="#设计初衷">设计初衷</a></li>
            <li><a href="#为什么没有继承">为什么没有继承</a></li>
            <li><a href="#为什么没有异常">为什么没有异常？</a></li>
            <li><a href="#为什么没有x">为什么没有X？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二章-类型">第二章 类型</a>
      <ul>
        <li><a href="#变量">变量</a>
          <ul>
            <li><a href="#定义">定义</a></li>
            <li><a href="#退化赋值"><strong>退化赋值</strong></a></li>
            <li><a href="#多变量赋值"><strong>多变量赋值</strong></a></li>
            <li><a href="#匿名变量"><strong>匿名变量</strong></a></li>
          </ul>
        </li>
        <li><a href="#命名">命名</a>
          <ul>
            <li><a href="#命名建议"><strong>命名建议：</strong></a></li>
            <li><a href="#空标识符"><strong>空标识符</strong></a></li>
          </ul>
        </li>
        <li><a href="#常量">常量</a>
          <ul>
            <li><a href="#定义-1">定义</a></li>
            <li><a href="#枚举">枚举</a></li>
            <li><a href="#展开">展开</a></li>
          </ul>
        </li>
        <li><a href="#基本类型">基本类型</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#引用类型">引用类型</a></li>
        <li><a href="#类型转换">类型转换</a>
          <ul>
            <li></li>
          </ul>
        </li>
        <li><a href="#自定义类型">自定义类型</a>
          <ul>
            <li></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三章-表达式">第三章 表达式</a>
      <ul>
        <li><a href="#保留字">保留字</a></li>
        <li><a href="#运算符">运算符</a>
          <ul>
            <li><a href="#算术运算符">算术运算符</a></li>
            <li><a href="#关系运算符">关系运算符</a></li>
            <li><a href="#逻辑运算符"><strong>逻辑运算符</strong></a></li>
            <li><a href="#位运算符">位运算符</a></li>
            <li><a href="#赋值运算符">赋值运算符</a></li>
            <li><a href="#其他运算符">其他运算符</a></li>
            <li><a href="#运算符优先级">运算符优先级</a></li>
          </ul>
        </li>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#流程控制">流程控制</a>
          <ul>
            <li><a href="#ifelse">if&hellip;else&hellip;</a></li>
            <li><a href="#switch">switch</a></li>
            <li><a href="#for">for</a></li>
            <li><a href="#select语句">select语句</a></li>
            <li><a href="#goto-continuebreak">goto, continue,break</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四章-函数">第四章 函数</a>
      <ul>
        <li><a href="#定义-2">定义</a></li>
        <li><a href="#参数">参数</a>
          <ul>
            <li><a href="#变参">变参</a></li>
          </ul>
        </li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#匿名函数">匿名函数</a>
          <ul>
            <li><a href="#闭包">闭包</a></li>
          </ul>
        </li>
        <li><a href="#延迟调用">延迟调用</a></li>
        <li><a href="#错误处理">错误处理</a>
          <ul>
            <li><a href="#error">error</a></li>
            <li><a href="#panicrecover">panic,recover</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五章-数据">第五章 数据</a>
      <ul>
        <li><a href="#字符串">字符串</a>
          <ul>
            <li><a href="#字符串处理">字符串处理</a></li>
            <li><a href="#字符串转换">字符串转换</a></li>
            <li><a href="#unicode">unicode</a></li>
          </ul>
        </li>
        <li><a href="#数组">数组</a>
          <ul>
            <li><a href="#初始化-1">初始化</a></li>
            <li><a href="#指针">指针</a></li>
            <li><a href="#复制">复制</a></li>
          </ul>
        </li>
        <li><a href="#切片">切片</a>
          <ul>
            <li><a href="#reslice">reslice</a></li>
            <li><a href="#append">append</a></li>
            <li><a href="#copy">copy</a></li>
          </ul>
        </li>
        <li><a href="#字典">字典</a></li>
        <li><a href="#结构体">结构体</a>
          <ul>
            <li><a href="#json格式数据">JSON格式数据</a></li>
          </ul>
        </li>
        <li><a href="#指针-1">指针</a>
          <ul>
            <li><a href="#指向指针的指针">指向指针的指针</a></li>
            <li><a href="#指针作为函数参数">指针作为函数参数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六章-方法">第六章 方法</a>
      <ul>
        <li><a href="#定义-3">定义</a></li>
        <li><a href="#匿名字段">匿名字段</a></li>
        <li><a href="#方法集">方法集</a></li>
        <li><a href="#表达式">表达式</a>
          <ul>
            <li><a href="#method-expression">Method Expression</a></li>
            <li><a href="#method-value">Method Value</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第七章-接口">第七章 接口</a>
      <ul>
        <li><a href="#定义-4">定义</a></li>
        <li><a href="#执行机制">执行机制</a></li>
        <li><a href="#类型转换-1">类型转换</a></li>
        <li><a href="#技巧">技巧</a></li>
      </ul>
    </li>
    <li><a href="#第八章-并发">第八章 并发</a>
      <ul>
        <li><a href="#含义">含义</a>
          <ul>
            <li><a href="#wait">Wait</a></li>
            <li><a href="#gomaxprocs">GOMAXPROCS</a></li>
            <li><a href="#local-storage">Local Storage</a></li>
            <li><a href="#gosched">Gosched</a></li>
            <li><a href="#goexit">Goexit</a></li>
          </ul>
        </li>
        <li><a href="#通道">通道</a>
          <ul>
            <li><a href="#收发">收发</a></li>
            <li><a href="#单向">单向</a></li>
            <li><a href="#选择">选择</a></li>
            <li><a href="#模式">模式</a></li>
            <li><a href="#性能">性能</a></li>
            <li><a href="#资源泄漏">资源泄漏</a></li>
          </ul>
        </li>
        <li><a href="#同步">同步</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












