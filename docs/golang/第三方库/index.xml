<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>第三方库 on Soulmate</title>
    <link>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</link>
    <description>Recent content in 第三方库 on Soulmate</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 19 Apr 2023 20:05:22 +0800</lastBuildDate><atom:link href="https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>resty</title>
      <link>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/resty/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/resty/</guid>
      <description>介绍： # RESTful API 已成为现代 Web 开发的基石，可实现客户端与服务器之间的无缝通信。在本文中，我们将探索使用 Resty（一种流行的 HTTP 客户端库）在 Go 中执行常见操作（如 GET、POST、UPDATE 和 DELETE 请求）的强大功能和简便性。我们还将学习如何在请求中传递标头，从而使我们能够自定义和增强 API 交互。
网址：https://github.com/go-resty/resty
安装 Resty： # 首先，我们需要在 Go 环境中安装 Resty。我们可以使用以下命令来安装 Resty 包：
go get -u github.com/go-resty/resty/v2 GET # 发出 GET 请求： # 让我们首先研究如何使用 Resty v2 执行 GET 请求。以下代码片段演示了一个简单的 GET 请求并将响应绑定到结构体中：
package mainimport (&amp;#34;fmt&amp;#34;&amp;#34;log&amp;#34;&amp;#34;github.com/go-resty/resty/v2&amp;#34;)type DevUser struct {ID int `json:&amp;#34;id&amp;#34;`Name string `json:&amp;#34;name&amp;#34;`Email string `json:&amp;#34;email&amp;#34;`}func main() {var users []DevUserresponse, err := resty.</description>
    </item>
    
    <item>
      <title>diskqueue</title>
      <link>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/diskqueue/</link>
      <pubDate>Wed, 19 Apr 2023 20:05:22 +0800</pubDate>
      
      <guid>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/diskqueue/</guid>
      <description>diskqueue # github.com/nsqio/go-diskqueue 是 NSQ（一个实时分布式消息平台）官方团队开发的一个 Go 语言库，主要用于实现基于磁盘的持久化队列。它的核心作用是为消息系统提供可靠的消息存储和异步处理能力，尤其适合需要高吞吐、持久化和故障恢复的场景。
https://github.com/nsqio/go-diskqueue?tab=readme-ov-file
nsq # https://github.com/nsqio
NSQ是一个实时分布式消息传递平台，旨在大规模运行，每天处理数十亿条消息。
它支持分布式和去中心化拓扑，消除单点故障，实现容错和高可用性，并提供可靠的消息传递保证。请参阅功能和保障。
NSQ操作简单，易于配置和部署（所有参数均可在命令行中指定，且编译后的二进制文件无运行时依赖）。为了实现最大的灵活性，它与数据格式无关（消息可以是 JSON、MsgPack、Protocol Buffers 或其他任何格式）。官方的 Go 和 Python 库开箱即用（以及许多其他客户端库），如果您有兴趣构建自己的客户端，可以参考协议规范。
案例： # 实现队列缓冲，当有大量的数据需要缓存，并且需要保证前后顺序一致，就能用到这个
// Helper for serialization (using gob as an example)func serializeDetectionResult(data *file2.DetectionResult) ([]byte, error) {var buf bytes.Bufferencoder := gob.NewEncoder(&amp;amp;buf)if err := encoder.Encode(data); err != nil {return nil, fmt.Errorf(&amp;#34;failed to serialize DetectionResult: %w&amp;#34;, err)}return buf.Bytes(), nil}func deserializeDetectionResult(data []byte) (*file2.</description>
    </item>
    
    <item>
      <title>gofpdf</title>
      <link>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gofpdf/</link>
      <pubDate>Wed, 19 Apr 2023 20:05:22 +0800</pubDate>
      
      <guid>https://chain-code.github.io/docs/golang/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/gofpdf/</guid>
      <description>gofpdf # gofpdf 包实现了一个 PDF 文档生成器，它对文本、绘图和图像具有高级支持。
https://github.com/jung-kurt/gofpdf</description>
    </item>
    
  </channel>
</rss>
