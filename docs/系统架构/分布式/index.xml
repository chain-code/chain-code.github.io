<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Soulmate</title>
    <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Soulmate</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Elastic Search面试题</title>
      <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/elasticsearch%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>为什么使用Elastic Search？和传统关系型数据库有什么不同？ # 数据类型 # ElasticSearch是基于文档的搜索引擎，它使用json文档来存储数据。在Elastic search中，相关数据通常存储在一个文档中，而不是分数在多个表中。
mysql是一个关系型数据库管理系统，它使用表、行和列的结构来组织数据。数据通过外键关系分散在多个表中。
查询语言 # ElasticSearch使用Query DSL，是一种非常灵活的查询语言，基于json，支持全文搜索、复合查询、过滤以及聚合等。
Mysql使用SQL，是一种强类型和非常成熟的语言，专门用于查询和管理关系型数据库。
全文搜索 # ElasticSerach的**核心功能是全文搜索。**它对数据进行索引时会自动建立全文搜索引擎，使其在搜索大量文本数据时表现优异。
Mysql虽然也提供了全文搜索功能，但其主要设计目标是处理结构化数据的存储和查询，对全文搜索的支持不如Elastic Search.
事务支持 # Elasticsearch不支持传统事务。虽然它确保了单个文档操作的原子性，但不适用于跨多个文档的复杂事务。
主要场景和优势 # Elasticsearch是一个开源的分布式搜索和分析引擎，主要适用于以下场景：
搜索引擎：用于快速检索文档、商品、新闻等 日志分析：通过分析日志数据，帮助企业了解其业务性能情况。 数据分析：帮助数据科学家和数据分析师进行数据分析，以获取有价值信息。 商业智能：帮助企业制定数据驱动决策，已实现商业上的成功 实时监控：帮助企业实时检测系统性能、监控数据变化，以保证系统正常运行。 安全性：帮助企业保证数据安全性，保证数据不被非法窃取 应用程序开发：帮助开发人员开发基于搜索的应用程序，以增加用户体验。 优势：
高性能：具有高性能搜索和分析能力，其中涵盖了多种查询语言和数据结构 可扩展性：是分布式的，可以通过增加节点数量扩展搜索和分析能力 灵活性：支持多种数据类型，支持多种语言，支持动态映射，允许快速地调整模型以适应不同需求 实时分析：支持实时分析，可以对数据进行实时查询，这对快速检索数据非常有用 可靠性：具有可靠性和高可用性，支持数据备份和恢复。 Elasticsearch为什么这么快？ # Elasticsearch是一个高性能、分布式搜索引擎，它之所以快，主要有以下几个原因：
分布式存储：Elasticsearch使用分布式存储技术，将数据存储在多个节点上，从而减少单个节点的压力，提高整体性能。 索引分片：Elasticsearch把每个索引划分成多个分片，这样可以让查询操作并行化，从而提高查询速度。 全文索引：Elasticsearch使用了高效的全文索引技术，把文档转化成可搜索的结构化数据，使得搜索操作快速高效。 倒排索引：Elasticsearch支持倒排索引这种数据结构，**倒排索引将文档中的每个词与该词出现在哪些文档中进行映射，并存储这些信息。**当搜索请求发生时，ES可以快速查找包含所有搜索词的文档，从而返回结果。 索引优化：Elasticsearch通过索引优化技术，可以使查询速度更快。例如，它支持索引覆盖、索引下推等优化技术，使得查询速度更快。 预存储结果：Elasticsearch在插入数据时，对数据进行预处理，把结果预存储到索引中，从而在查询时不需要再重新计算，提高查询速度。 高效的查询引擎：Elasticsearch使用了高效的查询引擎，支持各种类型的查询，并对复杂查询提供了优化策略，从而提高查询速度。 异步请求处理：ES使用了异步请求处理机制，能够在请求到达时立即返回，避免长时间的等待，提高用户体验。 内存存储：ES使用了内存存储技术，能够在读写数据时大大减少磁盘访问次数，提高数据存储和查询效率。 倒排索引是什么？ # 在 ElasticSearch 中，倒排索引是一种常用的索引结构，用于快速搜索文档中的某个词汇。
倒排索引的结构与传统的索引结构相反，传统的索引结构是由文档构成的，每个文档包含了若干个词汇，然后根据这些词汇建立索引。而倒排索引是由词汇构成的，每个词汇对应了若干个文档，然后根据这些文档建立索引。
对于一个包含多个词汇的文档，倒排索引会将每个词汇作为一个关键字（Term），然后记录下该词汇所在的文档编号（Document ID）及该词汇在文档中的位置（Term Position）。这样，当用户输入一个关键字时，就可以快速地查找到包含该关键字的文档编号，然后通过文档编号再查找到对应的文档内容。
**倒排索引的优点在于它可以快速定位包含关键字的文档，而且可以支持复杂的搜索操作，如词组搜索、通配符搜索等。**同时，由于倒排索引是由词汇构成的，因此在进行数据分析和统计时也非常有用。在 ElasticSearch 中，倒排索引是一种非常重要的索引结构，它被广泛应用于搜索引擎、日志分析、推荐系统等领域。
倒排索引建立过程 # ES中的倒排索引建立过程主要有2个步骤，分别是分词、建立倒排索引
比如我们现在有三份文档内容，分别是
id content 1 深入理解Java核心技术—Hollis 2 深入理解Java虚拟机—周志明 3 Java编程思想—布鲁斯·埃克尔 分词</description>
    </item>
    
    <item>
      <title>Rabbit Mq面试题</title>
      <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/rabbitmq%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description></description>
    </item>
    
    <item>
      <title>分布式面试题</title>
      <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description> 什么是分布式系统？和集群的区别？ # 分布式就是把一个集中式系统拆分成多个系统，每一个系统单独对外提供部分功能，整个分布式系统整体对外提供一整套服务。对于访问分布式系统的用户来说，感知上就像访问一台计算机一样。
分布式（distributed）是指在多台不同的服务器中部署不同的服务模块，通过远程调用协同工作，对外提供服务。
集群（cluster）是指在多台不同的服务器中部署相同应用或服务模块，构成一个集群，通过负载均衡设备对外提供服务。
什么是分布式系统的一致性？ # 所谓一致性，是指数据在多个副本之间是否能够保持一致的特性。
大的分类上面，主要有三种，分别是强一致性、弱一致性和最终一致性：
强一致性模型（Strong Consistency）： 在强一致性模型下，系统保证每个读操作都将返回最近的写操作的结果，即任何时间点，客户端都将看到相同的数据视图。这包括线性一致性（Linearizability）、顺序一致性（Sequential Consistency）和严格可串行性（Strict Serializability）等子模型。强一致性模型通常牺牲了可用性来实现数据一致性。 弱一致性模型（Weak Consistency）： 弱一致性模型放宽了一致性保证，它允许在不同节点之间的数据访问之间存在一定程度的不一致性，以换取更高的性能和可用性。这包括因果一致性（Causal Consistency）、会话一致性（Session Consistency）和单调一致性（Monotonic Consistency）等子模型。弱一致性模型通常更注重可用性，允许一定程度的数据不一致性。 最终一致性模型（Eventual Consistency）： 最终一致性模型是一种最大程度放宽了一致性要求的模型。它允许在系统发生分区或网络故障后，经过一段时间，系统将最终达到一致状态。这个模型在某些情况下提供了很高的可用性，但在一段时间内可能会出现数据不一致的情况。 线性一致性和顺序一致性 # 线性一致性是一种最强的一致性模型，它强调在分布式系统中的任何时间点，读操作都应该返回最近的写操作的结果。
顺序一致性也是一种强一致性模型，但相对于线性一致性而言，它放宽了一些限制。在顺序一致性模型中，系统维护一个全局的操作顺序，以确保每个客户端看到的操作顺序都是一致的。
与线性一致性不同，顺序一致性不强调实时性，只要操作的顺序是一致的，就可以接受一些延迟。
什么是一致性哈希？ # 一致性哈希是一种用于分布式系统中数据分片和负载均衡的算法。它的目标是在节点的动态增加或删除时，尽可能的减少数据迁移和重新分布的成本。
实现一致性哈希算法首先需要构造一个哈希环，然后把他划分为固定数量的虚拟节点，如2^32。那么他的节点编号就是 0-2^32-1：
接下来， 我们把128张表作为节点映射到这些虚拟节点上，每个节点在哈希空间上都有一个对应的虚拟节点：
hash(table_0000)%2^32、hash(table_0001)%2^32、hash(table_0002)%2^32 &amp;hellip;. hash(table_0127)%2^32
在把这些表做好hash映射之后，我们就需要存储数据了，现在我们要把一些需要分表的数据也根据同样的算法进行hash，并且也将其映射哈希环上。
hash(buyer_id)%2^32：hash(12321)%2^32、hash(34432)%2^32、hash(54543)%2^32 &amp;hellip;. hash(767676)%2^32
这样，这个hash环上的虚拟节点就包含两部分数据的映射了，一部分是存储数据的分表的映射，一部分是真实要存储的数据的映射。
那么， 我们最终还是要把这些数据存储到数据库分表中，那么做好哈希之后，这些数据又要保存在哪个数据库表节点中呢？
其实很简单，只需要按照数据的位置，沿着顺时针方向查找，找到的第一个分表节点就是数据应该存放的节点：
因为要存储的数据，以及存储这些数据的数据库分表，hash后的值都是固定的，所以在数据库数量不变的情况下，下次想要查询数据的时候，只需要按照同样的算法计算一次就能找到对应的分表了。
以上，就是一致性hash算法的原理，那么，再回到我们开头的问题，如果我要增加一个分表怎么办呢？
我们首先要将新增加的表通过一致性hash算法映射到哈希环的虚拟节点中：
这样，会有一部分数据，因为节点数量发生变化，那么他顺时针遇到的第一个分表可能就变了。
相比于普通hash算法，在增加服务器之后，影响的范围非常小，只影响到一部分数据，其他的数据是不需要调整的。
优点：
数据均衡：在增加或删除节点时，一致性哈希算法只会影响到少量的数据迁移，保持了数据的均衡性。
高扩展性：当节点数发生变化时，对于已经存在的数据，只有部分数据需要重新分布，不会影响到整体的数据结构。
缺点：
hash倾斜：在节点数较少的情况下，由于哈希空间是有限的，节点的分布可能不够均匀，导致数据倾斜。
节点的频繁变更：如果频繁添加或删除节点，可能导致大量的数据迁移，造成系统压力。
哈希倾斜 # 其实，hash倾斜带来的主要问题就是如果数据过于集中的话，就会使得节点数量发生变化时，数据的迁移成本过高。
那么想要解决这个问题，比较好的办法就是增加服务器节点，这样节点就会尽可能的分散了。
但是如果没有那么多服务器，我们也可以引入一些虚拟节点，把一个服务器节点，拆分成多个虚拟节点，然后数据在映射的时候先映射到虚拟节点，然后虚拟节点在找到对应的物理节点进行存储和读取就行了。
常见的分布式事务有哪些？ # 分布式事务的目的是保证分布式系统中的多个参与方的数据能够保证一致性。
一致性分为强一致性，和最终一致性。
如果想要强一致性，就一定要引入协调者，通过协调者来协调所有参与者进行提交或者回滚。
这类方案包含基于XA规范的二阶段即三阶段提交、以及支持2节点提交。
什么是XA规范？ # 有了二阶段提交为什么还需要3阶段提交？ # </description>
    </item>
    
    <item>
      <title>场景题</title>
      <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%9C%BA%E6%99%AF%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%9C%BA%E6%99%AF%E9%A2%98/</guid>
      <description>如何设计一个订单号生成服务？ # 唯一性：订单号必须保持唯一，uuid，Snowflake等。 数据量：在设计订单号的时候，需要充分的考虑到后续数据量变大的情况下该如何兼容。所以需要提前预留出足够的位数。 可读性：订单号应该易于理解和记忆，可以根据业务需求自定义订单号的格式和组成方式，例如使用时间戳、随机数、用户ID等信息来构造订单号。 基因法：订单系统到最后都可能会考虑分库分表，所以在最初设计订单号的时候，需要考虑将和分表有关的字段编码到订单号中，如买家ID等。 可扩展性：订单号生成服务需要支持高并发、分布式部署和横向扩展等特性，可以采用分布式ID生成器、Redis等技术来实现。 高性能：订单号生成服务需要具有高性能和低延迟的特点，可以使用内存缓存、异步处理等技术来优化性能。 高可用：订单号生成服务需要保证高可用性，可以使用多节点部署、负载均衡、健康检查等技术来提高系统的可靠性和稳定性。 通过2位数字表示业务类型，如交易订单、支付单、结算单等都是不同的业务类型，可以有不同的编号。中间的18-20位用一个唯一的ID来表示，可以用雪花算法，也可以用Leaf，总之就是他需要保证唯一性。最后4位，基于基因法，将分表后的结果获取到，把他也编码到订单号中。
订单到期关闭如何实现？ # 定时任务，最简单，最方便
redis过期监听不推荐，因为Redis官网上明确的说过，Redis并不保证Key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的，随着数据量越大延迟越长，延迟个几分钟都是常事儿。
如何设计一个购物车功能？ # 未登陆购物车
对于未登录的用户，其实他的购物车的信息没必要存储在后端，只需要在客户端做临时缓存就行了。客户端存储可以选择Cookie 和 LocalStorage等技术。
在存储时，只需要设计一个JSON格式就可以了，因为用户没登录，所以也就不需要标识数据属于谁，那么只需要如下存储即可：
{ &amp;#34;cart&amp;#34;: [ { &amp;#34;SKUID&amp;#34;: 10086, &amp;#34;timestamp&amp;#34;: 1666513990, &amp;#34;count&amp;#34;: 2 }, { &amp;#34;SKUID&amp;#34;: 10010, &amp;#34;timestamp&amp;#34;: 1666513990, &amp;#34;count&amp;#34;: 10 } ] } 已登陆
如果是使用数据库，那么就直接建表存储就行了，表中主要需要包含user_id、sku_id、count、time_stamp等几个业务字段就可以了。这样每一个加过购物车的用户都有一条记录。
如果使用Redis来保存的话，其实也简单，只需要在上面的未登录用户的购物车的基础上增加一个user_id作为key就行了：
{ &amp;#34;KEY&amp;#34;: 12343123, &amp;#34;VALUE&amp;#34;: [ { &amp;#34;SKUID&amp;#34;: 10086, &amp;#34;timestamp&amp;#34;: 1666513990, &amp;#34;count&amp;#34;: 2 }, { &amp;#34;SKUID&amp;#34;: 10010, &amp;#34;timestamp&amp;#34;: 1666513990, &amp;#34;count&amp;#34;: 10 } ] } 如果你的业务量突然提升100倍QPS，怎么做？ # 正常情况</description>
    </item>
    
    <item>
      <title>高并发高可用</title>
      <link>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://chain-code.github.io/docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
      <description>如何设计一个支持高并发的系统？ # 设计一个能够支持高并发的系统需要考虑多方面的因素，包括架构、性能优化、容错和可伸缩性等。以下是一些一般性的建议和实践。
分布式架构：将系统分解成多个模块，采用分布式架构来降低单点故障的风险，并提高系统的可伸缩性和性能。
集群部署：将一个服务通过集群进行部署，来提升系统整体的吞吐量及响应速度，并使用负载均衡技术将请求均衡分配给多个服务器，以提高系统的性能和可用性。
利用缓存：使用缓存、NoSQL等技术，以提高数据读写的性能和可靠性。
异步处理：采用异步处理机制，如使用消息队列、事件驱动等技术，以降低请求响应时间和提高系统吞吐量。
预加载：使用预加载技术来提前加载需要的资源，以减少用户等待时间。
代码优化和调优：对系统代码进行优化和调优，如采用异步I/O、避免锁（减小锁的粒度）、减少循环和递归、避免长事务等，以提高系统性能。
数据库优化：合理的数据库设计和优化，包括合理的索引设计、分库分表、读写分离、缓存优化等，可以有效提高系统的并发度和响应速度。
读写分离：读写分离是一种常用的数据库优化技术，它将读操作和写操作分配到不同的数据库实例上处理。通过读写分离，主库主要负责写操作，从库则负责读操作，从而提高了系统的并发度和可扩展性。同时，读写分离还可以提高系统的可用性和容错能力，因为即使主库出现故障，从库仍然可以提供读服务。
防止雪崩：通过使用限流、熔断、降级等技术，可以防止系统因为某个组件出现故障而导致整个系统崩溃的雪崩效应。
容错和监控：实现容错机制，如备份、容灾、负载降级等，以保障系统的可用性。同时，使用监控工具来实时监测系统的运行状况和性能瓶颈，及时做出调整和优化。
测试和评估：进行全面的性能测试和评估，包括压力测试、负载测试、安全测试等，以发现并解决系统的性能瓶颈和安全隐患。
什么是服务降级？ # 限流和降级都是对系统的保护功能，一般用户在流量高峰时期，比如双十一大促。
降级是通过开关配置将某些不重要的业务功能屏蔽掉，以提高服务处理能力。在大促场景中经常会对某些服务进行降级处理，大促结束之后再进行复原。
区别于熔断机制，降级一般并不是彻底功能不可用，而是用一种默认返回、异步执行、延迟处理等方式进行降低处理。
比如：在大促期间减少反馈问卷等功能推送
降级方式 # 异步处理：先让用户填手机号，等用户离店后，再短信推送调查问卷
延迟处理：门口放一个问卷表，用户离店时自愿去填写。
什么是熔断？ # 现在很多网站的背后都是一个庞大的分布式系统，多个系统之间的交互大多数都是采用RPC的方式，但是因为是远程调用，所以被调用者的服务的可用情况其实是不可控的。
而越是庞大的系统，上下游的调用链就会越长，而如果在一个很长的调用链中，某一个服务由于某种原因导致响应时间很长，或者完全无响应，那么就可能把整个分布式系统都拖垮。
如果其中某一个服务由于自身原因导致响应很慢，那么就可能导致上游的服务相应也很慢，这样循环往复，就会导致整个系统全线崩溃，这就是服务雪崩。
在服务的依赖调用中，当被调用方出现故障时，出于自我保护的目的，调用方会主动停止调用，并根据业务需要进行相应处理。调用方这种主动停止调用的行为我们称之为熔断。
为什么需要熔断 # 其实，在分布式系统中，为了保证整体服务可用性和一致性，很多系统都会引入重试机制，在有些情况下，重试其实是可以解决问题的，比如网络问题等，都可以通过重试来解决。
但是，有些情况下，重试并不能解决问题，反而会加剧问题的严重性，比如下游系统因为请求量太大，导致CPU已经被打满，数据库连接池被占满，这时候上游系统调不通就会不断进行重试，这种重试请求，对于下游系统来说，无疑是雪上加霜，给下游系统造成二次伤害。
一个比较完善的熔断器，一般包含三种状态：
关闭：熔断器在默认情况下下是呈现关闭的状态，而熔断器本身带有计数功能，每当错误发生一次，计数器也就会进行“累加”的动作，到了一定的错误发生次数断路器就会被“开启”，这个时候亦会在内部启用一个计时器，一旦时间到了就会切换成半开启的状态。 开启：在开启的状态下任何请求都会“直接”被拒绝并且抛出异常讯息。 半开启：在此状态下断路器会允许部分的请求，如果这些请求都能成功通过，那么就意味着错误已经不存在，则会被切换回关闭状态并重置计数。倘若请求中有“任一”的错误发生，则会恢复到“开启”状态，并且重新计时，给予系统一段休息时间。 什么是预热？有何作用？ # 缓存预热是指在系统启动之前或系统达到高峰期之前，通过预先将常用数据加载到缓存中，以提高缓存命中率和系统性能的过程。缓存预热的目的是尽可能地避免缓存击穿和缓存雪崩，还可以减轻后端存储系统的负载，提高系统的响应速度和吞吐量。
减少冷启动影响：当系统重启或新启动时，缓存是空的，这被称为冷启动。冷启动可能导致首次请求处理缓慢，因为数据需要从慢速存储（如数据库）检索。 提高数据访问速度：通过预先加载常用数据到缓存中，可以确保数据快速可用，从而加快数据访问速度。 平滑流量峰值：在流量高峰期之前预热缓存可以帮助系统更好地处理高流量，避免在流量激增时出现性能下降。 保证数据的时效性：定期预热可以保证缓存中的数据是最新的，特别是对于高度依赖于实时数据的系统。 减少对后端系统的压力：通过缓存预热，可以减少对数据库或其他后端服务的直接查询，从而减轻它们的负载。 什么是限流？常见的限流算法有哪些？ # 漏桶算法（常用）：系统请求先进入漏桶，再从漏桶中逐一取出请求执行，控制漏桶的流量。 令牌桶算法（常用）：系统请求会得到一个令牌，从令牌桶中取出一个令牌执行，控制令牌桶中令牌的数量。 计数器算法（简单）：系统请求被计数，通过比较当前请求数与限流阈值来判断是否限流。 可以阻塞算法：当系统达到限流阈值时，不再接受新请求，等到限流阈值降下来再接受请求。 令牌环算法：与令牌桶算法类似，但是在多个令牌桶之间形成环形结构，以便在不同的请求处理速率之间进行平衡。 最小延迟算法：基于预测每个请求的处理时间，并在处理完请求后进行延迟，以控制请求的速率。 滑动窗口（常用）：基于一个固定大小的时间窗口，允许在该时间窗口内的请求数不超过设定的阈值。这个时间窗口随着时间的推移不断滑动，以适应不同时间段内的请求流量。 单机限流和集群限流的区别是什么？ # 一个是针对单台服务器限流，一个是针对整个集群做限流。比如单机限100，那么就是单机最大就能抗100QPS，如果是集群限100，那么就意味着集群不管有多少台机器，总共 QPS 只能抗100。
集群限流通常需要使用分布式的限流算法和工具，比如 Redis、Sentinel、Hystrix等，以确保每个服务实例或节点都遵守全局的流量控制策略。
有了集群限流，还需要做单机限流吗？ # 需要
因为单机限流主要关注保护单个服务节点。即使集群级别有流量控制，单个实例依然可能因为本地的请求过多而出现性能问题或崩溃。
有了单机限流，还需要做集群限流吗？ # 一般来说也需要</description>
    </item>
    
  </channel>
</rss>
